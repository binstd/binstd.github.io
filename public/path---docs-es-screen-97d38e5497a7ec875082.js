webpackJsonp([0x7151e482348a],{872:function(e,o){e.exports={data:{currentPage:{html:'<h1>Construir una pantalla</h1>\n<p>Nos hemos concentrado en crear interfaces de usuario de abajo hacia arriba; comenzando por lo pequeño y añadiendo complejidad. Esto nos ha permitido desarrollar cada componente de forma aislada, determinar los datos que necesita y jugar con ellos en Storybook. Todo sin necesidad de levantar un servidor o construir pantallas!</p>\n<p>En este capítulo continuaremos aumentando la sofisticación combinando componentes en una pantalla y desarrollando esa pantalla en Storybook.</p>\n<h2>Componentes de contenedor anidados</h2>\n<p>Como nuestra aplicación es muy simple, la pantalla que construiremos es bastante trivial, simplemente envolviendo el componente <code>TaskList</code> (que proporciona sus propios datos a través de Redux) en alguna maqueta y sacando un campo <code>error</code> de primer nivel de redux (asumamos que pondremos ese campo si tenemos algún problema para conectarnos a nuestro servidor):</p>\n<pre><code class="language-javascript">import React from \'react\';\nimport PropTypes from \'prop-types\';\nimport { connect } from \'react-redux\';\n\nimport TaskList from \'./TaskList\';\n\nexport function PureInboxScreen({ error }) {\n  if (error) {\n    return (\n      &#x3C;div className="page lists-show">\n        &#x3C;div className="wrapper-message">\n          &#x3C;span className="icon-face-sad" />\n          &#x3C;div className="title-message">Oh no!&#x3C;/div>\n          &#x3C;div className="subtitle-message">Algo va mal&#x3C;/div>\n        &#x3C;/div>\n      &#x3C;/div>\n    );\n  }\n\n  return (\n    &#x3C;div className="page lists-show">\n      &#x3C;nav>\n        &#x3C;h1 className="title-page">\n          &#x3C;span className="title-wrapper">Taskbox&#x3C;/span>\n        &#x3C;/h1>\n      &#x3C;/nav>\n      &#x3C;TaskList />\n    &#x3C;/div>\n  );\n}\n\nPureInboxScreen.propTypes = {\n  error: PropTypes.string,\n};\n\nPureInboxScreen.defaultProps = {\n  error: null,\n};\n\nexport default connect(({ error }) => ({ error }))(PureInboxScreen);\n</code></pre>\n<p>También cambiamos el componente <code>App</code> para renderizar la pantalla de la bandeja de entrada <code>InboxScreen</code> (normalmente usaríamos un router para elegir la pantalla correcta, pero no nos preocupemos por ello aquí):</p>\n<pre><code class="language-javascript">import React, { Component } from \'react\';\nimport { Provider } from \'react-redux\';\nimport store from \'./lib/redux\';\n\nimport InboxScreen from \'./components/InboxScreen\';\n\nclass App extends Component {\n  render() {\n    return (\n      &#x3C;Provider store={store}>\n        &#x3C;InboxScreen />\n      &#x3C;/Provider>\n    );\n  }\n}\n\nexport default App;\n</code></pre>\n<p>Sin embargo, donde las cosas se ponen interesantes es en la representación de la historia en Storybook.</p>\n<p>Como vimos anteriormente, el componente <code>TaskList</code> es un <strong>contenedor</strong> que renderiza el componente de presentación <code>PureTaskList</code>. Por definición, los componentes de un contenedor no pueden simplemente hacer render de forma aislada; esperan que se les pase algún contexto o que se conecten a un servicio. Lo que esto significa es que para hacer render de un contenedor en Storybook, debemos mockearlo (es decir, proporcionar una versión ficticia) del contexto o servicio que requiere.</p>\n<p>Al colocar la "Lista de tareas" <code>TaskList</code> en Storybook, pudimos esquivar este problema simplemente renderizando la <code>PureTaskList</code> y evadiendo el contenedor. Haremos algo similar y renderizaremos la <code>PureInboxScreen</code> en Storybook también.</p>\n<p>Sin embargo, para la <code>PureInboxScreen</code> tenemos un problema porque aunque la <code>PureInboxScreen</code> en si misma es presentacional, su hijo, la <code>TaskList</code>, no lo es. En cierto sentido la <code>PureInboxScreen</code> ha sido contaminada por la "contenedorización". Así que cuando preparamos nuestras historias:</p>\n<pre><code class="language-javascript">import React from \'react\';\nimport { storiesOf } from \'@storybook/react\';\n\nimport { PureInboxScreen } from \'./InboxScreen\';\n\nstoriesOf(\'InboxScreen\', module)\n  .add(\'default\', () => &#x3C;PureInboxScreen />)\n  .add(\'error\', () => &#x3C;PureInboxScreen error="Something" />);\n</code></pre>\n<p>Vemos que aunque la historia de <code>error</code> funciona bien, tenemos un problema en la historia <code>default</code>, porque la <code>TaskList</code> no tiene una store de Redux a la que conectarse. (También encontrarás problemas similares cuando intentes probar la <code>PureInboxScreen</code> con un test unitario).</p>\n<p><img src="/broken-inboxscreen.png" alt="Broken inbox"></p>\n<p>Una forma de evitar este problema es nunca renderizar componentes contenedores en ninguna parte de tu aplicación excepto en el nivel más alto y en su lugar pasar todos los datos requeridos bajo la jerarquía de componentes.</p>\n<p>Sin embargo, los desarrolladores <strong>necesitarán</strong> inevitablemente renderizar los contenedores más abajo en la jerarquía de componentes. Si queremos renderizar la mayor parte o la totalidad de la aplicación en Storybook (¡lo hacemos!), necesitamos una solución a este problema.</p>\n<div class="aside">\nPor otro lado, la transmisión de datos a nivel jerárquico es un enfoque legítimo, especialmente cuando utilizas <a href="http://graphql.org/">GraphQL</a>. Así es como hemos construido <a href="https://chromaticqa.com">Chromatic</a> junto a más de 670+ historias.\n</div>\n<h2>Suministrando contexto con decoradores</h2>\n<p>La buena noticia es que es fácil suministrar una store de Redux a la <code>InboxScreen</code> en una historia! Podemos usar una versión mockeada de la store de Redux provista en un decorador:</p>\n<pre><code class="language-javascript">import React from \'react\';\nimport { storiesOf } from \'@storybook/react\';\nimport { action } from \'@storybook/addon-actions\';\nimport { Provider } from \'react-redux\';\n\nimport { PureInboxScreen } from \'./InboxScreen\';\nimport { defaultTasks } from \'./TaskList.stories\';\n\n// Un mock super simple de un store de redux\nconst store = {\n  getState: () => {\n    return {\n      tasks: defaultTasks,\n    };\n  },\n  subscribe: () => 0,\n  dispatch: action(\'dispatch\'),\n};\n\nstoriesOf(\'InboxScreen\', module)\n  .addDecorator(story => &#x3C;Provider store={store}>{story()}&#x3C;/Provider>)\n  .add(\'default\', () => &#x3C;PureInboxScreen />)\n  .add(\'error\', () => &#x3C;PureInboxScreen error="Something" />);\n</code></pre>\n<p>Existen enfoques similares para proporcionar un contexto simulado para otras bibliotecas de datos, tales como <a href="https://www.npmjs.com/package/apollo-storybook-decorator">Apollo</a>, <a href="https://github.com/orta/react-storybooks-relay-container">Relay</a> y algunas otras.</p>\n<p>Recorrer los estados en Storybook hace que sea fácil comprobar que lo hemos hecho correctamente:</p>\n<video autoPlay muted playsInline loop >\n  <source\n    src="/finished-inboxscreen-states.mp4"\n    type="video/mp4"\n  />\n</video>\n<h2>Desarrollo basado en componentes</h2>\n<p>Empezamos desde abajo con <code>Task</code>, luego progresamos a <code>TaskList</code>, ahora estamos aquí con una interfaz de usuario de pantalla completa. Nuestra <code>InboxScreen</code> contiene un componente de contenedor anidado e incluye historias de acompañamiento.</p>\n<video autoPlay muted playsInline loop style="width:480px; height:auto; margin: 0 auto;">\n  <source\n    src="/component-driven-development-optimized.mp4"\n    type="video/mp4"\n  />\n</video>\n<p><a href="https://blog.hichroma.com/component-driven-development-ce1109d56c8e"><strong>El desarrollo basado en componentes</strong></a> te permite expandir gradualmente la complejidad a medida que asciendes en la jerarquía de componentes. Entre los beneficios están un proceso de desarrollo más enfocado y una mayor cobertura de todas las posibles mutaciones de la interfaz de usuario. En resumen, la CDD te ayuda a construir interfaces de usuario de mayor calidad y complejidad.</p>\n<p>Aún no hemos terminado, el trabajo no termina cuando se construye la interfaz de usuario. También tenemos que asegurarnos de que siga siendo duradero a lo largo del tiempo.</p>',frontmatter:{title:"Construir una pantalla",description:"Construir una pantalla con componentes",commit:"22a1898"},fields:{slug:"/docs/es/screen/",chapter:"screen",framework:"docs",language:"es"}},site:{siteMetadata:{title:"binstd-区块链云服务平台",toc:["get-started","simple-component","composite-component","data","screen","test","deploy","conclusion","contribute"],languages:["en","zh"],githubUrl:"https://github.com/hichroma/learnstorybook.com",codeGithubUrl:"https://github.com/hichroma/learnstorybook-code",siteUrl:"https://binstd.com"}},pages:{edges:[{node:{frontmatter:{tocTitle:"Componente Compuesto",title:"Ensamblar un componente compuesto",description:"Ensamblar un componente compuesto a partir de componentes simples"},fields:{slug:"/docs/es/composite-component/",chapter:"composite-component"}}},{node:{frontmatter:{tocTitle:null,title:"Conclusion",description:"Pon todo tu conocimiento junto y aprende más técnicas de Storybook"},fields:{slug:"/docs/es/conclusion/",chapter:"conclusion"}}},{node:{frontmatter:{tocTitle:null,title:"Contribuir",description:"Ayuda a compartir Storybook con el mundo"},fields:{slug:"/docs/es/contribute/",chapter:"contribute"}}},{node:{frontmatter:{tocTitle:"Datos",title:"Introducir datos",description:"Aprende como introducir datos a tus componentes UI"},fields:{slug:"/docs/es/data/",chapter:"data"}}},{node:{frontmatter:{tocTitle:"Desplegar",title:"Desplegar Storybook",description:"Desplegar Storybook online con GitHub y Netlify"},fields:{slug:"/docs/es/deploy/",chapter:"deploy"}}},{node:{frontmatter:{tocTitle:"Empezando",title:"Empezando",description:"Configurar React Storybook en tu entorno de desarrollo"},fields:{slug:"/docs/es/get-started/",chapter:"get-started"}}},{node:{frontmatter:{tocTitle:"Pantallas",title:"Construir una pantalla",description:"Construir una pantalla con componentes"},fields:{slug:"/docs/es/screen/",chapter:"screen"}}},{node:{frontmatter:{tocTitle:"Componente Simple",title:"Construye un componente simple",description:"Construye un componente simple en aislamiento"},fields:{slug:"/docs/es/simple-component/",chapter:"simple-component"}}},{node:{frontmatter:{tocTitle:null,title:"Testing",description:"Aprende las formas de hacer test a los componentes de la UI"},fields:{slug:"/docs/es/test/",chapter:"test"}}}]}},pathContext:{slug:"/docs/es/screen/",framework:"docs",language:"es",chapter:"screen"}}}});
//# sourceMappingURL=path---docs-es-screen-97d38e5497a7ec875082.js.map