{"version":3,"sources":["webpack:///path---docs-en-composite-component-60a2012f00bc1c4854f0.js","webpack:///./.cache/json/docs-en-composite-component.json"],"names":["webpackJsonp","859","module","exports","data","currentPage","html","frontmatter","title","description","commit","fields","slug","chapter","framework","language","site","siteMetadata","toc","languages","githubUrl","codeGithubUrl","siteUrl","pages","edges","node","tocTitle","pathContext"],"mappings":"AAAAA,cAAc,iBAERC,IACA,SAAUC,EAAQC,GCHxBD,EAAAC,SAAkBC,MAAQC,aAAeC,KAAA,s/UAAoyTC,aAAwuBC,MAAA,iCAAAC,YAAA,2DAAAC,OAAA,WAAqIC,QAAWC,KAAA,gCAAAC,QAAA,sBAAAC,UAAA,OAAAC,SAAA,OAA2GC,MAASC,cAAgBT,MAAA,kBAAAU,KAAA,kHAAAC,WAAA,WAAAC,UAAA,iDAAAC,cAAA,kDAAAC,QAAA,uBAA0UC,OAAUC,QAAUC,MAAQlB,aAAemB,SAAA,sBAAAlB,MAAA,iCAAAC,YAAA,4DAAmJE,QAAWC,KAAA,gCAAAC,QAAA,0BAA2EY,MAAQlB,aAAemB,SAAA,KAAAlB,MAAA,aAAAC,YAAA,uEAAyHE,QAAWC,KAAA,uBAAAC,QAAA,iBAAyDY,MAAQlB,aAAemB,SAAA,KAAAlB,MAAA,aAAAC,YAAA,uCAAyFE,QAAWC,KAAA,uBAAAC,QAAA,iBAAyDY,MAAQlB,aAAemB,SAAA,OAAAlB,MAAA,eAAAC,YAAA,kDAAwGE,QAAWC,KAAA,iBAAAC,QAAA,WAA6CY,MAAQlB,aAAemB,SAAA,SAAAlB,MAAA,mBAAAC,YAAA,mDAA+GE,QAAWC,KAAA,mBAAAC,QAAA,aAAiDY,MAAQlB,aAAemB,SAAA,cAAAlB,MAAA,cAAAC,YAAA,yDAAqHE,QAAWC,KAAA,wBAAAC,QAAA,kBAA2DY,MAAQlB,aAAemB,SAAA,UAAAlB,MAAA,qBAAAC,YAAA,wCAAuGE,QAAWC,KAAA,mBAAAC,QAAA,aAAiDY,MAAQlB,aAAemB,SAAA,mBAAAlB,MAAA,2BAAAC,YAAA,yCAAuHE,QAAWC,KAAA,6BAAAC,QAAA,uBAAqEY,MAAQlB,aAAemB,SAAA,KAAAlB,MAAA,UAAAC,YAAA,wCAAuFE,QAAWC,KAAA,iBAAAC,QAAA,aAA8Cc,aAAgBf,KAAA,gCAAAE,UAAA,OAAAC,SAAA,KAAAF,QAAA","file":"path---docs-en-composite-component-60a2012f00bc1c4854f0.js","sourcesContent":["webpackJsonp([219667607431145],{\n\n/***/ 859:\n/***/ (function(module, exports) {\n\n\tmodule.exports = {\"data\":{\"currentPage\":{\"html\":\"<h1>Assemble a composite component</h1>\\n<p>Last chapter we built our first component; this chapter extends what we learned to build TaskList, a list of Tasks. Let’s combine components together and see what happens when more complexity is introduced.</p>\\n<h2>Tasklist</h2>\\n<p>Taskbox emphasizes pinned tasks by positioning them above default tasks. This yields two variations of <code>TaskList</code> you need to create stories for: default items and default and pinned items.</p>\\n<p><img src=\\\"/tasklist-states-1.png\\\" alt=\\\"default and pinned tasks\\\"></p>\\n<p>Since <code>Task</code> data can be sent asynchronously, we <strong>also</strong> need a loading state to render in the absence of a connection. In addition, an empty state is required when there are no tasks.</p>\\n<p><img src=\\\"/tasklist-states-2.png\\\" alt=\\\"empty and loading tasks\\\"></p>\\n<h2>Get setup</h2>\\n<p>A composite component isn’t much different than the basic components it contains. Create a <code>TaskList</code> component and an accompanying story file: <code>src/components/TaskList.js</code> and <code>src/components/TaskList.stories.js</code>.</p>\\n<p>Start with a rough implementation of the <code>TaskList</code>. You’ll need to import the <code>Task</code> component from earlier and pass in the attributes and actions as inputs.</p>\\n<pre><code class=\\\"language-javascript\\\">import React from 'react';\\n\\nimport Task from './Task';\\n\\nfunction TaskList({ loading, tasks, onPinTask, onArchiveTask }) {\\n  const events = {\\n    onPinTask,\\n    onArchiveTask,\\n  };\\n\\n  if (loading) {\\n    return &#x3C;div className=\\\"list-items\\\">loading&#x3C;/div>;\\n  }\\n\\n  if (tasks.length === 0) {\\n    return &#x3C;div className=\\\"list-items\\\">empty&#x3C;/div>;\\n  }\\n\\n  return (\\n    &#x3C;div className=\\\"list-items\\\">\\n      {tasks.map(task => &#x3C;Task key={task.id} task={task} {...events} />)}\\n    &#x3C;/div>\\n  );\\n}\\n\\nexport default TaskList;\\n</code></pre>\\n<p>Next create <code>Tasklist</code>’s test states in the story file.</p>\\n<pre><code class=\\\"language-javascript\\\">import React from 'react';\\nimport { storiesOf } from '@storybook/react';\\n\\nimport TaskList from './TaskList';\\nimport { task, actions } from './Task.stories';\\n\\nexport const defaultTasks = [\\n  { ...task, id: '1', title: 'Task 1' },\\n  { ...task, id: '2', title: 'Task 2' },\\n  { ...task, id: '3', title: 'Task 3' },\\n  { ...task, id: '4', title: 'Task 4' },\\n  { ...task, id: '5', title: 'Task 5' },\\n  { ...task, id: '6', title: 'Task 6' },\\n];\\n\\nexport const withPinnedTasks = [\\n  ...defaultTasks.slice(0, 5),\\n  { id: '6', title: 'Task 6 (pinned)', state: 'TASK_PINNED' },\\n];\\n\\nstoriesOf('TaskList', module)\\n  .addDecorator(story => &#x3C;div style={{ padding: '3rem' }}>{story()}&#x3C;/div>)\\n  .add('default', () => &#x3C;TaskList tasks={defaultTasks} {...actions} />)\\n  .add('withPinnedTasks', () => &#x3C;TaskList tasks={withPinnedTasks} {...actions} />)\\n  .add('loading', () => &#x3C;TaskList loading tasks={[]} {...actions} />)\\n  .add('empty', () => &#x3C;TaskList tasks={[]} {...actions} />);\\n</code></pre>\\n<p><code>addDecorator()</code> allows us to add some “context” to the rendering of each task. In this case we add padding around the list to make it easier to visually verify.</p>\\n<div class=\\\"aside\\\">\\n<a href=\\\"https://storybook.js.org/addons/introduction/#1-decorators\\\"><b>Decorators</b></a> are a way to provide arbitrary wrappers to stories. In this case we’re using a decorator to add styling. They can also be used to wrap stories in “providers” –i.e. library components that set React context.\\n</div>\\n<p><code>task</code> supplies the shape of a <code>Task</code> that we created and exported from the <code>Task.stories.js</code> file. Similarly, <code>actions</code> defines the actions (mocked callbacks) that a <code>Task</code> component expects, which the <code>TaskList</code> also needs.</p>\\n<p>Now check Storybook for the new <code>TaskList</code> stories.</p>\\n<video autoPlay muted playsInline loop>\\n  <source\\n    src=\\\"/inprogress-tasklist-states.mp4\\\"\\n    type=\\\"video/mp4\\\"\\n  />\\n</video>\\n<h2>Build out the states</h2>\\n<p>Our component is still rough but now we have an idea of the stories to work toward. You might be thinking that the <code>.list-items</code> wrapper is overly simplistic. You're right – in most cases we wouldn’t create a new component just to add a wrapper. But the <strong>real complexity</strong> of <code>TaskList</code> component is revealed in the edge cases <code>withPinnedTasks</code>, <code>loading</code>, and <code>empty</code>.</p>\\n<pre><code class=\\\"language-javascript\\\">import React from 'react';\\n\\nimport Task from './Task';\\n\\nfunction TaskList({ loading, tasks, onPinTask, onArchiveTask }) {\\n  const events = {\\n    onPinTask,\\n    onArchiveTask,\\n  };\\n\\n  const LoadingRow = (\\n    &#x3C;div className=\\\"loading-item\\\">\\n      &#x3C;span className=\\\"glow-checkbox\\\" />\\n      &#x3C;span className=\\\"glow-text\\\">\\n        &#x3C;span>Loading&#x3C;/span> &#x3C;span>cool&#x3C;/span> &#x3C;span>state&#x3C;/span>\\n      &#x3C;/span>\\n    &#x3C;/div>\\n  );\\n\\n  if (loading) {\\n    return (\\n      &#x3C;div className=\\\"list-items\\\">\\n        {LoadingRow}\\n        {LoadingRow}\\n        {LoadingRow}\\n        {LoadingRow}\\n        {LoadingRow}\\n        {LoadingRow}\\n      &#x3C;/div>\\n    );\\n  }\\n\\n  if (tasks.length === 0) {\\n    return (\\n      &#x3C;div className=\\\"list-items\\\">\\n        &#x3C;div className=\\\"wrapper-message\\\">\\n          &#x3C;span className=\\\"icon-check\\\" />\\n          &#x3C;div className=\\\"title-message\\\">You have no tasks&#x3C;/div>\\n          &#x3C;div className=\\\"subtitle-message\\\">Sit back and relax&#x3C;/div>\\n        &#x3C;/div>\\n      &#x3C;/div>\\n    );\\n  }\\n\\n  const tasksInOrder = [\\n    ...tasks.filter(t => t.state === 'TASK_PINNED'),\\n    ...tasks.filter(t => t.state !== 'TASK_PINNED'),\\n  ];\\n\\n  return (\\n    &#x3C;div className=\\\"list-items\\\">\\n      {tasksInOrder.map(task => &#x3C;Task key={task.id} task={task} {...events} />)}\\n    &#x3C;/div>\\n  );\\n}\\n\\nexport default TaskList;\\n</code></pre>\\n<p>The added markup results in the following UI:</p>\\n<video autoPlay muted playsInline loop>\\n  <source\\n    src=\\\"/finished-tasklist-states.mp4\\\"\\n    type=\\\"video/mp4\\\"\\n  />\\n</video>\\n<p>Note the position of the pinned item in the list. We want the pinned item to render at the top of the list to make it a priority for our users.</p>\\n<h2>Data requirements and props</h2>\\n<p>As the component grows, so too do input requirements. Define the prop requirements of <code>TaskList</code>. Because <code>Task</code> is a child component, make sure to provide data in the right shape to render it. To save time and headache, reuse the propTypes you defined in <code>Task</code> earlier.</p>\\n<pre><code class=\\\"language-javascript\\\">import React from 'react';\\nimport PropTypes from 'prop-types';\\n\\nfunction TaskList() {\\n  ...\\n}\\n\\n\\nTaskList.propTypes = {\\n  loading: PropTypes.bool,\\n  tasks: PropTypes.arrayOf(Task.propTypes.task).isRequired,\\n  onPinTask: PropTypes.func.isRequired,\\n  onArchiveTask: PropTypes.func.isRequired,\\n};\\n\\nTaskList.defaultProps = {\\n  loading: false,\\n};\\n\\nexport default TaskList;\\n</code></pre>\\n<h2>Automated testing</h2>\\n<p>In the previous chapter we learned how to snapshot test stories using Storyshots. With <code>Task</code> there wasn’t a lot of complexity to test beyond that it renders OK. Since <code>TaskList</code> adds another layer of complexity we want to verify that certain inputs produce certain outputs in a way amenable to automatic testing. To do this we’ll create unit tests using <a href=\\\"https://facebook.github.io/jest/\\\">Jest</a> coupled with a test renderer such as <a href=\\\"http://airbnb.io/enzyme/\\\">Enzyme</a>.</p>\\n<p><img src=\\\"/logo-jest.png\\\" alt=\\\"Jest logo\\\"></p>\\n<h3>Unit tests with Jest</h3>\\n<p>Storybook stories paired with manual visual tests and snapshot tests (see above) go a long way to avoiding UI bugs. If stories cover a wide variety of component use cases, and we use tools that ensure a human checks any change to the story, errors are much less likely.</p>\\n<p>However, sometimes the devil is in the details. A test framework that is explicit about those details is needed. Which brings us to unit tests.</p>\\n<p>In our case, we want our <code>TaskList</code> to render any pinned tasks <strong>before</strong> unpinned tasks that it is passed in the <code>tasks</code> prop. Although we have a story (<code>withPinnedTasks</code>) to test this exact scenario; it can be ambiguous to a human reviewer that if the component <strong>stops</strong> ordering the tasks like this, it is a bug. It certainly won’t scream <strong>“Wrong!”</strong> to the casual eye.</p>\\n<p>So, to avoid this problem, we can use Jest to render the story to the DOM and run some DOM querying code to verify salient features of the output.</p>\\n<p>Create a test file called <code>TaskList.test.js</code>. Here we’ll build out our tests that make assertions about the output.</p>\\n<pre><code class=\\\"language-javascript\\\">import React from 'react';\\nimport ReactDOM from 'react-dom';\\nimport TaskList from './TaskList';\\nimport { withPinnedTasks } from './TaskList.stories';\\n\\nit('renders pinned tasks at the start of the list', () => {\\n  const div = document.createElement('div');\\n  const events = { onPinTask: jest.fn(), onArchiveTask: jest.fn() };\\n  ReactDOM.render(&#x3C;TaskList tasks={withPinnedTasks} {...events} />, div);\\n\\n  // We expect the task titled \\\"Task 6 (pinned)\\\" to be rendered first, not at the end\\n  const lastTaskInput = div.querySelector('.list-item:nth-child(1) input[value=\\\"Task 6 (pinned)\\\"]');\\n  expect(lastTaskInput).not.toBe(null);\\n\\n  ReactDOM.unmountComponentAtNode(div);\\n});\\n</code></pre>\\n<p><img src=\\\"/tasklist-testrunner.png\\\" alt=\\\"TaskList test runner\\\"></p>\\n<p>Note that we’ve been able to reuse the <code>withPinnedTasks</code> list of tasks in both story and unit test; in this way we can continue to leverage an existing resource (the examples that represent interesting configurations of a component) in more and more ways.</p>\\n<p>Notice as well that this test is quite brittle. It's possible that as the project matures, and the exact implementation of the <code>Task</code> changes --perhaps using a different classname or a <code>textarea</code> rather than an <code>input</code>--the test will fail, and need to be updated. This is not necessarily a problem, but rather an indication to be careful liberally using unit tests for UI. They're not easy to maintain. Instead rely on visual, snapshot, and visual regression (see <a href=\\\"/test/\\\">testing chapter</a>) tests where possible.</p>\",\"frontmatter\":{\"title\":\"Assemble a composite component\",\"description\":\"Assemble a composite component out of simpler components\",\"commit\":\"5776042\"},\"fields\":{\"slug\":\"/docs/en/composite-component/\",\"chapter\":\"composite-component\",\"framework\":\"docs\",\"language\":\"en\"}},\"site\":{\"siteMetadata\":{\"title\":\"binstd-区块链云服务平台\",\"toc\":[\"get-started\",\"simple-component\",\"composite-component\",\"data\",\"screen\",\"test\",\"deploy\",\"conclusion\",\"contribute\"],\"languages\":[\"en\",\"zh\"],\"githubUrl\":\"https://github.com/hichroma/learnstorybook.com\",\"codeGithubUrl\":\"https://github.com/hichroma/learnstorybook-code\",\"siteUrl\":\"https://binstd.com\"}},\"pages\":{\"edges\":[{\"node\":{\"frontmatter\":{\"tocTitle\":\"Composite component\",\"title\":\"Assemble a composite component\",\"description\":\"Assemble a composite component out of simpler components\"},\"fields\":{\"slug\":\"/docs/en/composite-component/\",\"chapter\":\"composite-component\"}}},{\"node\":{\"frontmatter\":{\"tocTitle\":null,\"title\":\"Conclusion\",\"description\":\"Put all your knowledge together and learn more Storybook techniques\"},\"fields\":{\"slug\":\"/docs/en/conclusion/\",\"chapter\":\"conclusion\"}}},{\"node\":{\"frontmatter\":{\"tocTitle\":null,\"title\":\"Contribute\",\"description\":\"Help share Storybook with the world\"},\"fields\":{\"slug\":\"/docs/en/contribute/\",\"chapter\":\"contribute\"}}},{\"node\":{\"frontmatter\":{\"tocTitle\":\"Data\",\"title\":\"Wire in data\",\"description\":\"Learn how to wire in data to your UI component\"},\"fields\":{\"slug\":\"/docs/en/data/\",\"chapter\":\"data\"}}},{\"node\":{\"frontmatter\":{\"tocTitle\":\"Deploy\",\"title\":\"Deploy Storybook\",\"description\":\"Deploy Storybook online with GitHub and Netlify\"},\"fields\":{\"slug\":\"/docs/en/deploy/\",\"chapter\":\"deploy\"}}},{\"node\":{\"frontmatter\":{\"tocTitle\":\"Get started\",\"title\":\"Get started\",\"description\":\"Setup React Storybook in your development environment\"},\"fields\":{\"slug\":\"/docs/en/get-started/\",\"chapter\":\"get-started\"}}},{\"node\":{\"frontmatter\":{\"tocTitle\":\"Screens\",\"title\":\"Construct a screen\",\"description\":\"Construct a screen out of components\"},\"fields\":{\"slug\":\"/docs/en/screen/\",\"chapter\":\"screen\"}}},{\"node\":{\"frontmatter\":{\"tocTitle\":\"Simple component\",\"title\":\"Build a simple component\",\"description\":\"Build a simple component in isolation\"},\"fields\":{\"slug\":\"/docs/en/simple-component/\",\"chapter\":\"simple-component\"}}},{\"node\":{\"frontmatter\":{\"tocTitle\":null,\"title\":\"Testing\",\"description\":\"Learn the ways to test UI components\"},\"fields\":{\"slug\":\"/docs/en/test/\",\"chapter\":\"test\"}}}]}},\"pathContext\":{\"slug\":\"/docs/en/composite-component/\",\"framework\":\"docs\",\"language\":\"en\",\"chapter\":\"composite-component\"}}\n\n/***/ })\n\n});\n\n\n// WEBPACK FOOTER //\n// path---docs-en-composite-component-60a2012f00bc1c4854f0.js","module.exports = {\"data\":{\"currentPage\":{\"html\":\"<h1>Assemble a composite component</h1>\\n<p>Last chapter we built our first component; this chapter extends what we learned to build TaskList, a list of Tasks. Let’s combine components together and see what happens when more complexity is introduced.</p>\\n<h2>Tasklist</h2>\\n<p>Taskbox emphasizes pinned tasks by positioning them above default tasks. This yields two variations of <code>TaskList</code> you need to create stories for: default items and default and pinned items.</p>\\n<p><img src=\\\"/tasklist-states-1.png\\\" alt=\\\"default and pinned tasks\\\"></p>\\n<p>Since <code>Task</code> data can be sent asynchronously, we <strong>also</strong> need a loading state to render in the absence of a connection. In addition, an empty state is required when there are no tasks.</p>\\n<p><img src=\\\"/tasklist-states-2.png\\\" alt=\\\"empty and loading tasks\\\"></p>\\n<h2>Get setup</h2>\\n<p>A composite component isn’t much different than the basic components it contains. Create a <code>TaskList</code> component and an accompanying story file: <code>src/components/TaskList.js</code> and <code>src/components/TaskList.stories.js</code>.</p>\\n<p>Start with a rough implementation of the <code>TaskList</code>. You’ll need to import the <code>Task</code> component from earlier and pass in the attributes and actions as inputs.</p>\\n<pre><code class=\\\"language-javascript\\\">import React from 'react';\\n\\nimport Task from './Task';\\n\\nfunction TaskList({ loading, tasks, onPinTask, onArchiveTask }) {\\n  const events = {\\n    onPinTask,\\n    onArchiveTask,\\n  };\\n\\n  if (loading) {\\n    return &#x3C;div className=\\\"list-items\\\">loading&#x3C;/div>;\\n  }\\n\\n  if (tasks.length === 0) {\\n    return &#x3C;div className=\\\"list-items\\\">empty&#x3C;/div>;\\n  }\\n\\n  return (\\n    &#x3C;div className=\\\"list-items\\\">\\n      {tasks.map(task => &#x3C;Task key={task.id} task={task} {...events} />)}\\n    &#x3C;/div>\\n  );\\n}\\n\\nexport default TaskList;\\n</code></pre>\\n<p>Next create <code>Tasklist</code>’s test states in the story file.</p>\\n<pre><code class=\\\"language-javascript\\\">import React from 'react';\\nimport { storiesOf } from '@storybook/react';\\n\\nimport TaskList from './TaskList';\\nimport { task, actions } from './Task.stories';\\n\\nexport const defaultTasks = [\\n  { ...task, id: '1', title: 'Task 1' },\\n  { ...task, id: '2', title: 'Task 2' },\\n  { ...task, id: '3', title: 'Task 3' },\\n  { ...task, id: '4', title: 'Task 4' },\\n  { ...task, id: '5', title: 'Task 5' },\\n  { ...task, id: '6', title: 'Task 6' },\\n];\\n\\nexport const withPinnedTasks = [\\n  ...defaultTasks.slice(0, 5),\\n  { id: '6', title: 'Task 6 (pinned)', state: 'TASK_PINNED' },\\n];\\n\\nstoriesOf('TaskList', module)\\n  .addDecorator(story => &#x3C;div style={{ padding: '3rem' }}>{story()}&#x3C;/div>)\\n  .add('default', () => &#x3C;TaskList tasks={defaultTasks} {...actions} />)\\n  .add('withPinnedTasks', () => &#x3C;TaskList tasks={withPinnedTasks} {...actions} />)\\n  .add('loading', () => &#x3C;TaskList loading tasks={[]} {...actions} />)\\n  .add('empty', () => &#x3C;TaskList tasks={[]} {...actions} />);\\n</code></pre>\\n<p><code>addDecorator()</code> allows us to add some “context” to the rendering of each task. In this case we add padding around the list to make it easier to visually verify.</p>\\n<div class=\\\"aside\\\">\\n<a href=\\\"https://storybook.js.org/addons/introduction/#1-decorators\\\"><b>Decorators</b></a> are a way to provide arbitrary wrappers to stories. In this case we’re using a decorator to add styling. They can also be used to wrap stories in “providers” –i.e. library components that set React context.\\n</div>\\n<p><code>task</code> supplies the shape of a <code>Task</code> that we created and exported from the <code>Task.stories.js</code> file. Similarly, <code>actions</code> defines the actions (mocked callbacks) that a <code>Task</code> component expects, which the <code>TaskList</code> also needs.</p>\\n<p>Now check Storybook for the new <code>TaskList</code> stories.</p>\\n<video autoPlay muted playsInline loop>\\n  <source\\n    src=\\\"/inprogress-tasklist-states.mp4\\\"\\n    type=\\\"video/mp4\\\"\\n  />\\n</video>\\n<h2>Build out the states</h2>\\n<p>Our component is still rough but now we have an idea of the stories to work toward. You might be thinking that the <code>.list-items</code> wrapper is overly simplistic. You're right – in most cases we wouldn’t create a new component just to add a wrapper. But the <strong>real complexity</strong> of <code>TaskList</code> component is revealed in the edge cases <code>withPinnedTasks</code>, <code>loading</code>, and <code>empty</code>.</p>\\n<pre><code class=\\\"language-javascript\\\">import React from 'react';\\n\\nimport Task from './Task';\\n\\nfunction TaskList({ loading, tasks, onPinTask, onArchiveTask }) {\\n  const events = {\\n    onPinTask,\\n    onArchiveTask,\\n  };\\n\\n  const LoadingRow = (\\n    &#x3C;div className=\\\"loading-item\\\">\\n      &#x3C;span className=\\\"glow-checkbox\\\" />\\n      &#x3C;span className=\\\"glow-text\\\">\\n        &#x3C;span>Loading&#x3C;/span> &#x3C;span>cool&#x3C;/span> &#x3C;span>state&#x3C;/span>\\n      &#x3C;/span>\\n    &#x3C;/div>\\n  );\\n\\n  if (loading) {\\n    return (\\n      &#x3C;div className=\\\"list-items\\\">\\n        {LoadingRow}\\n        {LoadingRow}\\n        {LoadingRow}\\n        {LoadingRow}\\n        {LoadingRow}\\n        {LoadingRow}\\n      &#x3C;/div>\\n    );\\n  }\\n\\n  if (tasks.length === 0) {\\n    return (\\n      &#x3C;div className=\\\"list-items\\\">\\n        &#x3C;div className=\\\"wrapper-message\\\">\\n          &#x3C;span className=\\\"icon-check\\\" />\\n          &#x3C;div className=\\\"title-message\\\">You have no tasks&#x3C;/div>\\n          &#x3C;div className=\\\"subtitle-message\\\">Sit back and relax&#x3C;/div>\\n        &#x3C;/div>\\n      &#x3C;/div>\\n    );\\n  }\\n\\n  const tasksInOrder = [\\n    ...tasks.filter(t => t.state === 'TASK_PINNED'),\\n    ...tasks.filter(t => t.state !== 'TASK_PINNED'),\\n  ];\\n\\n  return (\\n    &#x3C;div className=\\\"list-items\\\">\\n      {tasksInOrder.map(task => &#x3C;Task key={task.id} task={task} {...events} />)}\\n    &#x3C;/div>\\n  );\\n}\\n\\nexport default TaskList;\\n</code></pre>\\n<p>The added markup results in the following UI:</p>\\n<video autoPlay muted playsInline loop>\\n  <source\\n    src=\\\"/finished-tasklist-states.mp4\\\"\\n    type=\\\"video/mp4\\\"\\n  />\\n</video>\\n<p>Note the position of the pinned item in the list. We want the pinned item to render at the top of the list to make it a priority for our users.</p>\\n<h2>Data requirements and props</h2>\\n<p>As the component grows, so too do input requirements. Define the prop requirements of <code>TaskList</code>. Because <code>Task</code> is a child component, make sure to provide data in the right shape to render it. To save time and headache, reuse the propTypes you defined in <code>Task</code> earlier.</p>\\n<pre><code class=\\\"language-javascript\\\">import React from 'react';\\nimport PropTypes from 'prop-types';\\n\\nfunction TaskList() {\\n  ...\\n}\\n\\n\\nTaskList.propTypes = {\\n  loading: PropTypes.bool,\\n  tasks: PropTypes.arrayOf(Task.propTypes.task).isRequired,\\n  onPinTask: PropTypes.func.isRequired,\\n  onArchiveTask: PropTypes.func.isRequired,\\n};\\n\\nTaskList.defaultProps = {\\n  loading: false,\\n};\\n\\nexport default TaskList;\\n</code></pre>\\n<h2>Automated testing</h2>\\n<p>In the previous chapter we learned how to snapshot test stories using Storyshots. With <code>Task</code> there wasn’t a lot of complexity to test beyond that it renders OK. Since <code>TaskList</code> adds another layer of complexity we want to verify that certain inputs produce certain outputs in a way amenable to automatic testing. To do this we’ll create unit tests using <a href=\\\"https://facebook.github.io/jest/\\\">Jest</a> coupled with a test renderer such as <a href=\\\"http://airbnb.io/enzyme/\\\">Enzyme</a>.</p>\\n<p><img src=\\\"/logo-jest.png\\\" alt=\\\"Jest logo\\\"></p>\\n<h3>Unit tests with Jest</h3>\\n<p>Storybook stories paired with manual visual tests and snapshot tests (see above) go a long way to avoiding UI bugs. If stories cover a wide variety of component use cases, and we use tools that ensure a human checks any change to the story, errors are much less likely.</p>\\n<p>However, sometimes the devil is in the details. A test framework that is explicit about those details is needed. Which brings us to unit tests.</p>\\n<p>In our case, we want our <code>TaskList</code> to render any pinned tasks <strong>before</strong> unpinned tasks that it is passed in the <code>tasks</code> prop. Although we have a story (<code>withPinnedTasks</code>) to test this exact scenario; it can be ambiguous to a human reviewer that if the component <strong>stops</strong> ordering the tasks like this, it is a bug. It certainly won’t scream <strong>“Wrong!”</strong> to the casual eye.</p>\\n<p>So, to avoid this problem, we can use Jest to render the story to the DOM and run some DOM querying code to verify salient features of the output.</p>\\n<p>Create a test file called <code>TaskList.test.js</code>. Here we’ll build out our tests that make assertions about the output.</p>\\n<pre><code class=\\\"language-javascript\\\">import React from 'react';\\nimport ReactDOM from 'react-dom';\\nimport TaskList from './TaskList';\\nimport { withPinnedTasks } from './TaskList.stories';\\n\\nit('renders pinned tasks at the start of the list', () => {\\n  const div = document.createElement('div');\\n  const events = { onPinTask: jest.fn(), onArchiveTask: jest.fn() };\\n  ReactDOM.render(&#x3C;TaskList tasks={withPinnedTasks} {...events} />, div);\\n\\n  // We expect the task titled \\\"Task 6 (pinned)\\\" to be rendered first, not at the end\\n  const lastTaskInput = div.querySelector('.list-item:nth-child(1) input[value=\\\"Task 6 (pinned)\\\"]');\\n  expect(lastTaskInput).not.toBe(null);\\n\\n  ReactDOM.unmountComponentAtNode(div);\\n});\\n</code></pre>\\n<p><img src=\\\"/tasklist-testrunner.png\\\" alt=\\\"TaskList test runner\\\"></p>\\n<p>Note that we’ve been able to reuse the <code>withPinnedTasks</code> list of tasks in both story and unit test; in this way we can continue to leverage an existing resource (the examples that represent interesting configurations of a component) in more and more ways.</p>\\n<p>Notice as well that this test is quite brittle. It's possible that as the project matures, and the exact implementation of the <code>Task</code> changes --perhaps using a different classname or a <code>textarea</code> rather than an <code>input</code>--the test will fail, and need to be updated. This is not necessarily a problem, but rather an indication to be careful liberally using unit tests for UI. They're not easy to maintain. Instead rely on visual, snapshot, and visual regression (see <a href=\\\"/test/\\\">testing chapter</a>) tests where possible.</p>\",\"frontmatter\":{\"title\":\"Assemble a composite component\",\"description\":\"Assemble a composite component out of simpler components\",\"commit\":\"5776042\"},\"fields\":{\"slug\":\"/docs/en/composite-component/\",\"chapter\":\"composite-component\",\"framework\":\"docs\",\"language\":\"en\"}},\"site\":{\"siteMetadata\":{\"title\":\"binstd-区块链云服务平台\",\"toc\":[\"get-started\",\"simple-component\",\"composite-component\",\"data\",\"screen\",\"test\",\"deploy\",\"conclusion\",\"contribute\"],\"languages\":[\"en\",\"zh\"],\"githubUrl\":\"https://github.com/hichroma/learnstorybook.com\",\"codeGithubUrl\":\"https://github.com/hichroma/learnstorybook-code\",\"siteUrl\":\"https://binstd.com\"}},\"pages\":{\"edges\":[{\"node\":{\"frontmatter\":{\"tocTitle\":\"Composite component\",\"title\":\"Assemble a composite component\",\"description\":\"Assemble a composite component out of simpler components\"},\"fields\":{\"slug\":\"/docs/en/composite-component/\",\"chapter\":\"composite-component\"}}},{\"node\":{\"frontmatter\":{\"tocTitle\":null,\"title\":\"Conclusion\",\"description\":\"Put all your knowledge together and learn more Storybook techniques\"},\"fields\":{\"slug\":\"/docs/en/conclusion/\",\"chapter\":\"conclusion\"}}},{\"node\":{\"frontmatter\":{\"tocTitle\":null,\"title\":\"Contribute\",\"description\":\"Help share Storybook with the world\"},\"fields\":{\"slug\":\"/docs/en/contribute/\",\"chapter\":\"contribute\"}}},{\"node\":{\"frontmatter\":{\"tocTitle\":\"Data\",\"title\":\"Wire in data\",\"description\":\"Learn how to wire in data to your UI component\"},\"fields\":{\"slug\":\"/docs/en/data/\",\"chapter\":\"data\"}}},{\"node\":{\"frontmatter\":{\"tocTitle\":\"Deploy\",\"title\":\"Deploy Storybook\",\"description\":\"Deploy Storybook online with GitHub and Netlify\"},\"fields\":{\"slug\":\"/docs/en/deploy/\",\"chapter\":\"deploy\"}}},{\"node\":{\"frontmatter\":{\"tocTitle\":\"Get started\",\"title\":\"Get started\",\"description\":\"Setup React Storybook in your development environment\"},\"fields\":{\"slug\":\"/docs/en/get-started/\",\"chapter\":\"get-started\"}}},{\"node\":{\"frontmatter\":{\"tocTitle\":\"Screens\",\"title\":\"Construct a screen\",\"description\":\"Construct a screen out of components\"},\"fields\":{\"slug\":\"/docs/en/screen/\",\"chapter\":\"screen\"}}},{\"node\":{\"frontmatter\":{\"tocTitle\":\"Simple component\",\"title\":\"Build a simple component\",\"description\":\"Build a simple component in isolation\"},\"fields\":{\"slug\":\"/docs/en/simple-component/\",\"chapter\":\"simple-component\"}}},{\"node\":{\"frontmatter\":{\"tocTitle\":null,\"title\":\"Testing\",\"description\":\"Learn the ways to test UI components\"},\"fields\":{\"slug\":\"/docs/en/test/\",\"chapter\":\"test\"}}}]}},\"pathContext\":{\"slug\":\"/docs/en/composite-component/\",\"framework\":\"docs\",\"language\":\"en\",\"chapter\":\"composite-component\"}}\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/json-loader!./.cache/json/docs-en-composite-component.json\n// module id = 859\n// module chunks = 219667607431145"],"sourceRoot":""}