webpackJsonp([41160170111749],{864:function(e,t){e.exports={data:{currentPage:{html:'<h1>Build a simple component</h1>\n<p>We’ll build our UI following a <a href="https://blog.hichroma.com/component-driven-development-ce1109d56c8e">Component-Driven Development</a> (CDD) methodology. It’s a process that builds UIs from the “bottom up” starting with components and ending with screens. CDD helps you scale the amount of complexity you’re faced with as you build out the UI.</p>\n<h2>Task</h2>\n<p><img src="/task-states-learnstorybook.png" alt="Task component in three states"></p>\n<p><code>Task</code> is the core component in our app. Each task displays slightly differently depending on exactly what state it’s in. We display a checked (or unchecked) checkbox, some information about the task, and a “pin” button, allowing us to move tasks up and down the list. Putting this together, we’ll need these props:</p>\n<ul>\n<li><code>title</code> – a string describing the task</li>\n<li><code>state</code> - which list is the task currently in and is it checked off?</li>\n</ul>\n<p>As we start to build <code>Task</code>, we first write our test states that correspond to the different types of tasks sketch above. Then we use Storybook to build the component in isolation using mocked data. We’ll “visual test” the component’s appearance given each state as we go.</p>\n<p>This process is similar to <a href="https://en.wikipedia.org/wiki/Test-driven_development">Test-driven development</a> (TDD) that we can call “<a href="https://blog.hichroma.com/visual-test-driven-development-aec1c98bed87">Visual TDD</a>”.</p>\n<h2>Get setup</h2>\n<p>First, let’s create the task component and its accompanying story file: <code>src/components/Task.js</code> and <code>src/components/Task.stories.js</code>.</p>\n<p>We’ll begin with a basic implementation of the <code>Task</code>, simply taking in the attributes we know we’ll need and the two actions you can take on a task (to move it between lists):</p>\n<pre><code class="language-javascript">import React from \'react\';\n\nexport default function Task({ task: { id, title, state }, onArchiveTask, onPinTask }) {\n  return (\n    &#x3C;div className="list-item">\n      &#x3C;input type="text" value={title} readOnly={true} />\n    &#x3C;/div>\n  );\n}\n</code></pre>\n<p>Above, we render straightforward markup for <code>Task</code> based on the existing HTML structure of the Todos app.</p>\n<p>Below we build out Task’s three test states in the story file:</p>\n<pre><code class="language-javascript">import React from \'react\';\nimport { storiesOf } from \'@storybook/react\';\nimport { action } from \'@storybook/addon-actions\';\n\nimport Task from \'./Task\';\n\nexport const task = {\n  id: \'1\',\n  title: \'Test Task\',\n  state: \'TASK_INBOX\',\n  updatedAt: new Date(2018, 0, 1, 9, 0),\n};\n\nexport const actions = {\n  onPinTask: action(\'onPinTask\'),\n  onArchiveTask: action(\'onArchiveTask\'),\n};\n\nstoriesOf(\'Task\', module)\n  .add(\'default\', () => &#x3C;Task task={task} {...actions} />)\n  .add(\'pinned\', () => &#x3C;Task task={{ ...task, state: \'TASK_PINNED\' }} {...actions} />)\n  .add(\'archived\', () => &#x3C;Task task={{ ...task, state: \'TASK_ARCHIVED\' }} {...actions} />);\n</code></pre>\n<p>There are two basic levels of organization in Storybook. The component and its child stories. Think of each story as a permutation of a component. You can have as many stories per component as you need.</p>\n<ul>\n<li>\n<p><strong>Component</strong></p>\n<ul>\n<li>Story</li>\n<li>Story</li>\n<li>Story</li>\n</ul>\n</li>\n</ul>\n<p>To initiate Storybook we first call the <code>storiesOf()</code> function to register the component. We add a display name for the component –the name that appears on the sidebar in the Storybook app.</p>\n<p><code>action()</code> allows us to create a callback that appears in the <strong>actions</strong> panel of the Storybook UI when clicked. So when we build a pin button, we’ll be able to determine in the test UI if a button click is successful.</p>\n<p>As we need to pass the same set of actions to all permutations of our component, it is convenient to bundle them up into a single <code>actions</code> variable and use React\'s <code>{...actions}</code> props expansion to pass them all at once. <code>&#x3C;Task {...actions}></code> is equivalent to <code>&#x3C;Task onPinTask={actions.onPinTask} onArchiveTask={actions.onArchiveTask}></code>.</p>\n<p>Another nice thing about bundling the <code>actions</code> that a component needs is that you can <code>export</code> them and use them in stories for components that reuse this component, as we\'ll see later.</p>\n<p>To define our stories, we call <code>add()</code> once for each of our test states to generate a story. The action story is a function that returns a rendered element (i.e. a component class with a set of props) in a given state---exactly like a React <a href="https://reactjs.org/docs/components-and-props.html">Stateless Functional Component</a>.</p>\n<p>When creating a story we use a base task (<code>task</code>) to build out the shape of the task the component expects. This is typically modelled from what the true data looks like. Again, <code>export</code>-ing this shape will enable us to reuse it in later stories, as we\'ll see.</p>\n<div class="aside">\n<a href="https://storybook.js.org/addons/introduction/#2-native-addons"><b>Actions</b></a> help you verify interactions when building UI components in isolation. Oftentimes you won\'t have access to the functions and state you have in context of the app. Use <code>action()</code> to stub them in.\n</div>\n<h2>Config</h2>\n<p>We also have to make one small change to the Storybook configuration setup (<code>.storybook/config.js</code>) so it notices our <code>.stories.js</code> files and uses our CSS file. By default Storybook looks for stories in a <code>/stories</code> directory; this tutorial uses a naming scheme that is similar to the <code>.test.js</code> naming scheme favoured by CRA for automated tests.</p>\n<pre><code class="language-javascript">import { configure } from \'@storybook/react\';\nimport \'../src/index.css\';\n\nconst req = require.context(\'../src\', true, /.stories.js$/);\n\nfunction loadStories() {\n  req.keys().forEach(filename => req(filename));\n}\n\nconfigure(loadStories, module);\n</code></pre>\n<p>Once we’ve done this, restarting the Storybook server should yield test cases for the three Task states:</p>\n<video autoPlay muted playsInline controls >\n  <source\n    src="/inprogress-task-states.mp4"\n    type="video/mp4"\n  />\n</video>\n<h2>Build out the states</h2>\n<p>Now we have Storybook setup, styles imported, and test cases built out, we can quickly start the work of implementing the HTML of the component to match the design.</p>\n<p>The component is still basic at the moment. First write the code that achieves the design without going into too much detail:</p>\n<pre><code class="language-javascript">import React from \'react\';\n\nexport default function Task({ task: { id, title, state }, onArchiveTask, onPinTask }) {\n  return (\n    &#x3C;div className={`list-item ${state}`}>\n      &#x3C;label className="checkbox">\n        &#x3C;input\n          type="checkbox"\n          defaultChecked={state === \'TASK_ARCHIVED\'}\n          disabled={true}\n          name="checked"\n        />\n        &#x3C;span className="checkbox-custom" onClick={() => onArchiveTask(id)} />\n      &#x3C;/label>\n      &#x3C;div className="title">\n        &#x3C;input type="text" value={title} readOnly={true} placeholder="Input title" />\n      &#x3C;/div>\n\n      &#x3C;div className="actions" onClick={event => event.stopPropagation()}>\n        {state !== \'TASK_ARCHIVED\' &#x26;&#x26; (\n          &#x3C;a onClick={() => onPinTask(id)}>\n            &#x3C;span className={`icon-star`} />\n          &#x3C;/a>\n        )}\n      &#x3C;/div>\n    &#x3C;/div>\n  );\n}\n</code></pre>\n<p>The additional markup from above combined with the CSS we imported earlier yields the following UI:</p>\n<video autoPlay muted playsInline loop>\n  <source\n    src="/finished-task-states.mp4"\n    type="video/mp4"\n  />\n</video>\n<h2>Specify data requirements</h2>\n<p>It’s best practice to use <code>propTypes</code> in React to specify the shape of data that a component expects. Not only is it self documenting, it also helps catch problems early.</p>\n<pre><code class="language-javascript">import React from \'react\';\nimport PropTypes from \'prop-types\';\n\nfunction Task() {\n  ...\n}\n\nTask.propTypes = {\n  task: PropTypes.shape({\n    id: PropTypes.string.isRequired,\n    title: PropTypes.string.isRequired,\n    state: PropTypes.string.isRequired,\n  }),\n  onArchiveTask: PropTypes.func,\n  onPinTask: PropTypes.func,\n};\n\nexport default Task;\n</code></pre>\n<p>Now a warning in development will appear if the Task component is misused.</p>\n<div class="aside">\nAn alternative way to achieve the same purpose is to use a JavaScript type system like TypeScript to create a type for the component properties.\n</div>\n<h2>Component built!</h2>\n<p>We’ve now successfully built out a component without needing a server or running the entire frontend application. The next step is to build out the remaining Taskbox components one by one in a similar fashion.</p>\n<p>As you can see, getting started building components in in isolation is easy and fast. We can expect to produce a higher-quality UI with less bugs and more polish because it’s possible to dig in and test every possible state.</p>\n<h2>Automated Testing</h2>\n<p>Storybook gave us a great way to visually test our application during construction. The ‘stories’ will help ensure we don’t break our Task visually as we continue to develop the app. However, it is a completely manual process at this stage, and someone has to go to the effort of clicking through each test state and ensuring it renders well and without errors or warnings. Can’t we do that automatically?</p>\n<h3>Snapshot testing</h3>\n<p>Snapshot testing refers to the practice of recording the “known good” output of a component for a given input and then flagging the component whenever the output changes in future. This complements Storybook, because it’s a quick way to view the new version of a component and check out the changes.</p>\n<div class="aside">\nMake sure your components render data that doesn\'t change, so that your snapshot tests won\'t fail each time. Watch out for things like dates or randomly generated values.\n</div>\n<p>With the <a href="https://github.com/storybooks/storybook/tree/master/addons/storyshots">Storyshots addon</a> a snapshot test is created for each of the stories. Use it by adding a development dependency on the package:</p>\n<pre><code class="language-bash">yarn add --dev @storybook/addon-storyshots react-test-renderer\n</code></pre>\n<p>Then create an <code>src/storybook.test.js</code> file with the following in it:</p>\n<pre><code class="language-javascript">import initStoryshots from \'@storybook/addon-storyshots\';\ninitStoryshots();\n</code></pre>\n<p>Once the above is done, we can run <code>yarn test</code> and see the following output:</p>\n<p><img src="/task-testrunner.png" alt="Task test runner"></p>\n<p>We now have a snapshot test for each of our <code>Task</code> stories. If we change the implementation of <code>Task</code>, we’ll be prompted to verify the changes.</p>',frontmatter:{title:"Build a simple component",description:"Build a simple component in isolation",commit:"131aade"},fields:{slug:"/docs/en/simple-component/",chapter:"simple-component",framework:"docs",language:"en"}},site:{siteMetadata:{title:"binstd-区块链云服务平台",toc:["get-started","simple-component","composite-component","data","screen","test","deploy","conclusion","contribute"],languages:["en","zh"],githubUrl:"https://github.com/hichroma/learnstorybook.com",codeGithubUrl:"https://github.com/hichroma/learnstorybook-code",siteUrl:"https://binstd.com"}},pages:{edges:[{node:{frontmatter:{tocTitle:"Composite component",title:"Assemble a composite component",description:"Assemble a composite component out of simpler components"},fields:{slug:"/docs/en/composite-component/",chapter:"composite-component"}}},{node:{frontmatter:{tocTitle:null,title:"Conclusion",description:"Put all your knowledge together and learn more Storybook techniques"},fields:{slug:"/docs/en/conclusion/",chapter:"conclusion"}}},{node:{frontmatter:{tocTitle:null,title:"Contribute",description:"Help share Storybook with the world"},fields:{slug:"/docs/en/contribute/",chapter:"contribute"}}},{node:{frontmatter:{tocTitle:"Data",title:"Wire in data",description:"Learn how to wire in data to your UI component"},fields:{slug:"/docs/en/data/",chapter:"data"}}},{node:{frontmatter:{tocTitle:"Deploy",title:"Deploy Storybook",description:"Deploy Storybook online with GitHub and Netlify"},fields:{slug:"/docs/en/deploy/",chapter:"deploy"}}},{node:{frontmatter:{tocTitle:"Get started",title:"Get started",description:"Setup React Storybook in your development environment"},fields:{slug:"/docs/en/get-started/",chapter:"get-started"}}},{node:{frontmatter:{tocTitle:"Screens",title:"Construct a screen",description:"Construct a screen out of components"},fields:{slug:"/docs/en/screen/",chapter:"screen"}}},{node:{frontmatter:{tocTitle:"Simple component",title:"Build a simple component",description:"Build a simple component in isolation"},fields:{slug:"/docs/en/simple-component/",chapter:"simple-component"}}},{node:{frontmatter:{tocTitle:null,title:"Testing",description:"Learn the ways to test UI components"},fields:{slug:"/docs/en/test/",chapter:"test"}}}]}},pathContext:{slug:"/docs/en/simple-component/",framework:"docs",language:"en",chapter:"simple-component"}}}});
//# sourceMappingURL=path---docs-en-simple-component-d6b44ef07a0e9fde6f8e.js.map