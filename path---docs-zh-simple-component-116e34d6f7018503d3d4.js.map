{"version":3,"sources":["webpack:///path---docs-zh-simple-component-116e34d6f7018503d3d4.js","webpack:///./.cache/json/docs-zh-simple-component.json"],"names":["webpackJsonp","882","module","exports","data","currentPage","html","frontmatter","title","description","commit","fields","slug","chapter","framework","language","site","siteMetadata","toc","languages","githubUrl","codeGithubUrl","siteUrl","pages","edges","node","tocTitle","pathContext"],"mappings":"AAAAA,cAAc,iBAERC,IACA,SAAUC,EAAQC,GCHxBD,EAAAC,SAAkBC,MAAQC,aAAeC,KAAA,q/OAA0zOC,aAA+OC,MAAA,YAAAC,YAAA,cAAAC,OAAA,WAAmEC,QAAWC,KAAA,6BAAAC,QAAA,mBAAAC,UAAA,OAAAC,SAAA,OAAqGC,MAASC,cAAgBT,MAAA,kBAAAU,KAAA,kHAAAC,WAAA,WAAAC,UAAA,iDAAAC,cAAA,kDAAAC,QAAA,uBAA0UC,OAAUC,QAAUC,MAAQlB,aAAemB,SAAA,OAAAlB,MAAA,SAAAC,YAAA,mBAAmEE,QAAWC,KAAA,gCAAAC,QAAA,0BAA2EY,MAAQlB,aAAemB,SAAA,KAAAlB,MAAA,KAAAC,YAAA,iCAA2EE,QAAWC,KAAA,uBAAAC,QAAA,iBAAyDY,MAAQlB,aAAemB,SAAA,KAAAlB,MAAA,OAAAC,YAAA,yBAAqEE,QAAWC,KAAA,uBAAAC,QAAA,iBAAyDY,MAAQlB,aAAemB,SAAA,OAAAlB,MAAA,SAAAC,YAAA,kBAAkEE,QAAWC,KAAA,iBAAAC,QAAA,WAA6CY,MAAQlB,aAAemB,SAAA,KAAAlB,MAAA,eAAAC,YAAA,uCAA2FE,QAAWC,KAAA,mBAAAC,QAAA,aAAiDY,MAAQlB,aAAemB,SAAA,OAAAlB,MAAA,MAAAC,YAAA,iCAA8EE,QAAWC,KAAA,wBAAAC,QAAA,kBAA2DY,MAAQlB,aAAemB,SAAA,KAAAlB,MAAA,SAAAC,YAAA,aAA2DE,QAAWC,KAAA,mBAAAC,QAAA,aAAiDY,MAAQlB,aAAemB,SAAA,QAAAlB,MAAA,YAAAC,YAAA,eAAmEE,QAAWC,KAAA,6BAAAC,QAAA,uBAAqEY,MAAQlB,aAAemB,SAAA,KAAAlB,MAAA,KAAAC,YAAA,eAAyDE,QAAWC,KAAA,iBAAAC,QAAA,aAA8Cc,aAAgBf,KAAA,6BAAAE,UAAA,OAAAC,SAAA,KAAAF,QAAA","file":"path---docs-zh-simple-component-116e34d6f7018503d3d4.js","sourcesContent":["webpackJsonp([21313861147051],{\n\n/***/ 882:\n/***/ (function(module, exports) {\n\n\tmodule.exports = {\"data\":{\"currentPage\":{\"html\":\"<h1>构建一个简单的组件</h1>\\n<p>我们将按照<a href=\\\"https://blog.hichroma.com/component-driven-development-ce1109d56c8e\\\">组件驱动开发</a> (CDD) 方法论来 构建我们的UI. 这是一个从\\\"自下而上\\\"开始构建UI的过程,从组件开始到整个页面结束. CDD 可帮助您在构建UI时,摆列您所面临的复杂程度. </p>\\n<h2>任务-Task</h2>\\n<p><img src=\\\"/task-states-learnstorybook.png\\\" alt=\\\"Task component in three states\\\"></p>\\n<p><code>Task</code>是我们的应用程序的核心组件. 每个任务的显示略有不同,具体取决于它所处的<code>状态-state</code>. 我们显示一个选中 (或未选中) 复选框,一些有关任务的信息,以及一个\\\"pin\\\"按钮,允许我们在列表中上下移动任务. 为了把各个它们摆在一起,我们需要下面的 <strong>props</strong>: </p>\\n<ul>\\n<li>\\n<p><code>title</code> - 描述任务的字符串</p>\\n</li>\\n<li>\\n<p><code>state</code> - 哪个列表是当前的任务,是否已检查?</p>\\n</li>\\n</ul>\\n<p>在我们开始构建<code>Task</code>时,我们首先编写 与 上面草图中不同类型的任务 相对应的测试状态. 然后我们使用 Storybook 模拟数据 隔离对应状态组件. 我们将\\\"视觉测试\\\"组件在每个状态下的外观. </p>\\n<p>这个过程类似于<a href=\\\"https://en.wikipedia.org/wiki/Test-driven_development\\\">测试驱动的开发(TDD)</a>,我们可以称之为<a href=\\\"https://blog.hichroma.com/visual-test-driven-development-aec1c98bed87\\\">\\\"Visual-虚拟 TDD\\\"</a></p>\\n<h2>获取设置</h2>\\n<p>首先,让我们创建任务组件 及 其附带的 <em>storybook-故事</em> 文件: </p>\\n<p><code>src/components/Task.js</code>和<code>src/components/Task.stories.js</code></p>\\n<p>我们将从基本实现开始,简单传入我们需要的<code>属性-props</code> 以及 您可以对任务执行的两个<code>on</code>操作 (在列表之间移动它) : </p>\\n<pre><code class=\\\"language-javascript\\\">import React from 'react';\\n\\nexport default function Task({ task: { id, title, state }, onArchiveTask, onPinTask }) {\\n  return (\\n    &#x3C;div className=\\\"list-item\\\">\\n      &#x3C;input type=\\\"text\\\" value={title} readOnly={true} />\\n    &#x3C;/div>\\n  );\\n}\\n</code></pre>\\n<p>上面,我们基于 Todos应用程序现有HTML结构 为 <code>Task</code>提供简单的 markup . </p>\\n<p>下面, 我们在 故事文件中 构建 Task的 三个测试状态: </p>\\n<pre><code class=\\\"language-javascript\\\">import React from 'react';\\nimport { storiesOf } from '@storybook/react';\\nimport { action } from '@storybook/addon-actions';\\n\\nimport Task from './Task';\\n\\nexport const task = {\\n  id: '1',\\n  title: 'Test Task',\\n  state: 'TASK_INBOX',\\n  updatedAt: new Date(2018, 0, 1, 9, 0),\\n};\\n\\nexport const actions = {\\n  onPinTask: action('onPinTask'),\\n  onArchiveTask: action('onArchiveTask'),\\n};\\n\\nstoriesOf('Task', module)\\n  .add('default', () => &#x3C;Task task={task} {...actions} />)\\n  .add('pinned', () => &#x3C;Task task={{ ...task, state: 'TASK_PINNED' }} {...actions} />)\\n  .add('archived', () => &#x3C;Task task={{ ...task, state: 'TASK_ARCHIVED' }} {...actions} />);\\n</code></pre>\\n<p>Storybook中有两个基本的组织级别. </p>\\n<p>该组件 及 其 child 故事. </p>\\n<p>将每个故事 视为组件的排列. 您可以根据需要为每个组件 创建 尽可能多的故事. </p>\\n<ul>\\n<li>\\n<p><strong>组件</strong></p>\\n<ul>\\n<li>故事</li>\\n<li>故事</li>\\n<li>故事</li>\\n</ul>\\n</li>\\n</ul>\\n<p>要开始 Storybook,我们先运<code>行 注册组件的</code>storiesOf()`函数. 我们为组件添加 <em>显示名称 -  Storybook应用程序侧栏上显示的名称</em>. </p>\\n<p><code>action()</code>允许我们创建一个回调, 当在Storybook UI的面板中 单击这个 <strong>action</strong> 时 回调触发. 因此,当我们构建一个pin按钮 时,我们将能够在 测试UI中 确定按钮单击 是否成功. </p>\\n<p>由于我们需要将 相同的一组操作 传递给 组件的所有排列,因此将它们捆绑到<code>actions</code>变量 并 使用React<code>{...actions}</code>的<code>porps</code>扩展以立即传递它们. <code>&#x3C;Task {...actions}></code>相当于<code>&#x3C;Task onPinTask={actions.onPinTask} onArchiveTask={actions.onArchiveTask}></code>. </p>\\n<p>关于捆绑<code>actions</code>的另一个好处就是,你可以<code>export-暴露</code>它们,用于重用该组件的组件,我们稍后会看到. </p>\\n<p>为了定义我们的故事,我们用<code>add()</code>,一次一个为我们的每个测试状态生成一个故事. <code>add</code>第二个参数是一个函数,它返回一个给定状态的渲染元素 (即带有一组<code>props</code>的组件类)  - 就像一个React<a href=\\\"https://reactjs.org/docs/components-and-props.html\\\">无状态功能组件</a>. </p>\\n<p>在创建故事时,我们使用基本任务 (<code>task</code>) 构建组件期望的 任务的形状. 这通常是 根据真实数据的模型建模的. 再次,正如我们所看到的,<code>export</code>这种形状将使我们能够在以后的故事中重复使用它. </p>\\n<div class=\\\"aside\\\">\\n<a href=\\\"https://storybook.js.org/addons/introduction/#2-native-addons\\\"><b>Actions</b></a> 帮助您在隔离构建UI组件时 验证交互. 通常，您无法访问应用程序上下文中的函数和状态。 使用 <code>action()</code> 将它们存入.\\n</div>\\n<h2>配置</h2>\\n<p>我们还必须对 Storybook的配置设置 (<code>.storybook/config.js</code>) 做一个小改动,让它注意到我们的<code>.stories.js</code>文件并使用我们的CSS文件. 默认情况下, Storybook 会查找故事<code>/stories</code>目录; 本教程使用类似于<code>.test.js</code>的命名方案, 这个命令是 <strong>CRA</strong> 赞成的用于自动化测试的方案. </p>\\n<pre><code class=\\\"language-javascript\\\">import { configure } from '@storybook/react';\\nimport '../src/index.css';\\n\\nconst req = require.context('../src', true, /.stories.js$/);\\n\\nfunction loadStories() {\\n  req.keys().forEach(filename => req(filename));\\n}\\n\\nconfigure(loadStories, module);\\n</code></pre>\\n<p>完成此操作后,重新启动 Storybook服务器 应该会产生 三个任务状态的测试用例: </p>\\n<video autoPlay muted playsInline controls >\\n  <source\\n    src=\\\"/inprogress-task-states.mp4\\\"\\n    type=\\\"video/mp4\\\"\\n  />\\n</video>\\n<h2>建立状态</h2>\\n<p>现在我们有 Storybook设置,导入的样式和构建的测试用例,我们可以快速开始实现组件的HTML,以匹配设计. </p>\\n<p>该组件目前仍然是基本的. 首先编写实现设计的代码,不用过多细节: </p>\\n<pre><code class=\\\"language-javascript\\\">import React from 'react';\\n\\nexport default function Task({ task: { id, title, state }, onArchiveTask, onPinTask }) {\\n  return (\\n    &#x3C;div className={`list-item ${state}`}>\\n      &#x3C;label className=\\\"checkbox\\\">\\n        &#x3C;input\\n          type=\\\"checkbox\\\"\\n          defaultChecked={state === 'TASK_ARCHIVED'}\\n          disabled={true}\\n          name=\\\"checked\\\"\\n        />\\n        &#x3C;span className=\\\"checkbox-custom\\\" onClick={() => onArchiveTask(id)} />\\n      &#x3C;/label>\\n      &#x3C;div className=\\\"title\\\">\\n        &#x3C;input type=\\\"text\\\" value={title} readOnly={true} placeholder=\\\"Input title\\\" />\\n      &#x3C;/div>\\n\\n      &#x3C;div className=\\\"actions\\\" onClick={event => event.stopPropagation()}>\\n        {state !== 'TASK_ARCHIVED' &#x26;&#x26; (\\n          &#x3C;a onClick={() => onPinTask(id)}>\\n            &#x3C;span className={`icon-star`} />\\n          &#x3C;/a>\\n        )}\\n      &#x3C;/div>\\n    &#x3C;/div>\\n  );\\n}\\n</code></pre>\\n<p>上面的附加 markup 与我们之前导入的CSS相结合,产生以下UI: </p>\\n<video autoPlay muted playsInline loop>\\n  <source\\n    src=\\\"/finished-task-states.mp4\\\"\\n    type=\\\"video/mp4\\\"\\n  />\\n</video>\\n<h2>特别数据要求</h2>\\n<p>最好的做法是<code>propTypes</code>在React中 指定组件所需的 数据形状. 它不仅可以自我记录,还有助于及早发现问题. </p>\\n<pre><code class=\\\"language-javascript\\\">import React from 'react';\\nimport PropTypes from 'prop-types';\\n\\nfunction Task() {\\n  ...\\n}\\n\\nTask.propTypes = {\\n  task: PropTypes.shape({\\n    id: PropTypes.string.isRequired,\\n    title: PropTypes.string.isRequired,\\n    state: PropTypes.string.isRequired,\\n  }),\\n  onArchiveTask: PropTypes.func,\\n  onPinTask: PropTypes.func,\\n};\\n\\nexport default Task;\\n</code></pre>\\n<p>现在,如果任务组件被滥用,则会出现开发警告. </p>\\n<div class=\\\"aside\\\">\\n另一种实现方法是使用 类似TypeScript的JavaScript类型系统 来为组件属性 创建类型。\\n</div>\\n<h2>组件构建!</h2>\\n<p>我们现在已成功构建了一个组件,没用到服务器或运行整个前端应用程序. 下一步是以类似的方式逐个构建剩余的 Taskbox组件. </p>\\n<p>如您所见,开始单独构建组件非常简单快捷. 我们可以期望生成更高质量的UI,减少错误和更多打磨,因为它可以挖掘并测试每个可能的状态. </p>\\n<h2>自动化测试</h2>\\n<p> Storybook 为我们提供了一种在施工期间,<code>可视化</code>测试我们的应用程序.在我们继续开发应用程序时,\\\"故事\\\"将有助于确保我们不会在视觉上打破我们的任务.\\n但是,在这个阶段,这是一个完全手动的过程,有人必须努力点击每个测试状态,并确保它呈现良好且没有错误或警告.\\n我们不能自动这样做吗?</p>\\n<h3>快照测试</h3>\\n<p>快照测试是指,记录 带一定输入的组件的\\\"已知良好\\\"输出,然后,将来 输出发生变化时标记组件 的做法.\\n这补充了 Storybook,因为快照 是查看 组件新版本 并 检查更改的快速方法. </p>\\n<div class=\\\"aside\\\">\\n确保您的组件呈现 <b>不变</b> 的数据，以便每次快照测试都不会失败。 注意日期或随机生成的值等内容。\\n</div>\\n<p>需要<a href=\\\"https://github.com/storybooks/storybook/tree/master/addons/storyshots\\\">Storyshots 插件</a>为每个故事创建 快照测试.\\n通过添加开发依赖项来使用它: </p>\\n<pre><code class=\\\"language-bash\\\">yarn add --dev @storybook/addon-storyshots react-test-renderer\\n</code></pre>\\n<p>然后创建一个<code>src/storybook.test.js</code>文件中包含以下内容: </p>\\n<pre><code class=\\\"language-javascript\\\">import initStoryshots from '@storybook/addon-storyshots';\\ninitStoryshots();\\n</code></pre>\\n<p>完成上述操作后,我们就可以运行了<code>yarn test</code>并看到以下输出: </p>\\n<p><img src=\\\"/task-testrunner.png\\\" alt=\\\"Task test runner\\\"></p>\\n<p>我们现在为每个<code>Task</code>故事进行快照测试. 如果我们改变了<code>Task</code>的实现,我们会提示您验证更改. </p>\",\"frontmatter\":{\"title\":\"构建一个简单的组件\",\"description\":\"单独构建一个简单的组件\",\"commit\":\"131aade\"},\"fields\":{\"slug\":\"/docs/zh/simple-component/\",\"chapter\":\"simple-component\",\"framework\":\"docs\",\"language\":\"zh\"}},\"site\":{\"siteMetadata\":{\"title\":\"binstd-区块链云服务平台\",\"toc\":[\"get-started\",\"simple-component\",\"composite-component\",\"data\",\"screen\",\"test\",\"deploy\",\"conclusion\",\"contribute\"],\"languages\":[\"en\",\"zh\"],\"githubUrl\":\"https://github.com/hichroma/learnstorybook.com\",\"codeGithubUrl\":\"https://github.com/hichroma/learnstorybook-code\",\"siteUrl\":\"https://binstd.com\"}},\"pages\":{\"edges\":[{\"node\":{\"frontmatter\":{\"tocTitle\":\"合成组件\",\"title\":\"组装复合组件\",\"description\":\"使用更简单的组件 组装复合组件\"},\"fields\":{\"slug\":\"/docs/zh/composite-component/\",\"chapter\":\"composite-component\"}}},{\"node\":{\"frontmatter\":{\"tocTitle\":null,\"title\":\"总结\",\"description\":\"把所有的知识汇总以下，学习更多的 storybook 技巧\"},\"fields\":{\"slug\":\"/docs/zh/conclusion/\",\"chapter\":\"conclusion\"}}},{\"node\":{\"frontmatter\":{\"tocTitle\":null,\"title\":\"帮助我们\",\"description\":\"帮助 我们与世界分享 Storybook \"},\"fields\":{\"slug\":\"/docs/zh/contribute/\",\"chapter\":\"contribute\"}}},{\"node\":{\"frontmatter\":{\"tocTitle\":\"Data\",\"title\":\"接连data\",\"description\":\"了解如何将数据连接到UI组件\"},\"fields\":{\"slug\":\"/docs/zh/data/\",\"chapter\":\"data\"}}},{\"node\":{\"frontmatter\":{\"tocTitle\":\"发布\",\"title\":\"发布 Storybook\",\"description\":\"使用 GitHub 和 Netlify 发布 Storybook网站 \"},\"fields\":{\"slug\":\"/docs/zh/deploy/\",\"chapter\":\"deploy\"}}},{\"node\":{\"frontmatter\":{\"tocTitle\":\"从头开始\",\"title\":\"开始吧\",\"description\":\"在你的开发环境下, 设置 React Storybook \"},\"fields\":{\"slug\":\"/docs/zh/get-started/\",\"chapter\":\"get-started\"}}},{\"node\":{\"frontmatter\":{\"tocTitle\":\"页面\",\"title\":\"构建一个页面\",\"description\":\"用组件构建一个页面\"},\"fields\":{\"slug\":\"/docs/zh/screen/\",\"chapter\":\"screen\"}}},{\"node\":{\"frontmatter\":{\"tocTitle\":\"简单 组件\",\"title\":\"构建一个简单的组件\",\"description\":\"单独构建一个简单的组件\"},\"fields\":{\"slug\":\"/docs/zh/simple-component/\",\"chapter\":\"simple-component\"}}},{\"node\":{\"frontmatter\":{\"tocTitle\":null,\"title\":\"测试\",\"description\":\"了解测试UI组件的方法\"},\"fields\":{\"slug\":\"/docs/zh/test/\",\"chapter\":\"test\"}}}]}},\"pathContext\":{\"slug\":\"/docs/zh/simple-component/\",\"framework\":\"docs\",\"language\":\"zh\",\"chapter\":\"simple-component\"}}\n\n/***/ })\n\n});\n\n\n// WEBPACK FOOTER //\n// path---docs-zh-simple-component-116e34d6f7018503d3d4.js","module.exports = {\"data\":{\"currentPage\":{\"html\":\"<h1>构建一个简单的组件</h1>\\n<p>我们将按照<a href=\\\"https://blog.hichroma.com/component-driven-development-ce1109d56c8e\\\">组件驱动开发</a> (CDD) 方法论来 构建我们的UI. 这是一个从\\\"自下而上\\\"开始构建UI的过程,从组件开始到整个页面结束. CDD 可帮助您在构建UI时,摆列您所面临的复杂程度. </p>\\n<h2>任务-Task</h2>\\n<p><img src=\\\"/task-states-learnstorybook.png\\\" alt=\\\"Task component in three states\\\"></p>\\n<p><code>Task</code>是我们的应用程序的核心组件. 每个任务的显示略有不同,具体取决于它所处的<code>状态-state</code>. 我们显示一个选中 (或未选中) 复选框,一些有关任务的信息,以及一个\\\"pin\\\"按钮,允许我们在列表中上下移动任务. 为了把各个它们摆在一起,我们需要下面的 <strong>props</strong>: </p>\\n<ul>\\n<li>\\n<p><code>title</code> - 描述任务的字符串</p>\\n</li>\\n<li>\\n<p><code>state</code> - 哪个列表是当前的任务,是否已检查?</p>\\n</li>\\n</ul>\\n<p>在我们开始构建<code>Task</code>时,我们首先编写 与 上面草图中不同类型的任务 相对应的测试状态. 然后我们使用 Storybook 模拟数据 隔离对应状态组件. 我们将\\\"视觉测试\\\"组件在每个状态下的外观. </p>\\n<p>这个过程类似于<a href=\\\"https://en.wikipedia.org/wiki/Test-driven_development\\\">测试驱动的开发(TDD)</a>,我们可以称之为<a href=\\\"https://blog.hichroma.com/visual-test-driven-development-aec1c98bed87\\\">\\\"Visual-虚拟 TDD\\\"</a></p>\\n<h2>获取设置</h2>\\n<p>首先,让我们创建任务组件 及 其附带的 <em>storybook-故事</em> 文件: </p>\\n<p><code>src/components/Task.js</code>和<code>src/components/Task.stories.js</code></p>\\n<p>我们将从基本实现开始,简单传入我们需要的<code>属性-props</code> 以及 您可以对任务执行的两个<code>on</code>操作 (在列表之间移动它) : </p>\\n<pre><code class=\\\"language-javascript\\\">import React from 'react';\\n\\nexport default function Task({ task: { id, title, state }, onArchiveTask, onPinTask }) {\\n  return (\\n    &#x3C;div className=\\\"list-item\\\">\\n      &#x3C;input type=\\\"text\\\" value={title} readOnly={true} />\\n    &#x3C;/div>\\n  );\\n}\\n</code></pre>\\n<p>上面,我们基于 Todos应用程序现有HTML结构 为 <code>Task</code>提供简单的 markup . </p>\\n<p>下面, 我们在 故事文件中 构建 Task的 三个测试状态: </p>\\n<pre><code class=\\\"language-javascript\\\">import React from 'react';\\nimport { storiesOf } from '@storybook/react';\\nimport { action } from '@storybook/addon-actions';\\n\\nimport Task from './Task';\\n\\nexport const task = {\\n  id: '1',\\n  title: 'Test Task',\\n  state: 'TASK_INBOX',\\n  updatedAt: new Date(2018, 0, 1, 9, 0),\\n};\\n\\nexport const actions = {\\n  onPinTask: action('onPinTask'),\\n  onArchiveTask: action('onArchiveTask'),\\n};\\n\\nstoriesOf('Task', module)\\n  .add('default', () => &#x3C;Task task={task} {...actions} />)\\n  .add('pinned', () => &#x3C;Task task={{ ...task, state: 'TASK_PINNED' }} {...actions} />)\\n  .add('archived', () => &#x3C;Task task={{ ...task, state: 'TASK_ARCHIVED' }} {...actions} />);\\n</code></pre>\\n<p>Storybook中有两个基本的组织级别. </p>\\n<p>该组件 及 其 child 故事. </p>\\n<p>将每个故事 视为组件的排列. 您可以根据需要为每个组件 创建 尽可能多的故事. </p>\\n<ul>\\n<li>\\n<p><strong>组件</strong></p>\\n<ul>\\n<li>故事</li>\\n<li>故事</li>\\n<li>故事</li>\\n</ul>\\n</li>\\n</ul>\\n<p>要开始 Storybook,我们先运<code>行 注册组件的</code>storiesOf()`函数. 我们为组件添加 <em>显示名称 -  Storybook应用程序侧栏上显示的名称</em>. </p>\\n<p><code>action()</code>允许我们创建一个回调, 当在Storybook UI的面板中 单击这个 <strong>action</strong> 时 回调触发. 因此,当我们构建一个pin按钮 时,我们将能够在 测试UI中 确定按钮单击 是否成功. </p>\\n<p>由于我们需要将 相同的一组操作 传递给 组件的所有排列,因此将它们捆绑到<code>actions</code>变量 并 使用React<code>{...actions}</code>的<code>porps</code>扩展以立即传递它们. <code>&#x3C;Task {...actions}></code>相当于<code>&#x3C;Task onPinTask={actions.onPinTask} onArchiveTask={actions.onArchiveTask}></code>. </p>\\n<p>关于捆绑<code>actions</code>的另一个好处就是,你可以<code>export-暴露</code>它们,用于重用该组件的组件,我们稍后会看到. </p>\\n<p>为了定义我们的故事,我们用<code>add()</code>,一次一个为我们的每个测试状态生成一个故事. <code>add</code>第二个参数是一个函数,它返回一个给定状态的渲染元素 (即带有一组<code>props</code>的组件类)  - 就像一个React<a href=\\\"https://reactjs.org/docs/components-and-props.html\\\">无状态功能组件</a>. </p>\\n<p>在创建故事时,我们使用基本任务 (<code>task</code>) 构建组件期望的 任务的形状. 这通常是 根据真实数据的模型建模的. 再次,正如我们所看到的,<code>export</code>这种形状将使我们能够在以后的故事中重复使用它. </p>\\n<div class=\\\"aside\\\">\\n<a href=\\\"https://storybook.js.org/addons/introduction/#2-native-addons\\\"><b>Actions</b></a> 帮助您在隔离构建UI组件时 验证交互. 通常，您无法访问应用程序上下文中的函数和状态。 使用 <code>action()</code> 将它们存入.\\n</div>\\n<h2>配置</h2>\\n<p>我们还必须对 Storybook的配置设置 (<code>.storybook/config.js</code>) 做一个小改动,让它注意到我们的<code>.stories.js</code>文件并使用我们的CSS文件. 默认情况下, Storybook 会查找故事<code>/stories</code>目录; 本教程使用类似于<code>.test.js</code>的命名方案, 这个命令是 <strong>CRA</strong> 赞成的用于自动化测试的方案. </p>\\n<pre><code class=\\\"language-javascript\\\">import { configure } from '@storybook/react';\\nimport '../src/index.css';\\n\\nconst req = require.context('../src', true, /.stories.js$/);\\n\\nfunction loadStories() {\\n  req.keys().forEach(filename => req(filename));\\n}\\n\\nconfigure(loadStories, module);\\n</code></pre>\\n<p>完成此操作后,重新启动 Storybook服务器 应该会产生 三个任务状态的测试用例: </p>\\n<video autoPlay muted playsInline controls >\\n  <source\\n    src=\\\"/inprogress-task-states.mp4\\\"\\n    type=\\\"video/mp4\\\"\\n  />\\n</video>\\n<h2>建立状态</h2>\\n<p>现在我们有 Storybook设置,导入的样式和构建的测试用例,我们可以快速开始实现组件的HTML,以匹配设计. </p>\\n<p>该组件目前仍然是基本的. 首先编写实现设计的代码,不用过多细节: </p>\\n<pre><code class=\\\"language-javascript\\\">import React from 'react';\\n\\nexport default function Task({ task: { id, title, state }, onArchiveTask, onPinTask }) {\\n  return (\\n    &#x3C;div className={`list-item ${state}`}>\\n      &#x3C;label className=\\\"checkbox\\\">\\n        &#x3C;input\\n          type=\\\"checkbox\\\"\\n          defaultChecked={state === 'TASK_ARCHIVED'}\\n          disabled={true}\\n          name=\\\"checked\\\"\\n        />\\n        &#x3C;span className=\\\"checkbox-custom\\\" onClick={() => onArchiveTask(id)} />\\n      &#x3C;/label>\\n      &#x3C;div className=\\\"title\\\">\\n        &#x3C;input type=\\\"text\\\" value={title} readOnly={true} placeholder=\\\"Input title\\\" />\\n      &#x3C;/div>\\n\\n      &#x3C;div className=\\\"actions\\\" onClick={event => event.stopPropagation()}>\\n        {state !== 'TASK_ARCHIVED' &#x26;&#x26; (\\n          &#x3C;a onClick={() => onPinTask(id)}>\\n            &#x3C;span className={`icon-star`} />\\n          &#x3C;/a>\\n        )}\\n      &#x3C;/div>\\n    &#x3C;/div>\\n  );\\n}\\n</code></pre>\\n<p>上面的附加 markup 与我们之前导入的CSS相结合,产生以下UI: </p>\\n<video autoPlay muted playsInline loop>\\n  <source\\n    src=\\\"/finished-task-states.mp4\\\"\\n    type=\\\"video/mp4\\\"\\n  />\\n</video>\\n<h2>特别数据要求</h2>\\n<p>最好的做法是<code>propTypes</code>在React中 指定组件所需的 数据形状. 它不仅可以自我记录,还有助于及早发现问题. </p>\\n<pre><code class=\\\"language-javascript\\\">import React from 'react';\\nimport PropTypes from 'prop-types';\\n\\nfunction Task() {\\n  ...\\n}\\n\\nTask.propTypes = {\\n  task: PropTypes.shape({\\n    id: PropTypes.string.isRequired,\\n    title: PropTypes.string.isRequired,\\n    state: PropTypes.string.isRequired,\\n  }),\\n  onArchiveTask: PropTypes.func,\\n  onPinTask: PropTypes.func,\\n};\\n\\nexport default Task;\\n</code></pre>\\n<p>现在,如果任务组件被滥用,则会出现开发警告. </p>\\n<div class=\\\"aside\\\">\\n另一种实现方法是使用 类似TypeScript的JavaScript类型系统 来为组件属性 创建类型。\\n</div>\\n<h2>组件构建!</h2>\\n<p>我们现在已成功构建了一个组件,没用到服务器或运行整个前端应用程序. 下一步是以类似的方式逐个构建剩余的 Taskbox组件. </p>\\n<p>如您所见,开始单独构建组件非常简单快捷. 我们可以期望生成更高质量的UI,减少错误和更多打磨,因为它可以挖掘并测试每个可能的状态. </p>\\n<h2>自动化测试</h2>\\n<p> Storybook 为我们提供了一种在施工期间,<code>可视化</code>测试我们的应用程序.在我们继续开发应用程序时,\\\"故事\\\"将有助于确保我们不会在视觉上打破我们的任务.\\n但是,在这个阶段,这是一个完全手动的过程,有人必须努力点击每个测试状态,并确保它呈现良好且没有错误或警告.\\n我们不能自动这样做吗?</p>\\n<h3>快照测试</h3>\\n<p>快照测试是指,记录 带一定输入的组件的\\\"已知良好\\\"输出,然后,将来 输出发生变化时标记组件 的做法.\\n这补充了 Storybook,因为快照 是查看 组件新版本 并 检查更改的快速方法. </p>\\n<div class=\\\"aside\\\">\\n确保您的组件呈现 <b>不变</b> 的数据，以便每次快照测试都不会失败。 注意日期或随机生成的值等内容。\\n</div>\\n<p>需要<a href=\\\"https://github.com/storybooks/storybook/tree/master/addons/storyshots\\\">Storyshots 插件</a>为每个故事创建 快照测试.\\n通过添加开发依赖项来使用它: </p>\\n<pre><code class=\\\"language-bash\\\">yarn add --dev @storybook/addon-storyshots react-test-renderer\\n</code></pre>\\n<p>然后创建一个<code>src/storybook.test.js</code>文件中包含以下内容: </p>\\n<pre><code class=\\\"language-javascript\\\">import initStoryshots from '@storybook/addon-storyshots';\\ninitStoryshots();\\n</code></pre>\\n<p>完成上述操作后,我们就可以运行了<code>yarn test</code>并看到以下输出: </p>\\n<p><img src=\\\"/task-testrunner.png\\\" alt=\\\"Task test runner\\\"></p>\\n<p>我们现在为每个<code>Task</code>故事进行快照测试. 如果我们改变了<code>Task</code>的实现,我们会提示您验证更改. </p>\",\"frontmatter\":{\"title\":\"构建一个简单的组件\",\"description\":\"单独构建一个简单的组件\",\"commit\":\"131aade\"},\"fields\":{\"slug\":\"/docs/zh/simple-component/\",\"chapter\":\"simple-component\",\"framework\":\"docs\",\"language\":\"zh\"}},\"site\":{\"siteMetadata\":{\"title\":\"binstd-区块链云服务平台\",\"toc\":[\"get-started\",\"simple-component\",\"composite-component\",\"data\",\"screen\",\"test\",\"deploy\",\"conclusion\",\"contribute\"],\"languages\":[\"en\",\"zh\"],\"githubUrl\":\"https://github.com/hichroma/learnstorybook.com\",\"codeGithubUrl\":\"https://github.com/hichroma/learnstorybook-code\",\"siteUrl\":\"https://binstd.com\"}},\"pages\":{\"edges\":[{\"node\":{\"frontmatter\":{\"tocTitle\":\"合成组件\",\"title\":\"组装复合组件\",\"description\":\"使用更简单的组件 组装复合组件\"},\"fields\":{\"slug\":\"/docs/zh/composite-component/\",\"chapter\":\"composite-component\"}}},{\"node\":{\"frontmatter\":{\"tocTitle\":null,\"title\":\"总结\",\"description\":\"把所有的知识汇总以下，学习更多的 storybook 技巧\"},\"fields\":{\"slug\":\"/docs/zh/conclusion/\",\"chapter\":\"conclusion\"}}},{\"node\":{\"frontmatter\":{\"tocTitle\":null,\"title\":\"帮助我们\",\"description\":\"帮助 我们与世界分享 Storybook \"},\"fields\":{\"slug\":\"/docs/zh/contribute/\",\"chapter\":\"contribute\"}}},{\"node\":{\"frontmatter\":{\"tocTitle\":\"Data\",\"title\":\"接连data\",\"description\":\"了解如何将数据连接到UI组件\"},\"fields\":{\"slug\":\"/docs/zh/data/\",\"chapter\":\"data\"}}},{\"node\":{\"frontmatter\":{\"tocTitle\":\"发布\",\"title\":\"发布 Storybook\",\"description\":\"使用 GitHub 和 Netlify 发布 Storybook网站 \"},\"fields\":{\"slug\":\"/docs/zh/deploy/\",\"chapter\":\"deploy\"}}},{\"node\":{\"frontmatter\":{\"tocTitle\":\"从头开始\",\"title\":\"开始吧\",\"description\":\"在你的开发环境下, 设置 React Storybook \"},\"fields\":{\"slug\":\"/docs/zh/get-started/\",\"chapter\":\"get-started\"}}},{\"node\":{\"frontmatter\":{\"tocTitle\":\"页面\",\"title\":\"构建一个页面\",\"description\":\"用组件构建一个页面\"},\"fields\":{\"slug\":\"/docs/zh/screen/\",\"chapter\":\"screen\"}}},{\"node\":{\"frontmatter\":{\"tocTitle\":\"简单 组件\",\"title\":\"构建一个简单的组件\",\"description\":\"单独构建一个简单的组件\"},\"fields\":{\"slug\":\"/docs/zh/simple-component/\",\"chapter\":\"simple-component\"}}},{\"node\":{\"frontmatter\":{\"tocTitle\":null,\"title\":\"测试\",\"description\":\"了解测试UI组件的方法\"},\"fields\":{\"slug\":\"/docs/zh/test/\",\"chapter\":\"test\"}}}]}},\"pathContext\":{\"slug\":\"/docs/zh/simple-component/\",\"framework\":\"docs\",\"language\":\"zh\",\"chapter\":\"simple-component\"}}\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/json-loader!./.cache/json/docs-zh-simple-component.json\n// module id = 882\n// module chunks = 21313861147051"],"sourceRoot":""}