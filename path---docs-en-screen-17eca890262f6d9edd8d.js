webpackJsonp([0xe61600bbb146],{863:function(e,o){e.exports={data:{currentPage:{html:"<h1>Construct a screen</h1>\n<p>We've concentrated on building UIs from the bottom up; starting small and adding complexity. Doing so has allowed us to develop each component in isolation, figure out its data needs, and play with it in Storybook. All without needing to stand up a server or build out screens!</p>\n<p>In this chapter we continue to increase the sophistication by combining components in a screen and developing that screen in Storybook.</p>\n<h2>Nested container components</h2>\n<p>As our app is very simple, the screen we’ll build is pretty trivial, simply wrapping the <code>TaskList</code> component (which supplies its own data via Redux) in some layout and pulling a top-level <code>error</code> field out of redux (let's assume we'll set that field if we have some problem connecting to our server). Create <code>InboxScreen.js</code> in your <code>components</code> folder:</p>\n<pre><code class=\"language-javascript\">import React from 'react';\nimport PropTypes from 'prop-types';\nimport { connect } from 'react-redux';\n\nimport TaskList from './TaskList';\n\nexport function PureInboxScreen({ error }) {\n  if (error) {\n    return (\n      &#x3C;div className=\"page lists-show\">\n        &#x3C;div className=\"wrapper-message\">\n          &#x3C;span className=\"icon-face-sad\" />\n          &#x3C;div className=\"title-message\">Oh no!&#x3C;/div>\n          &#x3C;div className=\"subtitle-message\">Something went wrong&#x3C;/div>\n        &#x3C;/div>\n      &#x3C;/div>\n    );\n  }\n\n  return (\n    &#x3C;div className=\"page lists-show\">\n      &#x3C;nav>\n        &#x3C;h1 className=\"title-page\">\n          &#x3C;span className=\"title-wrapper\">Taskbox&#x3C;/span>\n        &#x3C;/h1>\n      &#x3C;/nav>\n      &#x3C;TaskList />\n    &#x3C;/div>\n  );\n}\n\nPureInboxScreen.propTypes = {\n  error: PropTypes.string,\n};\n\nPureInboxScreen.defaultProps = {\n  error: null,\n};\n\nexport default connect(({ error }) => ({ error }))(PureInboxScreen);\n</code></pre>\n<p>We also change the <code>App</code> component to render the <code>InboxScreen</code> (eventually we would use a router to choose the correct screen, but let's not worry about that here):</p>\n<pre><code class=\"language-javascript\">import React, { Component } from 'react';\nimport { Provider } from 'react-redux';\nimport store from './lib/redux';\n\nimport InboxScreen from './components/InboxScreen';\n\nclass App extends Component {\n  render() {\n    return (\n      &#x3C;Provider store={store}>\n        &#x3C;InboxScreen />\n      &#x3C;/Provider>\n    );\n  }\n}\n\nexport default App;\n</code></pre>\n<p>However, where things get interesting is in rendering the story in Storybook.</p>\n<p>As we saw previously, the <code>TaskList</code> component is a <strong>container</strong> that renders the <code>PureTaskList</code> presentational component. By definition container components cannot be simply rendered in isolation; they expect to be passed some context or to connect to a service. What this means is that to render a container in Storybook, we must mock (i.e. provide a pretend version) the context or service it requires.</p>\n<p>When placing the <code>TaskList</code> into Storybook, we were able to dodge this issue by simply rendering the <code>PureTaskList</code> and avoiding the container. We'll do something similar and render the <code>PureInboxScreen</code> in Storybook also.</p>\n<p>However, for the <code>PureInboxScreen</code> we have a problem because although the <code>PureInboxScreen</code> itself is presentational, its child, the <code>TaskList</code>, is not. In a sense the <code>PureInboxScreen</code> has been polluted by “container-ness”. So when we setup our stories in <code>InboxScreen.stories.js</code>:</p>\n<pre><code class=\"language-javascript\">import React from 'react';\nimport { storiesOf } from '@storybook/react';\n\nimport { PureInboxScreen } from './InboxScreen';\n\nstoriesOf('InboxScreen', module)\n  .add('default', () => &#x3C;PureInboxScreen />)\n  .add('error', () => &#x3C;PureInboxScreen error=\"Something\" />);\n</code></pre>\n<p>We see that although the <code>error</code> story works just fine, we have an issue in the <code>default</code> story, because the <code>TaskList</code> has no Redux store to connect to. (You also would encounter similar problems when trying to test the <code>PureInboxScreen</code> with a unit test).</p>\n<p><img src=\"/broken-inboxscreen.png\" alt=\"Broken inbox\"></p>\n<p>One way to sidestep this problem is to never render container components anywhere in your app except at the highest level and instead pass all data-requirements down the component hierarchy.</p>\n<p>However, developers <strong>will</strong> inevitably need to render containers further down the component hierarchy. If we want to render most or all of the app in Storybook (we do!), we need a solution to this issue.</p>\n<div class=\"aside\">\nAs an aside, passing data down the hierarchy is a legitimate approach, especially when using <a href=\"http://graphql.org/\">GraphQL</a>. It’s how we have built <a href=\"https://chromaticqa.com\">Chromatic</a> alongside 670+ stories.\n</div>\n<h2>Supplying context with decorators</h2>\n<p>The good news is that it is easy to supply a Redux store to the <code>InboxScreen</code> in a story! We can just use a mocked version of the Redux store provided in a decorator:</p>\n<pre><code class=\"language-javascript\">import React from 'react';\nimport { storiesOf } from '@storybook/react';\nimport { action } from '@storybook/addon-actions';\nimport { Provider } from 'react-redux';\n\nimport { PureInboxScreen } from './InboxScreen';\nimport { defaultTasks } from './TaskList.stories';\n\n// A super-simple mock of a redux store\nconst store = {\n  getState: () => {\n    return {\n      tasks: defaultTasks,\n    };\n  },\n  subscribe: () => 0,\n  dispatch: action('dispatch'),\n};\n\nstoriesOf('InboxScreen', module)\n  .addDecorator(story => &#x3C;Provider store={store}>{story()}&#x3C;/Provider>)\n  .add('default', () => &#x3C;PureInboxScreen />)\n  .add('error', () => &#x3C;PureInboxScreen error=\"Something\" />);\n</code></pre>\n<p>Similar approaches exist to provide mocked context for other data libraries, such as <a href=\"https://www.npmjs.com/package/apollo-storybook-decorator\">Apollo</a>, <a href=\"https://github.com/orta/react-storybooks-relay-container\">Relay</a> and others.</p>\n<p>Cycling through states in Storybook makes it easy to test we’ve done this correctly:</p>\n<video autoPlay muted playsInline loop >\n  <source\n    src=\"/finished-inboxscreen-states.mp4\"\n    type=\"video/mp4\"\n  />\n</video>\n<h2>Component-Driven Development</h2>\n<p>We started from the bottom with <code>Task</code>, then progressed to <code>TaskList</code>, now we’re here with a whole screen UI. Our <code>InboxScreen</code> accommodates a nested container component and includes accompanying stories.</p>\n<video autoPlay muted playsInline loop style=\"width:480px; height:auto; margin: 0 auto;\">\n  <source\n    src=\"/component-driven-development-optimized.mp4\"\n    type=\"video/mp4\"\n  />\n</video>\n<p><a href=\"https://blog.hichroma.com/component-driven-development-ce1109d56c8e\"><strong>Component-Driven Development</strong></a> allows you to gradually expand complexity as you move up the component hierarchy. Among the benefits are a more focused development process and increased coverage of all possible UI permutations. In short, CDD helps you build higher-quality and more complex user interfaces.</p>\n<p>We’re not done yet - the job doesn't end when the UI is built. We also need to ensure that it remains durable over time.</p>",frontmatter:{title:"Construct a screen",description:"Construct a screen out of components",commit:"9ead5d8"},fields:{slug:"/docs/en/screen/",chapter:"screen",framework:"docs",language:"en"}},site:{siteMetadata:{title:"binstd-区块链云服务平台",toc:["get-started","simple-component","composite-component","data","screen","test","deploy","conclusion","contribute"],languages:["en","zh"],githubUrl:"https://github.com/hichroma/learnstorybook.com",codeGithubUrl:"https://github.com/hichroma/learnstorybook-code",siteUrl:"https://binstd.com"}},pages:{edges:[{node:{frontmatter:{tocTitle:"Composite component",title:"Assemble a composite component",description:"Assemble a composite component out of simpler components"},fields:{slug:"/docs/en/composite-component/",chapter:"composite-component"}}},{node:{frontmatter:{tocTitle:null,title:"Conclusion",description:"Put all your knowledge together and learn more Storybook techniques"},fields:{slug:"/docs/en/conclusion/",chapter:"conclusion"}}},{node:{frontmatter:{tocTitle:null,title:"Contribute",description:"Help share Storybook with the world"},fields:{slug:"/docs/en/contribute/",chapter:"contribute"}}},{node:{frontmatter:{tocTitle:"Data",title:"Wire in data",description:"Learn how to wire in data to your UI component"},fields:{slug:"/docs/en/data/",chapter:"data"}}},{node:{frontmatter:{tocTitle:"Deploy",title:"Deploy Storybook",description:"Deploy Storybook online with GitHub and Netlify"},fields:{slug:"/docs/en/deploy/",chapter:"deploy"}}},{node:{frontmatter:{tocTitle:"Get started",title:"Get started",description:"Setup React Storybook in your development environment"},fields:{slug:"/docs/en/get-started/",chapter:"get-started"}}},{node:{frontmatter:{tocTitle:"Screens",title:"Construct a screen",description:"Construct a screen out of components"},fields:{slug:"/docs/en/screen/",chapter:"screen"}}},{node:{frontmatter:{tocTitle:"Simple component",title:"Build a simple component",description:"Build a simple component in isolation"},fields:{slug:"/docs/en/simple-component/",chapter:"simple-component"}}},{node:{frontmatter:{tocTitle:null,title:"Testing",description:"Learn the ways to test UI components"},fields:{slug:"/docs/en/test/",chapter:"test"}}}]}},pathContext:{slug:"/docs/en/screen/",framework:"docs",language:"en",chapter:"screen"}}}});
//# sourceMappingURL=path---docs-en-screen-17eca890262f6d9edd8d.js.map