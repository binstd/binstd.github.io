webpackJsonp([0x97121d11373f],{875:function(t,s){t.exports={data:{currentPage:{html:"<h1>组装复合组件</h1>\n<p>上一章我们构建了第一个组件; 本章 我们学习 扩展构建TaskList的任务列表. 让我们将 组件组合 在一起,看看在引入更多复杂性时会发生什么. </p>\n<h2>任务列表</h2>\n<p>Taskbox 通过将 固定任务 置于默认任务之上 来强调 固定任务. 这产生了两种变体<code>TaskList</code>您需要为以下内容创建故事: 默认项目 以及 默认和 固定项目. </p>\n<p><img src=\"/tasklist-states-1.png\" alt=\"default and pinned tasks\"></p>\n<p><code>Task</code>可以异步发送数据,我们 <strong>也</strong>需要在没有连接的情况下 loading 渲染 <em>右图</em>. 此外,当没有任务时,需要 空状态 <em>左图</em>. </p>\n<p><img src=\"/tasklist-states-2.png\" alt=\"empty and loading tasks\"></p>\n<h2>获取设置</h2>\n<p>复合组件与 其包含的基本组件没有太大区别. 创建一个<code>TaskList</code>组件和 对应的故事文件: <code>src/components/TaskList.js</code>和<code>src/components/TaskList.stories.js</code>. </p>\n<p>从粗略的实现开始<code>TaskList</code>. 你需要导入早期的<code>Task</code>组件,并将 属性和操作 作为输入传递. </p>\n<pre><code class=\"language-javascript\">import React from 'react';\n\nimport Task from './Task';\n\nfunction TaskList({ loading, tasks, onPinTask, onArchiveTask }) {\n  const events = {\n    onPinTask,\n    onArchiveTask,\n  };\n\n  if (loading) {\n    return &#x3C;div className=\"list-items\">loading&#x3C;/div>;\n  }\n\n  if (tasks.length === 0) {\n    return &#x3C;div className=\"list-items\">empty&#x3C;/div>;\n  }\n\n  return (\n    &#x3C;div className=\"list-items\">\n      {tasks.map(task => &#x3C;Task key={task.id} task={task} {...events} />)}\n    &#x3C;/div>\n  );\n}\n\nexport default TaskList;\n</code></pre>\n<p>接下来创建<code>Tasklist</code>故事文件中的测试状态. </p>\n<pre><code class=\"language-javascript\">import React from 'react';\nimport { storiesOf } from '@storybook/react';\n\nimport TaskList from './TaskList';\nimport { task, actions } from './Task.stories';\n\nexport const defaultTasks = [\n  { ...task, id: '1', title: 'Task 1' },\n  { ...task, id: '2', title: 'Task 2' },\n  { ...task, id: '3', title: 'Task 3' },\n  { ...task, id: '4', title: 'Task 4' },\n  { ...task, id: '5', title: 'Task 5' },\n  { ...task, id: '6', title: 'Task 6' },\n];\n\nexport const withPinnedTasks = [\n  ...defaultTasks.slice(0, 5),\n  { id: '6', title: 'Task 6 (pinned)', state: 'TASK_PINNED' },\n];\n\nstoriesOf('TaskList', module)\n  .addDecorator(story => &#x3C;div style={{ padding: '3rem' }}>{story()}&#x3C;/div>)\n  .add('default', () => &#x3C;TaskList tasks={defaultTasks} {...actions} />)\n  .add('withPinnedTasks', () => &#x3C;TaskList tasks={withPinnedTasks} {...actions} />)\n  .add('loading', () => &#x3C;TaskList loading tasks={[]} {...actions} />)\n  .add('empty', () => &#x3C;TaskList tasks={[]} {...actions} />);\n</code></pre>\n<p><code>addDecorator()</code>允许我们为每个任务的渲染添加一些\"上下文\". 在这种情况下,我们在列表周围添加 <em>填充-padding</em>,以便更容易进行 可视化验证. </p>\n<div class=\"aside\">\n<a href=\"https://storybook.js.org/addons/introduction/#1-decorators\"><b>Decorators-装饰器</b></a> 是一种为 故事 提供任意包装的方法。 在这种情况下，我们使用装饰器来添加样式。 它们还可以用于包装故事在 <b>\"providers\" - 设置 React上下文 的库组件</b>.\n</div>\n<p><code>task</code>提供一个<code>Task</code>的形状,这是通过我们创建和导出的<code>Task.stories.js</code>文件. 同样的,<code>actions</code>定义<code>Task</code>组件期望的操作 (模拟回调) ,其中<code>TaskList</code>也需要. </p>\n<p>现在查看 Storybook的新内容<code>TaskList</code>故事. </p>\n<video autoPlay muted playsInline loop>\n  <source\n    src=\"/inprogress-tasklist-states.mp4\"\n    type=\"video/mp4\"\n  />\n</video>\n<h2>建立状态</h2>\n<p>我们的组件仍然很粗糙,但现在我们已经了解了 要努力的故事. 你可能会想到<code>.list-items</code>包装过于简单化. 你是对的 - 在大多数情况下,我们不会只是添加一个包装器来创建一个新的组件. 但是 <strong>真正的复杂性</strong> 的<code>TaskList</code>组件在边缘情况下会显示<code>withPinnedTasks</code>,<code>loading</code>,和<code>empty</code>. </p>\n<pre><code class=\"language-javascript\">import React from 'react';\n\nimport Task from './Task';\n\nfunction TaskList({ loading, tasks, onPinTask, onArchiveTask }) {\n  const events = {\n    onPinTask,\n    onArchiveTask,\n  };\n\n  const LoadingRow = (\n    &#x3C;div className=\"loading-item\">\n      &#x3C;span className=\"glow-checkbox\" />\n      &#x3C;span className=\"glow-text\">\n        &#x3C;span>Loading&#x3C;/span> &#x3C;span>cool&#x3C;/span> &#x3C;span>state&#x3C;/span>\n      &#x3C;/span>\n    &#x3C;/div>\n  );\n\n  if (loading) {\n    return (\n      &#x3C;div className=\"list-items\">\n        {LoadingRow}\n        {LoadingRow}\n        {LoadingRow}\n        {LoadingRow}\n        {LoadingRow}\n        {LoadingRow}\n      &#x3C;/div>\n    );\n  }\n\n  if (tasks.length === 0) {\n    return (\n      &#x3C;div className=\"list-items\">\n        &#x3C;div className=\"wrapper-message\">\n          &#x3C;span className=\"icon-check\" />\n          &#x3C;div className=\"title-message\">You have no tasks&#x3C;/div>\n          &#x3C;div className=\"subtitle-message\">Sit back and relax&#x3C;/div>\n        &#x3C;/div>\n      &#x3C;/div>\n    );\n  }\n\n  const tasksInOrder = [\n    ...tasks.filter(t => t.state === 'TASK_PINNED'), //&#x3C; ==== 固定顶部\n    ...tasks.filter(t => t.state !== 'TASK_PINNED'),\n  ];\n\n  return (\n    &#x3C;div className=\"list-items\">\n      {tasksInOrder.map(task => &#x3C;Task key={task.id} task={task} {...events} />)}\n    &#x3C;/div>\n  );\n}\n\nexport default TaskList;\n</code></pre>\n<p>添加的标记会产生以下UI: </p>\n<video autoPlay muted playsInline loop>\n  <source\n    src=\"/finished-tasklist-states.mp4\"\n    type=\"video/mp4\"\n  />\n</video>\n<p>请注意列表中 固定项 的位置. 我们希望固定项目在 列表顶部 呈现,以使其成为我们用户的优先事项. </p>\n<h2>数据要求和props</h2>\n<p>随着组件的增长,输入要求也在增长. 要求定义<code>TaskList</code>的<em>props</em>. 因为<code>Task</code>是一个子组件,请确保提供 正确形状的数据 来呈现它. 为了节省时间和头痛,请重用您定义的早期<code>Task</code>的propTypes. </p>\n<pre><code class=\"language-javascript\">import React from 'react';\nimport PropTypes from 'prop-types';\n\nfunction TaskList() {\n  ...\n}\n\n\nTaskList.propTypes = {\n  loading: PropTypes.bool,\n  tasks: PropTypes.arrayOf(Task.propTypes.task).isRequired,\n  onPinTask: PropTypes.func.isRequired,\n  onArchiveTask: PropTypes.func.isRequired,\n};\n\nTaskList.defaultProps = {\n  loading: false,\n};\n\nexport default TaskList;\n</code></pre>\n<h2>自动化测试</h2>\n<p>在上一章中,我们学习了如何使用 Storyshots快照测试 故事. <code>Task</code>测试没有太多的复杂性,已然够用了. 而<code>TaskList</code>增加了另一层复杂性,我们希望 以 自动测试 的方式验证 某些输入产生某些输出. 为此,我们将使用创建单 元测试<a href=\"https://facebook.github.io/jest/\">jest-笑话</a>再加上测试渲染器等<a href=\"http://airbnb.io/enzyme/\">Enzyme</a>. </p>\n<p><img src=\"/logo-jest.png\" alt=\"Jest logo\"></p>\n<h3>用Jest进行单元测试</h3>\n<p> Storybook故事 与 手动可视化测试 和 快照测试 (见上文) 相结合,可以避免 UI错误. 如果故事 涵盖了 各种各样的组件用例,并且我们使用的工具可以确保 人员检查故事的任何变化,那么错误的可能性就大大降低. </p>\n<p>然而,有时候魔鬼是在细节中. 需要一个明确有关这些细节的测试框架. 这让我们进行了单元测试. </p>\n<p>在我们的例子中,我们希望我们的<code>TaskList</code>,在传递 不固定tasks 之前,呈现所有固定tasks. 虽然我们有一个故事 (<code>withPinnedTasks</code>) 测试这个确切的场景; 但是如果组件停止对 这样的任务 进行排序，那么就人类看着来说，这可能是不明确的,<em>因为只看到表面与操作</em>, 这是一个bug. 它肯定不会尖叫 <strong>\"错误!\"</strong> 直怼眼睛. </p>\n<p>因此,为了避免这个问题,我们可以使用Jest 将故事呈现给<code>DOM</code>,并运行一些<code>DOM</code>查询代码,来验证输出的显着特征. </p>\n<p>创建一个名为的测试文件<code>TaskList.test.js</code>. 在这里,我们将构建我们的测试,对输出进行断言. </p>\n<pre><code class=\"language-javascript\">import React from 'react';\nimport ReactDOM from 'react-dom';\nimport TaskList from './TaskList';\nimport { withPinnedTasks } from './TaskList.stories';\n\nit('renders pinned tasks at the start of the list', () => {\n  const div = document.createElement('div');\n  const events = { onPinTask: jest.fn(), onArchiveTask: jest.fn() };\n  ReactDOM.render(&#x3C;TaskList tasks={withPinnedTasks} {...events} />, div);\n\n  // 我们期望首先渲染标题为“任务6（固定）”的任务，而不是最后\n  const lastTaskInput = div.querySelector('.list-item:nth-child(1) input[value=\"Task 6 (pinned)\"]');\n  expect(lastTaskInput).not.toBe(null);\n\n  ReactDOM.unmountComponentAtNode(div);\n});\n</code></pre>\n<p><img src=\"/tasklist-testrunner.png\" alt=\"TaskList test runner\"></p>\n<p>请注意,我们已经能够重用<code>withPinnedTasks</code>故事 和单元测试中的任务列表;通过这种方式,我们可以继续以越来越多的方式利用现有资源(代表组件的有趣配置的示例) . </p>\n<p>另请注意,此测试非常脆弱. 随着项目的成熟,以及项目的确切实现,这都可能是<code>Task</code>的更改 - 可能使用 不同的类名或<code>textarea</code>而不是一个<code>input</code>- 测试将失败,需要更新. 这不一定是一个问题,但使用UI的 单元测试 要小心的指示. 它们不容易维护. 替代的是依靠视觉,快照和视觉回归 (参见<a href=\"/test/\">测试章节</a>) 的 Stortbook测试. </p>",frontmatter:{title:"组装复合组件",description:"使用更简单的组件 组装复合组件",commit:"5776042"},fields:{slug:"/docs/zh/composite-component/",chapter:"composite-component",framework:"docs",language:"zh"}},site:{siteMetadata:{title:"binstd-区块链云服务平台",toc:["get-started","simple-component","composite-component","data","screen","test","deploy","conclusion","contribute"],languages:["en","zh"],githubUrl:"https://github.com/hichroma/learnstorybook.com",codeGithubUrl:"https://github.com/hichroma/learnstorybook-code",siteUrl:"https://binstd.com"}},pages:{edges:[{node:{frontmatter:{tocTitle:"合成组件",title:"组装复合组件",description:"使用更简单的组件 组装复合组件"},fields:{slug:"/docs/zh/composite-component/",chapter:"composite-component"}}},{node:{frontmatter:{tocTitle:null,title:"总结",description:"把所有的知识汇总以下，学习更多的 storybook 技巧"},fields:{slug:"/docs/zh/conclusion/",chapter:"conclusion"}}},{node:{frontmatter:{tocTitle:null,title:"帮助我们",description:"帮助 我们与世界分享 Storybook "},fields:{slug:"/docs/zh/contribute/",chapter:"contribute"}}},{node:{frontmatter:{tocTitle:"Data",title:"接连data",description:"了解如何将数据连接到UI组件"},fields:{slug:"/docs/zh/data/",chapter:"data"}}},{node:{frontmatter:{tocTitle:"发布",title:"发布 Storybook",description:"使用 GitHub 和 Netlify 发布 Storybook网站 "},fields:{slug:"/docs/zh/deploy/",chapter:"deploy"}}},{node:{frontmatter:{tocTitle:"从头开始",title:"开始吧",description:"在你的开发环境下, 设置 React Storybook "},fields:{slug:"/docs/zh/get-started/",chapter:"get-started"}}},{node:{frontmatter:{tocTitle:"页面",title:"构建一个页面",description:"用组件构建一个页面"},fields:{slug:"/docs/zh/screen/",chapter:"screen"}}},{node:{frontmatter:{tocTitle:"简单 组件",title:"构建一个简单的组件",description:"单独构建一个简单的组件"},fields:{slug:"/docs/zh/simple-component/",chapter:"simple-component"}}},{node:{frontmatter:{tocTitle:null,title:"测试",description:"了解测试UI组件的方法"},fields:{slug:"/docs/zh/test/",chapter:"test"}}}]}},pathContext:{slug:"/docs/zh/composite-component/",framework:"docs",language:"zh",chapter:"composite-component"}}}});
//# sourceMappingURL=path---docs-zh-composite-component-5cf09c557d077740832c.js.map