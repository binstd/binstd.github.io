webpackJsonp([0xa88643d5b602],{873:function(e,o){e.exports={data:{currentPage:{html:'<h1>Construye un componente simple</h1>\n<p>Construiremos nuestra UI siguiendo la metodología (CDD) <a href="https://blog.hichroma.com/component-driven-development-ce1109d56c8e">Component-Driven Development</a>. Es un proceso que construye UIs de “abajo hacia arriba”, empezando con los componentes y terminando con las vistas. CDD te ayudará a escalar la cantidad de complejidad con la que te enfrentas a medida que construyes la UI.</p>\n<h2>Task - Tarea</h2>\n<p><img src="/task-states-learnstorybook.png" alt="Task component in three states"></p>\n<p><code>Task</code> (o Tarea) es el componente principal en nuestra app. Cada tarea se muestra de forma ligeramente diferente según el estado en el que se encuentre. Mostramos un checkbox marcado (o no marcado), información sobre la tarea y un botón “pin” que nos permite mover la tarea hacia arriba o abajo en la lista de tareas. Poniendo esto en conjunto, necesitaremos estas propiedades -props- :</p>\n<ul>\n<li><code>title</code> – un string que describe la tarea</li>\n<li><code>state</code> - en que lista se encuentra la tarea actualmente? y, está marcado el checkbox?</li>\n</ul>\n<p>A medida que comencemos a construir <code>Task</code>, primero escribiremos nuestros tests para los estados que corresponden a los distintos tipos de tareas descritas anteriormente. Luego, utilizamos Storybook para construir el componente de forma aislada usando datos de prueba. Vamos a “testear visualmente” la apariencia del componente a medida que cambiemos cada estado.</p>\n<p>Este proceso es similar a <a href="https://en.wikipedia.org/wiki/Test-driven_development">Test-driven development</a> (TDD) al que podemos llamar “<a href="https://blog.hichroma.com/visual-test-driven-development-aec1c98bed87">Visual TDD</a>”.</p>\n<h2>Ajustes iniciales</h2>\n<p>Primero, vamos a crear el componente Task y el archivo de historias de storybook que lo acompaña: <code>src/components/Task.js</code> y <code>src/components/Task.stories.js</code>.</p>\n<p>Comenzaremos con una implementación básica de <code>Task</code>, simplemente teniendo en cuenta los atributos que sabemos que necesitaremos y las dos acciones que puedes realizar con una tarea (para moverla entre las listas):</p>\n<pre><code class="language-javascript">import React from \'react\';\n\nexport default function Task({ task: { id, title, state }, onArchiveTask, onPinTask }) {\n  return (\n    &#x3C;div className="list-item">\n      &#x3C;input type="text" value={title} readOnly={true} />\n    &#x3C;/div>\n  );\n}\n</code></pre>\n<p>Arriba, renderizamos directamente <code>Task</code> basándonos en la estructura HTML existente de la app Todos.</p>\n<p>A continuación creamos los tres estados de prueba de Task dentro del archivo de historia:</p>\n<pre><code class="language-javascript">import React from \'react\';\nimport { storiesOf } from \'@storybook/react\';\nimport { action } from \'@storybook/addon-actions\';\n\nimport Task from \'./Task\';\n\nexport function createTask(attrs) {\n  return {\n    id: Math.round(Math.random() * 1000000).toString(),\n    title: \'Test Task\',\n    state: \'TASK_INBOX\',\n    updatedAt: Date.now(),\n    ...attrs,\n  };\n}\n\nexport const actions = {\n  onPinTask: action(\'onPinTask\'),\n  onArchiveTask: action(\'onArchiveTask\'),\n};\n\nstoriesOf(\'Task\', module)\n  .add(\'default\', () => &#x3C;Task task={createTask({ state: \'TASK_INBOX\' })} {...actions} />)\n  .add(\'pinned\', () => &#x3C;Task task={createTask({ state: \'TASK_PINNED\' })} {...actions} />)\n  .add(\'archived\', () => &#x3C;Task task={createTask({ state: \'TASK_ARCHIVED\' })} {...actions} />);\n</code></pre>\n<p>Existen dos niveles básicos de organización en Storybook. El componente y sus historias hijas. Piensa en cada historia como una permutación posible del componente. Puedes tener tantas historias por componente como se necesite.</p>\n<ul>\n<li>\n<p><strong>Component</strong></p>\n<ul>\n<li>Story</li>\n<li>Story</li>\n<li>Story</li>\n</ul>\n</li>\n</ul>\n<p>Para iniciar Storybook, primero invocamos a la función <code>storiesOf()</code> para registrar el componente. Agregamos un nombre para mostrar el componente, que se muestra en la barra lateral de la aplicación Storybook.</p>\n<p><code>action()</code> nos permite crear un callback que aparecerá en el panel <strong>actions</strong> de la UI de Storybook cuando es cliqueado. Entonces, cuando construyamos un botón pin, podremos determinar en la UI de prueba si un click en el botón es exitoso o no.</p>\n<p>Como necesitamos pasarle el mismo conjunto de acciones a todas las permutaciones de nuestro componente, es conveniente agruparlas en una sola variable <code>actions</code> y utilizar <code>{...actions}</code>, la expansión de propiedades de React, para pasarlas todas a la vez. <code>&#x3C;Task {...actions}></code> es equivalente a <code>&#x3C;Task onPinTask={actions.onPinTask} onArchiveTask={actions.onArchiveTask}></code>.</p>\n<p>Otra cosa positiva acerca de agrupar las <code>actions</code> que un componente necesita, es que puedes usar <code>export</code> y utilizarlas en historias para otros componentes que reutilicen este componente, como veremos luego.</p>\n<p>Para definir nuestras historias, llamamos a <code>add()</code> una vez para cada uno de nuestros estados del test para generar una historia. La historia de acción - action story - es una función que retorna un elemento renderizado (es decir, una clase componente con un conjunto de props) en un estado dado---exactamente como en React <a href="https://reactjs.org/docs/components-and-props.html">Stateless Functional Component</a>.</p>\n<p>Al crear una historia utilizamos una función auxiliar (<code>createTask()</code>) para construir la forma de la task que el componente espera. Esto generalmente se modela a partir del aspecto de los datos verdaderos. Nuevamente, <code>export</code>-ando esta función nos permitirá reutilizarla en historias posteriores, como veremos.</p>\n<div class="aside">\nLas <a href="https://storybook.js.org/addons/introduction/#2-native-addons"><b>Acciones</b></a> ayudan a verificar las interacciones cuando creamos componentes UI en aislamiento. A menudo no tendrás acceso a las funciones y el estado que tienes en el contexto de la aplicación. Utiliza <code>action()</code> para agregarlas.\n</div>\n<h2>Configuración</h2>\n<p>También necesitamos hacer un pequeño cambio en la configuración de Storybook (<code>.storybook/config.js</code>) para que tenga en cuenta nuestros archivos <code>.stories.js</code> y use nuestro archivo CSS. Por defecto, Storybook busca historias en el directorio <code>/stories</code>; este tutorial usa un esquema de nombres que es similar al esquema de nombres <code>.test.js</code> preferido por CRA para pruebas -tests- automatizadas.</p>\n<pre><code class="language-javascript">import { configure } from \'@storybook/react\';\nimport \'../src/index.css\';\n\nconst req = require.context(\'../src\', true, /.stories.js$/);\n\nfunction loadStories() {\n  req.keys().forEach(filename => req(filename));\n}\n\nconfigure(loadStories, module);\n</code></pre>\n<p>Una vez que hayamos hecho esto, reiniciando el servidor de Storybook debería producir casos de prueba para los tres estados de Task:</p>\n<video autoPlay muted playsInline controls >\n  <source\n    src="/inprogress-task-states.mp4"\n    type="video/mp4"\n  />\n</video>\n<h2>Construyendo los estados</h2>\n<p>Ahora tenemos configurado Storybook, los estilos importados y los casos de prueba construidos; podemos comenzar rápidamente el trabajo de implementar el HTML del componente para que coincida con el diseño.</p>\n<p>El componente todavía es básico. Primero escribiremos el código que se aproxima al diseño sin entrar en demasiados detalles:</p>\n<pre><code class="language-javascript">import React from \'react\';\n\nexport default function Task({ task: { id, title, state }, onArchiveTask, onPinTask }) {\n  return (\n    &#x3C;div className={`list-item ${state}`}>\n      &#x3C;label className="checkbox">\n        &#x3C;input\n          type="checkbox"\n          defaultChecked={state === \'TASK_ARCHIVED\'}\n          disabled={true}\n          name="checked"\n        />\n        &#x3C;span className="checkbox-custom" onClick={() => onArchiveTask(id)} />\n      &#x3C;/label>\n      &#x3C;div className="title">\n        &#x3C;input type="text" value={title} readOnly={true} placeholder="Input title" />\n      &#x3C;/div>\n\n      &#x3C;div className="actions" onClick={event => event.stopPropagation()}>\n        {state !== \'TASK_ARCHIVED\' &#x26;&#x26; (\n          &#x3C;a onClick={() => onPinTask(id)}>\n            &#x3C;span className={`icon-star`} />\n          &#x3C;/a>\n        )}\n      &#x3C;/div>\n    &#x3C;/div>\n  );\n}\n</code></pre>\n<p>El maquetado adicional de arriba, combinado con el CSS que hemos importado antes, produce la siguiente UI:</p>\n<video autoPlay muted playsInline loop>\n  <source\n    src="/finished-task-states.mp4"\n    type="video/mp4"\n  />\n</video>\n<h2>Especificar los requerimientos de datos</h2>\n<p>Es una buena práctica en React utilizar <code>propTypes</code> para especificar la forma de los datos que espera recibir un componente. No sólo se auto documenta, sino que también ayuda a detectar problemas rápidamente.</p>\n<pre><code class="language-javascript">import React from \'react\';\nimport PropTypes from \'prop-types\';\n\nfunction Task() {\n  ...\n}\n\nTask.propTypes = {\n  task: PropTypes.shape({\n    id: PropTypes.string.isRequired,\n    title: PropTypes.string.isRequired,\n    state: PropTypes.string.isRequired,\n  }),\n  onArchiveTask: PropTypes.func,\n  onPinTask: PropTypes.func,\n};\n\nexport default Task;\n</code></pre>\n<p>Ahora aparecerá una advertencia en modo desarrollo si el componente Task  se utiliza incorrectamente.</p>\n<div class="aside">\nUna forma alternativa de lograr el mismo propósito es utilizando un sistema de tipos de JavaScript como TypeScript, para crear un tipo para las propiedades del componente.\n</div>\n<h2>Componente construido!</h2>\n<p>Ahora hemos construido con éxito un componente sin necesidad de un servidor o sin ejecutar toda la aplicación frontend. El siguiente paso es construir los componentes restantes de la Taskbox, uno por uno de manera similar.</p>\n<p>Como puedes ver, comenzar a construir componentes de forma aislada es fácil y rápido. Podemos esperar producir una UI de mayor calidad con menos errores y más pulida porque es posible profundizar y probar todos los estados posibles.</p>\n<h2>Pruebas automatizadas</h2>\n<p>Storybook nos dio una excelente manera de probar visualmente nuestra aplicación durante su construcción. Las \'historias\' ayudarán a asegurar que no rompamos nuestra Task visualmente, a medida que continuamos desarrollando la aplicación. Sin embargo, en esta etapa, es un proceso completamente manual y alguien tiene que hacer el esfuerzo de hacer clic en cada estado de prueba y asegurarse de que se visualice bien y sin errores ni advertencias. ¿No podemos hacer eso automáticamente?</p>\n<h3>Pruebas de instantáneas</h3>\n<p>La prueba de instantáneas se refiere a la práctica de registrar la salida "correcta" de un componente para una entrada dada y luego en el futuro marcar el componente siempre que la salida cambie. Esto complementa a Storybook, porque es una manera rápida de ver la nueva versión de un componente y verificar los cambios.</p>\n<p>Con <a href="https://github.com/storybooks/storybook/tree/master/addons/storyshots">Storyshots addon</a> se crea una prueba de instantánea para cada una de las historias. Usalo agregando una dependencia en modo desarrollo en el paquete:</p>\n<pre><code class="language-bash">yarn add --dev @storybook/addon-storyshots react-test-renderer\n</code></pre>\n<p>Luego crea un archivo <code>src/storybook.test.js</code> con el siguiente contenido:</p>\n<pre><code class="language-javascript">import initStoryshots from \'@storybook/addon-storyshots\';\ninitStoryshots();\n</code></pre>\n<p>Una vez hecho lo anterior, podemos ejecutar <code>yarn test</code> y veremos el siguiente resultado:</p>\n<p><img src="/task-testrunner.png" alt="Task test runner"></p>\n<p>Ahora tenemos una prueba de instantánea para cada una de las historias de <code>Task</code>. Si cambiamos la implementación de <code>Task</code>, se nos pedirá que verifiquemos los cambios.</p>',frontmatter:{title:"Construye un componente simple",description:"Construye un componente simple en aislamiento",commit:"b3488c2"},fields:{slug:"/docs/es/simple-component/",chapter:"simple-component",framework:"docs",language:"es"}},site:{siteMetadata:{title:"binstd-区块链云服务平台",toc:["get-started","simple-component","composite-component","data","screen","test","deploy","conclusion","contribute"],languages:["en","zh"],githubUrl:"https://github.com/hichroma/learnstorybook.com",codeGithubUrl:"https://github.com/hichroma/learnstorybook-code",siteUrl:"https://binstd.com"}},pages:{edges:[{node:{frontmatter:{tocTitle:"Componente Compuesto",title:"Ensamblar un componente compuesto",description:"Ensamblar un componente compuesto a partir de componentes simples"},fields:{slug:"/docs/es/composite-component/",chapter:"composite-component"}}},{node:{frontmatter:{tocTitle:null,title:"Conclusion",description:"Pon todo tu conocimiento junto y aprende más técnicas de Storybook"},fields:{slug:"/docs/es/conclusion/",chapter:"conclusion"}}},{node:{frontmatter:{tocTitle:null,title:"Contribuir",description:"Ayuda a compartir Storybook con el mundo"},fields:{slug:"/docs/es/contribute/",chapter:"contribute"}}},{node:{frontmatter:{tocTitle:"Datos",title:"Introducir datos",description:"Aprende como introducir datos a tus componentes UI"},fields:{slug:"/docs/es/data/",chapter:"data"}}},{node:{frontmatter:{tocTitle:"Desplegar",title:"Desplegar Storybook",description:"Desplegar Storybook online con GitHub y Netlify"},fields:{slug:"/docs/es/deploy/",chapter:"deploy"}}},{node:{frontmatter:{tocTitle:"Empezando",title:"Empezando",description:"Configurar React Storybook en tu entorno de desarrollo"},fields:{slug:"/docs/es/get-started/",chapter:"get-started"}}},{node:{frontmatter:{tocTitle:"Pantallas",title:"Construir una pantalla",description:"Construir una pantalla con componentes"},fields:{slug:"/docs/es/screen/",chapter:"screen"}}},{node:{frontmatter:{tocTitle:"Componente Simple",title:"Construye un componente simple",description:"Construye un componente simple en aislamiento"},fields:{slug:"/docs/es/simple-component/",chapter:"simple-component"}}},{node:{frontmatter:{tocTitle:null,title:"Testing",description:"Aprende las formas de hacer test a los componentes de la UI"},fields:{slug:"/docs/es/test/",chapter:"test"}}}]}},pathContext:{slug:"/docs/es/simple-component/",framework:"docs",language:"es",chapter:"simple-component"}}}});
//# sourceMappingURL=path---docs-es-simple-component-a633015926d480a31560.js.map