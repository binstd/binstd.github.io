{"version":3,"sources":["webpack:///path---docs-en-data-f0c87abb5a00e119227a.js","webpack:///./.cache/json/docs-en-data.json"],"names":["webpackJsonp","860","module","exports","data","currentPage","html","frontmatter","title","description","commit","fields","slug","chapter","framework","language","site","siteMetadata","toc","languages","githubUrl","codeGithubUrl","siteUrl","pages","edges","node","tocTitle","pathContext"],"mappings":"AAAAA,cAAc,iBAERC,IACA,SAAUC,EAAQC,GCHxBD,EAAAC,SAAkBC,MAAQC,aAAeC,KAAA,s/MAA4+MC,aAAgCC,MAAA,eAAAC,YAAA,iDAAAC,OAAA,WAAyGC,QAAWC,KAAA,iBAAAC,QAAA,OAAAC,UAAA,OAAAC,SAAA,OAA6EC,MAASC,cAAgBT,MAAA,kBAAAU,KAAA,kHAAAC,WAAA,WAAAC,UAAA,iDAAAC,cAAA,kDAAAC,QAAA,uBAA0UC,OAAUC,QAAUC,MAAQlB,aAAemB,SAAA,sBAAAlB,MAAA,iCAAAC,YAAA,4DAAmJE,QAAWC,KAAA,gCAAAC,QAAA,0BAA2EY,MAAQlB,aAAemB,SAAA,KAAAlB,MAAA,aAAAC,YAAA,uEAAyHE,QAAWC,KAAA,uBAAAC,QAAA,iBAAyDY,MAAQlB,aAAemB,SAAA,KAAAlB,MAAA,aAAAC,YAAA,uCAAyFE,QAAWC,KAAA,uBAAAC,QAAA,iBAAyDY,MAAQlB,aAAemB,SAAA,OAAAlB,MAAA,eAAAC,YAAA,kDAAwGE,QAAWC,KAAA,iBAAAC,QAAA,WAA6CY,MAAQlB,aAAemB,SAAA,SAAAlB,MAAA,mBAAAC,YAAA,mDAA+GE,QAAWC,KAAA,mBAAAC,QAAA,aAAiDY,MAAQlB,aAAemB,SAAA,cAAAlB,MAAA,cAAAC,YAAA,yDAAqHE,QAAWC,KAAA,wBAAAC,QAAA,kBAA2DY,MAAQlB,aAAemB,SAAA,UAAAlB,MAAA,qBAAAC,YAAA,wCAAuGE,QAAWC,KAAA,mBAAAC,QAAA,aAAiDY,MAAQlB,aAAemB,SAAA,mBAAAlB,MAAA,2BAAAC,YAAA,yCAAuHE,QAAWC,KAAA,6BAAAC,QAAA,uBAAqEY,MAAQlB,aAAemB,SAAA,KAAAlB,MAAA,UAAAC,YAAA,wCAAuFE,QAAWC,KAAA,iBAAAC,QAAA,aAA8Cc,aAAgBf,KAAA,iBAAAE,UAAA,OAAAC,SAAA,KAAAF,QAAA","file":"path---docs-en-data-f0c87abb5a00e119227a.js","sourcesContent":["webpackJsonp([38278536168888],{\n\n/***/ 860:\n/***/ (function(module, exports) {\n\n\tmodule.exports = {\"data\":{\"currentPage\":{\"html\":\"<h1>Wire in data</h1>\\n<p>So far we created isolated stateless components –great for Storybook, but ultimately not useful until we give them some data in our app.</p>\\n<p>This tutorial doesn’t focus on the particulars of building an app so we won’t dig into those details here. But we will take a moment to look at a common pattern for wiring in data with container components.</p>\\n<h2>Container components</h2>\\n<p>Our <code>TaskList</code> component as currently written is “presentational” (see <a href=\\\"https://medium.com/@dan_abramov/smart-and-dumb-components-7ca2f9a7c7d0\\\">this blog post</a>) in that it doesn’t talk to anything external to its own implementation. To get data into it, we need a “container”.</p>\\n<p>This example uses <a href=\\\"https://redux.js.org/\\\">Redux</a>, the most popular React library for storing data, to build a simple data model for our app. However, the pattern used here applies just as well to other data management libraries like <a href=\\\"https://www.apollographql.com/client/\\\">Apollo</a> and <a href=\\\"https://mobx.js.org/\\\">MobX</a>.</p>\\n<p>First we’ll construct a simple Redux store that responds to actions that change the state of tasks, in a file called <code>lib/redux.js</code> in the <code>src</code> folder (intentionally kept simple):</p>\\n<pre><code class=\\\"language-javascript\\\">// A simple redux store/actions/reducer implementation.\\n// A true app would be more complex and separated into different files.\\nimport { createStore } from 'redux';\\n\\n// The actions are the \\\"names\\\" of the changes that can happen to the store\\nexport const actions = {\\n  ARCHIVE_TASK: 'ARCHIVE_TASK',\\n  PIN_TASK: 'PIN_TASK',\\n};\\n\\n// The action creators are how you bundle actions with the data required to execute them\\nexport const archiveTask = id => ({ type: actions.ARCHIVE_TASK, id });\\nexport const pinTask = id => ({ type: actions.PIN_TASK, id });\\n\\n// All our reducers simply change the state of a single task.\\nfunction taskStateReducer(taskState) {\\n  return (state, action) => {\\n    return {\\n      ...state,\\n      tasks: state.tasks.map(\\n        task => (task.id === action.id ? { ...task, state: taskState } : task)\\n      ),\\n    };\\n  };\\n}\\n\\n// The reducer describes how the contents of the store change for each action\\nexport const reducer = (state, action) => {\\n  switch (action.type) {\\n    case actions.ARCHIVE_TASK:\\n      return taskStateReducer('TASK_ARCHIVED')(state, action);\\n    case actions.PIN_TASK:\\n      return taskStateReducer('TASK_PINNED')(state, action);\\n    default:\\n      return state;\\n  }\\n};\\n\\n// The initial state of our store when the app loads.\\n// Usually you would fetch this from a server\\nconst defaultTasks = [\\n  { id: '1', title: 'Something', state: 'TASK_INBOX' },\\n  { id: '2', title: 'Something more', state: 'TASK_INBOX' },\\n  { id: '3', title: 'Something else', state: 'TASK_INBOX' },\\n  { id: '4', title: 'Something again', state: 'TASK_INBOX' },\\n];\\n\\n// We export the constructed redux store\\nexport default createStore(reducer, { tasks: defaultTasks });\\n</code></pre>\\n<p>Then we’ll update the default export from the <code>TaskList</code> component to connect to the Redux store and render the tasks we are interested in:</p>\\n<pre><code class=\\\"language-javascript\\\">import React from 'react';\\nimport PropTypes from 'prop-types';\\n\\nimport Task from './Task';\\nimport { connect } from 'react-redux';\\nimport { archiveTask, pinTask } from '../lib/redux';\\n\\nexport function PureTaskList({ loading, tasks, onPinTask, onArchiveTask }) {\\n  /* previous implementation of TaskList */\\n}\\n\\nPureTaskList.propTypes = {\\n  loading: PropTypes.bool,\\n  tasks: PropTypes.arrayOf(Task.propTypes.task).isRequired,\\n  onPinTask: PropTypes.func.isRequired,\\n  onArchiveTask: PropTypes.func.isRequired,\\n};\\n\\nPureTaskList.defaultProps = {\\n  loading: false,\\n};\\n\\nexport default connect(\\n  ({ tasks }) => ({\\n    tasks: tasks.filter(t => t.state === 'TASK_INBOX' || t.state === 'TASK_PINNED'),\\n  }),\\n  dispatch => ({\\n    onArchiveTask: id => dispatch(archiveTask(id)),\\n    onPinTask: id => dispatch(pinTask(id)),\\n  })\\n)(PureTaskList);\\n</code></pre>\\n<p>At this stage our Storybook tests will have stopped working, as the <code>TaskList</code> is now a container, and no longer expects any props, instead it connects to the store and sets the props on the <code>PureTaskList</code> component it wraps.</p>\\n<p>However, we can easily solve this problem by simply rendering the <code>PureTaskList</code> --the presentational component-- in our Storybook stories:</p>\\n<pre><code class=\\\"language-javascript\\\">import React from 'react';\\nimport { storiesOf } from '@storybook/react';\\n\\nimport { PureTaskList } from './TaskList';\\nimport { task, actions } from './Task.stories';\\n\\nexport const defaultTasks = [\\n  { ...task, id: '1', title: 'Task 1' },\\n  { ...task, id: '2', title: 'Task 2' },\\n  { ...task, id: '3', title: 'Task 3' },\\n  { ...task, id: '4', title: 'Task 4' },\\n  { ...task, id: '5', title: 'Task 5' },\\n  { ...task, id: '6', title: 'Task 6' },\\n];\\n\\nexport const withPinnedTasks = [\\n  ...defaultTasks.slice(0, 5),\\n  { id: '6', title: 'Task 6 (pinned)', state: 'TASK_PINNED' },\\n];\\n\\nstoriesOf('TaskList', module)\\n  .addDecorator(story => &#x3C;div style={{ padding: '3rem' }}>{story()}&#x3C;/div>)\\n  .add('default', () => &#x3C;PureTaskList tasks={defaultTasks} {...actions} />)\\n  .add('withPinnedTasks', () => &#x3C;PureTaskList tasks={withPinnedTasks} {...actions} />)\\n  .add('loading', () => &#x3C;PureTaskList loading tasks={[]} {...actions} />)\\n  .add('empty', () => &#x3C;PureTaskList tasks={[]} {...actions} />);\\n</code></pre>\\n<video autoPlay muted playsInline loop>\\n  <source\\n    src=\\\"/finished-tasklist-states.mp4\\\"\\n    type=\\\"video/mp4\\\"\\n  />\\n</video>\\n<p>Similarly, we need to use <code>PureTaskList</code> in our Jest test:</p>\\n<pre><code class=\\\"language-js\\\">import React from 'react';\\nimport ReactDOM from 'react-dom';\\nimport { PureTaskList } from './TaskList';\\nimport { withPinnedTasks } from './TaskList.stories';\\n\\nit('renders pinned tasks at the start of the list', () => {\\n  const div = document.createElement('div');\\n  const events = { onPinTask: jest.fn(), onArchiveTask: jest.fn() };\\n  ReactDOM.render(&#x3C;PureTaskList tasks={withPinnedTasks} {...events} />, div);\\n\\n  // We expect the task titled \\\"Task 6 (pinned)\\\" to be rendered first, not at the end\\n  const lastTaskInput = div.querySelector('.list-item:nth-child(1) input[value=\\\"Task 6 (pinned)\\\"]');\\n  expect(lastTaskInput).not.toBe(null);\\n\\n  ReactDOM.unmountComponentAtNode(div);\\n});\\n</code></pre>\",\"frontmatter\":{\"title\":\"Wire in data\",\"description\":\"Learn how to wire in data to your UI component\",\"commit\":\"dd04879\"},\"fields\":{\"slug\":\"/docs/en/data/\",\"chapter\":\"data\",\"framework\":\"docs\",\"language\":\"en\"}},\"site\":{\"siteMetadata\":{\"title\":\"binstd-区块链云服务平台\",\"toc\":[\"get-started\",\"simple-component\",\"composite-component\",\"data\",\"screen\",\"test\",\"deploy\",\"conclusion\",\"contribute\"],\"languages\":[\"en\",\"zh\"],\"githubUrl\":\"https://github.com/hichroma/learnstorybook.com\",\"codeGithubUrl\":\"https://github.com/hichroma/learnstorybook-code\",\"siteUrl\":\"https://binstd.com\"}},\"pages\":{\"edges\":[{\"node\":{\"frontmatter\":{\"tocTitle\":\"Composite component\",\"title\":\"Assemble a composite component\",\"description\":\"Assemble a composite component out of simpler components\"},\"fields\":{\"slug\":\"/docs/en/composite-component/\",\"chapter\":\"composite-component\"}}},{\"node\":{\"frontmatter\":{\"tocTitle\":null,\"title\":\"Conclusion\",\"description\":\"Put all your knowledge together and learn more Storybook techniques\"},\"fields\":{\"slug\":\"/docs/en/conclusion/\",\"chapter\":\"conclusion\"}}},{\"node\":{\"frontmatter\":{\"tocTitle\":null,\"title\":\"Contribute\",\"description\":\"Help share Storybook with the world\"},\"fields\":{\"slug\":\"/docs/en/contribute/\",\"chapter\":\"contribute\"}}},{\"node\":{\"frontmatter\":{\"tocTitle\":\"Data\",\"title\":\"Wire in data\",\"description\":\"Learn how to wire in data to your UI component\"},\"fields\":{\"slug\":\"/docs/en/data/\",\"chapter\":\"data\"}}},{\"node\":{\"frontmatter\":{\"tocTitle\":\"Deploy\",\"title\":\"Deploy Storybook\",\"description\":\"Deploy Storybook online with GitHub and Netlify\"},\"fields\":{\"slug\":\"/docs/en/deploy/\",\"chapter\":\"deploy\"}}},{\"node\":{\"frontmatter\":{\"tocTitle\":\"Get started\",\"title\":\"Get started\",\"description\":\"Setup React Storybook in your development environment\"},\"fields\":{\"slug\":\"/docs/en/get-started/\",\"chapter\":\"get-started\"}}},{\"node\":{\"frontmatter\":{\"tocTitle\":\"Screens\",\"title\":\"Construct a screen\",\"description\":\"Construct a screen out of components\"},\"fields\":{\"slug\":\"/docs/en/screen/\",\"chapter\":\"screen\"}}},{\"node\":{\"frontmatter\":{\"tocTitle\":\"Simple component\",\"title\":\"Build a simple component\",\"description\":\"Build a simple component in isolation\"},\"fields\":{\"slug\":\"/docs/en/simple-component/\",\"chapter\":\"simple-component\"}}},{\"node\":{\"frontmatter\":{\"tocTitle\":null,\"title\":\"Testing\",\"description\":\"Learn the ways to test UI components\"},\"fields\":{\"slug\":\"/docs/en/test/\",\"chapter\":\"test\"}}}]}},\"pathContext\":{\"slug\":\"/docs/en/data/\",\"framework\":\"docs\",\"language\":\"en\",\"chapter\":\"data\"}}\n\n/***/ })\n\n});\n\n\n// WEBPACK FOOTER //\n// path---docs-en-data-f0c87abb5a00e119227a.js","module.exports = {\"data\":{\"currentPage\":{\"html\":\"<h1>Wire in data</h1>\\n<p>So far we created isolated stateless components –great for Storybook, but ultimately not useful until we give them some data in our app.</p>\\n<p>This tutorial doesn’t focus on the particulars of building an app so we won’t dig into those details here. But we will take a moment to look at a common pattern for wiring in data with container components.</p>\\n<h2>Container components</h2>\\n<p>Our <code>TaskList</code> component as currently written is “presentational” (see <a href=\\\"https://medium.com/@dan_abramov/smart-and-dumb-components-7ca2f9a7c7d0\\\">this blog post</a>) in that it doesn’t talk to anything external to its own implementation. To get data into it, we need a “container”.</p>\\n<p>This example uses <a href=\\\"https://redux.js.org/\\\">Redux</a>, the most popular React library for storing data, to build a simple data model for our app. However, the pattern used here applies just as well to other data management libraries like <a href=\\\"https://www.apollographql.com/client/\\\">Apollo</a> and <a href=\\\"https://mobx.js.org/\\\">MobX</a>.</p>\\n<p>First we’ll construct a simple Redux store that responds to actions that change the state of tasks, in a file called <code>lib/redux.js</code> in the <code>src</code> folder (intentionally kept simple):</p>\\n<pre><code class=\\\"language-javascript\\\">// A simple redux store/actions/reducer implementation.\\n// A true app would be more complex and separated into different files.\\nimport { createStore } from 'redux';\\n\\n// The actions are the \\\"names\\\" of the changes that can happen to the store\\nexport const actions = {\\n  ARCHIVE_TASK: 'ARCHIVE_TASK',\\n  PIN_TASK: 'PIN_TASK',\\n};\\n\\n// The action creators are how you bundle actions with the data required to execute them\\nexport const archiveTask = id => ({ type: actions.ARCHIVE_TASK, id });\\nexport const pinTask = id => ({ type: actions.PIN_TASK, id });\\n\\n// All our reducers simply change the state of a single task.\\nfunction taskStateReducer(taskState) {\\n  return (state, action) => {\\n    return {\\n      ...state,\\n      tasks: state.tasks.map(\\n        task => (task.id === action.id ? { ...task, state: taskState } : task)\\n      ),\\n    };\\n  };\\n}\\n\\n// The reducer describes how the contents of the store change for each action\\nexport const reducer = (state, action) => {\\n  switch (action.type) {\\n    case actions.ARCHIVE_TASK:\\n      return taskStateReducer('TASK_ARCHIVED')(state, action);\\n    case actions.PIN_TASK:\\n      return taskStateReducer('TASK_PINNED')(state, action);\\n    default:\\n      return state;\\n  }\\n};\\n\\n// The initial state of our store when the app loads.\\n// Usually you would fetch this from a server\\nconst defaultTasks = [\\n  { id: '1', title: 'Something', state: 'TASK_INBOX' },\\n  { id: '2', title: 'Something more', state: 'TASK_INBOX' },\\n  { id: '3', title: 'Something else', state: 'TASK_INBOX' },\\n  { id: '4', title: 'Something again', state: 'TASK_INBOX' },\\n];\\n\\n// We export the constructed redux store\\nexport default createStore(reducer, { tasks: defaultTasks });\\n</code></pre>\\n<p>Then we’ll update the default export from the <code>TaskList</code> component to connect to the Redux store and render the tasks we are interested in:</p>\\n<pre><code class=\\\"language-javascript\\\">import React from 'react';\\nimport PropTypes from 'prop-types';\\n\\nimport Task from './Task';\\nimport { connect } from 'react-redux';\\nimport { archiveTask, pinTask } from '../lib/redux';\\n\\nexport function PureTaskList({ loading, tasks, onPinTask, onArchiveTask }) {\\n  /* previous implementation of TaskList */\\n}\\n\\nPureTaskList.propTypes = {\\n  loading: PropTypes.bool,\\n  tasks: PropTypes.arrayOf(Task.propTypes.task).isRequired,\\n  onPinTask: PropTypes.func.isRequired,\\n  onArchiveTask: PropTypes.func.isRequired,\\n};\\n\\nPureTaskList.defaultProps = {\\n  loading: false,\\n};\\n\\nexport default connect(\\n  ({ tasks }) => ({\\n    tasks: tasks.filter(t => t.state === 'TASK_INBOX' || t.state === 'TASK_PINNED'),\\n  }),\\n  dispatch => ({\\n    onArchiveTask: id => dispatch(archiveTask(id)),\\n    onPinTask: id => dispatch(pinTask(id)),\\n  })\\n)(PureTaskList);\\n</code></pre>\\n<p>At this stage our Storybook tests will have stopped working, as the <code>TaskList</code> is now a container, and no longer expects any props, instead it connects to the store and sets the props on the <code>PureTaskList</code> component it wraps.</p>\\n<p>However, we can easily solve this problem by simply rendering the <code>PureTaskList</code> --the presentational component-- in our Storybook stories:</p>\\n<pre><code class=\\\"language-javascript\\\">import React from 'react';\\nimport { storiesOf } from '@storybook/react';\\n\\nimport { PureTaskList } from './TaskList';\\nimport { task, actions } from './Task.stories';\\n\\nexport const defaultTasks = [\\n  { ...task, id: '1', title: 'Task 1' },\\n  { ...task, id: '2', title: 'Task 2' },\\n  { ...task, id: '3', title: 'Task 3' },\\n  { ...task, id: '4', title: 'Task 4' },\\n  { ...task, id: '5', title: 'Task 5' },\\n  { ...task, id: '6', title: 'Task 6' },\\n];\\n\\nexport const withPinnedTasks = [\\n  ...defaultTasks.slice(0, 5),\\n  { id: '6', title: 'Task 6 (pinned)', state: 'TASK_PINNED' },\\n];\\n\\nstoriesOf('TaskList', module)\\n  .addDecorator(story => &#x3C;div style={{ padding: '3rem' }}>{story()}&#x3C;/div>)\\n  .add('default', () => &#x3C;PureTaskList tasks={defaultTasks} {...actions} />)\\n  .add('withPinnedTasks', () => &#x3C;PureTaskList tasks={withPinnedTasks} {...actions} />)\\n  .add('loading', () => &#x3C;PureTaskList loading tasks={[]} {...actions} />)\\n  .add('empty', () => &#x3C;PureTaskList tasks={[]} {...actions} />);\\n</code></pre>\\n<video autoPlay muted playsInline loop>\\n  <source\\n    src=\\\"/finished-tasklist-states.mp4\\\"\\n    type=\\\"video/mp4\\\"\\n  />\\n</video>\\n<p>Similarly, we need to use <code>PureTaskList</code> in our Jest test:</p>\\n<pre><code class=\\\"language-js\\\">import React from 'react';\\nimport ReactDOM from 'react-dom';\\nimport { PureTaskList } from './TaskList';\\nimport { withPinnedTasks } from './TaskList.stories';\\n\\nit('renders pinned tasks at the start of the list', () => {\\n  const div = document.createElement('div');\\n  const events = { onPinTask: jest.fn(), onArchiveTask: jest.fn() };\\n  ReactDOM.render(&#x3C;PureTaskList tasks={withPinnedTasks} {...events} />, div);\\n\\n  // We expect the task titled \\\"Task 6 (pinned)\\\" to be rendered first, not at the end\\n  const lastTaskInput = div.querySelector('.list-item:nth-child(1) input[value=\\\"Task 6 (pinned)\\\"]');\\n  expect(lastTaskInput).not.toBe(null);\\n\\n  ReactDOM.unmountComponentAtNode(div);\\n});\\n</code></pre>\",\"frontmatter\":{\"title\":\"Wire in data\",\"description\":\"Learn how to wire in data to your UI component\",\"commit\":\"dd04879\"},\"fields\":{\"slug\":\"/docs/en/data/\",\"chapter\":\"data\",\"framework\":\"docs\",\"language\":\"en\"}},\"site\":{\"siteMetadata\":{\"title\":\"binstd-区块链云服务平台\",\"toc\":[\"get-started\",\"simple-component\",\"composite-component\",\"data\",\"screen\",\"test\",\"deploy\",\"conclusion\",\"contribute\"],\"languages\":[\"en\",\"zh\"],\"githubUrl\":\"https://github.com/hichroma/learnstorybook.com\",\"codeGithubUrl\":\"https://github.com/hichroma/learnstorybook-code\",\"siteUrl\":\"https://binstd.com\"}},\"pages\":{\"edges\":[{\"node\":{\"frontmatter\":{\"tocTitle\":\"Composite component\",\"title\":\"Assemble a composite component\",\"description\":\"Assemble a composite component out of simpler components\"},\"fields\":{\"slug\":\"/docs/en/composite-component/\",\"chapter\":\"composite-component\"}}},{\"node\":{\"frontmatter\":{\"tocTitle\":null,\"title\":\"Conclusion\",\"description\":\"Put all your knowledge together and learn more Storybook techniques\"},\"fields\":{\"slug\":\"/docs/en/conclusion/\",\"chapter\":\"conclusion\"}}},{\"node\":{\"frontmatter\":{\"tocTitle\":null,\"title\":\"Contribute\",\"description\":\"Help share Storybook with the world\"},\"fields\":{\"slug\":\"/docs/en/contribute/\",\"chapter\":\"contribute\"}}},{\"node\":{\"frontmatter\":{\"tocTitle\":\"Data\",\"title\":\"Wire in data\",\"description\":\"Learn how to wire in data to your UI component\"},\"fields\":{\"slug\":\"/docs/en/data/\",\"chapter\":\"data\"}}},{\"node\":{\"frontmatter\":{\"tocTitle\":\"Deploy\",\"title\":\"Deploy Storybook\",\"description\":\"Deploy Storybook online with GitHub and Netlify\"},\"fields\":{\"slug\":\"/docs/en/deploy/\",\"chapter\":\"deploy\"}}},{\"node\":{\"frontmatter\":{\"tocTitle\":\"Get started\",\"title\":\"Get started\",\"description\":\"Setup React Storybook in your development environment\"},\"fields\":{\"slug\":\"/docs/en/get-started/\",\"chapter\":\"get-started\"}}},{\"node\":{\"frontmatter\":{\"tocTitle\":\"Screens\",\"title\":\"Construct a screen\",\"description\":\"Construct a screen out of components\"},\"fields\":{\"slug\":\"/docs/en/screen/\",\"chapter\":\"screen\"}}},{\"node\":{\"frontmatter\":{\"tocTitle\":\"Simple component\",\"title\":\"Build a simple component\",\"description\":\"Build a simple component in isolation\"},\"fields\":{\"slug\":\"/docs/en/simple-component/\",\"chapter\":\"simple-component\"}}},{\"node\":{\"frontmatter\":{\"tocTitle\":null,\"title\":\"Testing\",\"description\":\"Learn the ways to test UI components\"},\"fields\":{\"slug\":\"/docs/en/test/\",\"chapter\":\"test\"}}}]}},\"pathContext\":{\"slug\":\"/docs/en/data/\",\"framework\":\"docs\",\"language\":\"en\",\"chapter\":\"data\"}}\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/json-loader!./.cache/json/docs-en-data.json\n// module id = 860\n// module chunks = 38278536168888"],"sourceRoot":""}