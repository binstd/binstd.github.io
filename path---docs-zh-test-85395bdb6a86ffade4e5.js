webpackJsonp([78201966420524],{883:function(o,t){o.exports={data:{currentPage:{html:'<h1>测试UI组件</h1>\n<p>Storybook教程没有测试是不完整的. 测试对于创建高质量的UI至关重要. 在模块化系统中,微小的调整可能导致重大的回溯. 到目前为止,我们遇到了三种类型的测试</p>\n<ul>\n<li><strong>视觉测试</strong> 依赖开发人员手动查看组件以验证其正确性. 它们帮助我们在构建时检查组件的外观. </li>\n<li><strong>快照测试</strong> 使用Storyshots捕获组件的渲染标记. 它们可以帮助我们及时了解导致 渲染错误和警告的标记更改. </li>\n<li><strong>单元测试</strong> 使用Jest验证 在给定固定输入的情况下 组件的输出保持不变. 它们非常适合测试组件的功能质量. </li>\n</ul>\n<h2>"但看起来不错吗?"</h2>\n<p>不幸的是,单独的上述测试方法不足以防止UI错误. 用户界面很难测试,因为设计是主观的,细致入微的. 可视化测试 过于手动,快照测试在用于UI时 会触发太多误报,而 像素级单元测试的价值很低. 完整的 Storybook测试策略 还包括视觉回溯测试. </p>\n<h2>Storybook的视觉回溯测试</h2>\n<p>视觉回溯测试旨在捕捉外观的变化. 他们通过捕获每个故事的屏幕截图,并将它们提交到 表面更改 进行比较工作. 这非常适合验证布局,颜色,大小和对比度等图形元素. </p>\n<video autoPlay muted playsInline loop style="width:480px; margin: 0 auto;">\n  <source\n    src="/visual-regression-testing.mp4"\n    type="video/mp4"\n  />\n</video>\n<p> Storybook 是视觉回溯测试的绝佳工具,因为每个故事本质上都是一个测试规范. 每次我们编写或更新故事时,我们都会免费获得规格!</p>\n<p>有许多用于视觉回溯测试的工具. 对于专业团队,我们建议<a href="https://www.chromaticqa.com/"><strong>Chromatic</strong></a>,由 Storybook维护者制作的插件,在云中运行测试. </p>\n<h2>设置视觉回溯测试</h2>\n<p>Chromatic 是一个无障碍的 Storybook插件,用于在云中进行视觉回溯测试和审查. 由于它是付费服务 (免费试用) ,因此可能并非适合所有人. 但是,Chromatic 是生产视觉测试工作流程的一个有益的例子,我们将免费试用. 我们来看一下. </p>\n<h3>初始化Git</h3>\n<p>首先,您要在本地目录中为项目设置Git. Chromatic 使用 Git历史记录 来跟踪您的UI组件. </p>\n<pre><code class="language-bash">$ git init\n</code></pre>\n<p>接下来将文件添加到第一次提交. </p>\n<pre><code class="language-bash">$ git add .\n</code></pre>\n<p>现在提交文件. </p>\n<pre><code class="language-bash">$ git commit -m "taskbox UI"\n</code></pre>\n<h3>获得 Chromatic</h3>\n<p>将包添加为依赖项. </p>\n<pre><code class="language-bash">yarn add storybook-chromatic\n</code></pre>\n<p>导入Chromatic 到你的<code>.storybook/config.js</code>文件. </p>\n<pre><code class="language-javascript">import { configure } from \'@storybook/react\';\nimport \'storybook-chromatic/storybook-addon\';\n\nimport \'../src/index.css\';\n\nconst req = require.context(\'../src/components\', true, /\\.stories\\.js$/);\n\nfunction loadStories() {\n  req.keys().forEach(filename => req(filename));\n}\n\nconfigure(loadStories, module);\n</code></pre>\n<p>然后<a href="https://chromaticqa.com/start">登录Chromatic</a>使用您的GitHub帐户 (Chromatic仅要求轻量级权限) . 创建名为"taskbox"的项目并复制您的唯一项目<code>app-code</code>. </p>\n<video autoPlay muted playsInline loop style="width:520px; margin: 0 auto;">\n  <source\n    src="/chromatic-setup-learnstorybook.mp4"\n    type="video/mp4"\n  />\n</video>\n<p>在命令行中运行 test命令 以设置Storybook的可视化回溯测试. 不要忘记添加您的 唯一应用代码 来代替<code>&#x3C;app-code></code>. </p>\n<pre><code class="language-bash">./node_modules/.bin/chromatic test --storybook-addon --app-code=&#x3C;app-code> --do-not-start\n</code></pre>\n<div class="aside">\n<code>--do-not-start</code> 是一个选项，告诉 Chromatic 不要启动故事书。 如果您已经运行了故事书，请使用此选项。 如果没有会省略 <code>--do-not-start</code>.\n</div>\n<p>第一次测试完成后, 我们会为每个故事提供测试基准. 换句话说,每个故事的屏幕截图都被称为"good". 这些故事的未来变化 将与 基线进行比较. </p>\n<p><img src="/chromatic-baselines.png" alt="Chromatic baselines"></p>\n<h2>捕获UI更改</h2>\n<p>视觉回溯测试 依赖于将 新呈现的UI代码的图像 与 基线图像 进行比较. 如果捕获到UI更改,则会收到通知. 通过调整背景 来了解它是如何工作的<code>Task</code>组件: </p>\n<p><img src="/chromatic-change-to-task-component.png" alt="code change"></p>\n<p>这会为项目生成新的背景颜色. </p>\n<p><img src="/chromatic-task-change.png" alt="task background change"></p>\n<p>使用之前的test命令运行另一个Chromatic测试. </p>\n<pre><code class="language-bash">./node_modules/.bin/chromatic test --storybook-addon --app-code=&#x3C;app-code> --do-not-start\n</code></pre>\n<p>点击您将看到 更改的网络用户界面 链接. </p>\n<p><img src="/chromatic-catch-changes.png" alt="UI changes in Chromatic"></p>\n<p>有很多变化! 组件层次结构表明 <code>Task</code>是<code>TaskList</code>的孩子和<code>Inbox</code>意味着一个小小的调整滚雪球成为主要的回溯. 这种情况正是开发人员除了其他测试方法之外,还需要视觉回溯测试的原因. </p>\n<p><img src="/minor-major-regressions.gif" alt="UI minor tweaks major regressions"></p>\n<h2>查看更改</h2>\n<p>视觉回溯测试确保组件不会意外更改. 但是,您仍然需要确定更改是否是有意的. </p>\n<p>如果有意更改,则需要更新基线,以便将来的测试与故事的最新版本进行比较. 如果改变是无意的,则需要修复. </p>\n<video autoPlay muted playsInline loop style="width:480px; margin: 0 auto;">\n  <source\n    src="/website-workflow-review-merge-optimized.mp4"\n    type="video/mp4"\n  />\n</video>\n<p>由于现代应用程序是 由组件构建的,因此我们在组件级别 进行测试非常重要. 这样做有助于我们找出变化的根本原因,即组件,而不是对 变化的症状,页面 和 复合组件 做出反应. </p>\n<h2>合并更改</h2>\n<p>当我们完成审核后,我们已准备好自信地合并 UI更改 - 知道更新不会意外地引入错误. 如果你喜欢新的<code>papayawhip</code>背景色,然后接受更改,如果不需要恢复到以前的状态. </p>\n<p><img src="/chromatic-review-finished.png" alt="Changes ready to be merged"></p>\n<p> Storybook可以帮助你 <strong>建立</strong> 组件;测试可以帮助你 <strong>保持</strong> 他们. 本教程介绍了四种类型的UI测试,包括 可视化,快照,单元和可视化回溯测试. 您可以通过将它们添加到 CI脚本 来自动执行最后三个. 这有助于您运输组件 而不必担心 偷渡漏洞. 整个工作流程如下所示. </p>\n<p><img src="/cdd-review-workflow.png" alt="Visual regression testing workflow"></p>',frontmatter:{title:"测试",description:"了解测试UI组件的方法",commit:"342bce5"},fields:{slug:"/docs/zh/test/",chapter:"test",framework:"docs",language:"zh"}},site:{siteMetadata:{title:"binstd-区块链云服务平台",toc:["get-started","simple-component","composite-component","data","screen","test","deploy","conclusion","contribute"],languages:["en","zh"],githubUrl:"https://github.com/hichroma/learnstorybook.com",codeGithubUrl:"https://github.com/hichroma/learnstorybook-code",siteUrl:"https://binstd.com"}},pages:{edges:[{node:{frontmatter:{tocTitle:"合成组件",title:"组装复合组件",description:"使用更简单的组件 组装复合组件"},fields:{slug:"/docs/zh/composite-component/",chapter:"composite-component"}}},{node:{frontmatter:{tocTitle:null,title:"总结",description:"把所有的知识汇总以下，学习更多的 storybook 技巧"},fields:{slug:"/docs/zh/conclusion/",chapter:"conclusion"}}},{node:{frontmatter:{tocTitle:null,title:"帮助我们",description:"帮助 我们与世界分享 Storybook "},fields:{slug:"/docs/zh/contribute/",chapter:"contribute"}}},{node:{frontmatter:{tocTitle:"Data",title:"接连data",description:"了解如何将数据连接到UI组件"},fields:{slug:"/docs/zh/data/",chapter:"data"}}},{node:{frontmatter:{tocTitle:"发布",title:"发布 Storybook",description:"使用 GitHub 和 Netlify 发布 Storybook网站 "},fields:{slug:"/docs/zh/deploy/",chapter:"deploy"}}},{node:{frontmatter:{tocTitle:"从头开始",title:"开始吧",description:"在你的开发环境下, 设置 React Storybook "},fields:{slug:"/docs/zh/get-started/",chapter:"get-started"}}},{node:{frontmatter:{tocTitle:"页面",title:"构建一个页面",description:"用组件构建一个页面"},fields:{slug:"/docs/zh/screen/",chapter:"screen"}}},{node:{frontmatter:{tocTitle:"简单 组件",title:"构建一个简单的组件",description:"单独构建一个简单的组件"},fields:{slug:"/docs/zh/simple-component/",chapter:"simple-component"}}},{node:{frontmatter:{tocTitle:null,title:"测试",description:"了解测试UI组件的方法"},fields:{slug:"/docs/zh/test/",chapter:"test"}}}]}},pathContext:{slug:"/docs/zh/test/",framework:"docs",language:"zh",chapter:"test"}}}});
//# sourceMappingURL=path---docs-zh-test-85395bdb6a86ffade4e5.js.map