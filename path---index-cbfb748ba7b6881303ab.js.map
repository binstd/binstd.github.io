{"version":3,"sources":["webpack:///path---index-cbfb748ba7b6881303ab.js","webpack:///./.cache/json/index.json"],"names":["webpackJsonp","886","module","exports","data","allMarkdownRemark","edges","node","id","html","excerpt","frontmatter","path","title","pathContext"],"mappings":"AAAAA,cAAc,iBAERC,IACA,SAAUC,EAAQC,GCHxBD,EAAAC,SAAkBC,MAAQC,mBAAqBC,QAAUC,MAAQC,GAAA,0FAAAC,KAAA,ygBAAkLC,QAAA,kNAAkhBC,aAAwJC,KAAA,QAAAC,MAAA,WAAkCN,MAAQC,GAAA,kGAAAC,KAAA,+vJAAw9EC,QAAA,IAAAC,aAA87EC,KAAA,SAAAC,MAAA,iBAAyCN,MAAQC,GAAA,kGAAAC,KAAA,+vJAAw9EC,QAAA,IAAAC,aAA87EC,KAAA,SAAAC,MAAA,iBAAyCN,MAAQC,GAAA,kGAAAC,KAAA,+vJAAw9EC,QAAA,IAAAC,aAA87EC,KAAA,SAAAC,MAAA,iBAAyCN,MAAQC,GAAA,kGAAAC,KAAA,+vJAAw9EC,QAAA,IAAAC,aAA87EC,KAAA,SAAAC,MAAA,iBAAyCN,MAAQC,GAAA,gGAAAC,KAAA,+vJAAs9EC,QAAA,IAAAC,aAA87EC,KAAA,OAAAC,MAAA,iBAAuCN,MAAQC,GAAA,iHAAAC,KAAA;AAA05TC,QAAA,0PAA6yBC,aAA+LC,KAAA,KAAAC,MAAA,qCAAyDN,MAAQC,GAAA,wGAAAC,KAAA,ujEAAqoEC,QAAA,0PAAAC,aAA2UC,KAAA,QAAAC,MAAA,iBAAwCN,MAAQC,GAAA,wGAAAC,KAAA,68BAAAC,QAAA,0PAAAC,aAAg2CC,KAAA,QAAAC,MAAA,iBAAwCN,MAAQC,GAAA,kGAAAC,KAAA,s/MAAmlNC,QAAA,8PAAAC,aAAwSC,KAAA,KAAAC,MAAA,mBAAuCN,MAAQC,GAAA,oGAAAC,KAAA,ujIAAiyEC,QAAA,6PAAAC,aAA4sEC,KAAA,KAAAC,MAAA,uBAA2CN,MAAQC,GAAA,yGAAAC,KAAA,g8FAA8UC,QAAA,6PAA+9FC,aAAgEC,KAAA,KAAAC,MAAA,kBAAsCN,MAAQC,GAAA,oGAAAC,KAAA,qhPAAs/NC,QAAA,yPAAmuBC,aAA8LC,KAAA,KAAAC,MAAA,yBAA6CN,MAAQC,GAAA,8GAAAC,KAAA;AAAy7VC,QAAA,qPAAAC,aAAinBC,KAAA,KAAAC,MAAA,+BAAmDN,MAAQC,GAAA,kGAAAC,KAAA,6gPAAgwOC,QAAA,2PAAAC,aAA2sBC,KAAA,KAAAC,MAAA,cAAkCN,MAAQC,GAAA,iHAAAC,KAAA,m0XAA2nWC,QAAA,0PAA86BC,aAA0KC,KAAA,KAAAC,MAAA,wCAA4DN,MAAQC,GAAA,wGAAAC,KAAA,uuEAAmzEC,QAAA,6PAAAC,aAA8UC,KAAA,KAAAC,MAAA,iBAAqCN,MAAQC,GAAA,wGAAAC,KAAA,khCAAAC,QAAA,uPAAAC,aAAk6CC,KAAA,KAAAC,MAAA,iBAAqCN,MAAQC,GAAA,kGAAAC,KAAA,iwMAAutMC,QAAA,0PAAAC,aAA2aC,KAAA,KAAAC,MAAA,uBAA2CN,MAAQC,GAAA;AAAAC,KAAA,06IAA87EC,QAAA,2PAAAC,aAAo6EC,KAAA,KAAAC,MAAA,0BAA8CN,MAAQC,GAAA,yGAAAC,KAAA,8iGAAuVC,QAAA,2PAAykGC,aAAqDC,KAAA,KAAAC,MAAA,gBAAoCN,MAAQC,GAAA,oGAAAC,KAAA,mmQAA88OC,QAAA,sPAA43BC,aAAkKC,KAAA,KAAAC,MAAA,6BAAiDN,MAAQC,GAAA,8GAAAC,KAAA,gmYAAk2XC,QAAA,6PAAAC,aAA8pBC,KAAA,KAAAC,MAAA,qCAAyDN,MAAQC,GAAA,kGAAAC,KAAA;AAA8rQC,QAAA,sPAAAC,aAA2wBC,KAAA,KAAAC,MAAA,cAAkCN,MAAQC,GAAA,iHAAAC,KAAA,0vPAAolPC,QAAA,yNAAmUC,aAAkNC,KAAA,KAAAC,MAAA,aAAiCN,MAAQC,GAAA,wGAAAC,KAAA,84CAA49CC,QAAA,gQAAAC,aAAiVC,KAAA,KAAAC,MAAA,SAA6BN,MAAQC,GAAA,wGAAAC,KAAA,4oBAAAC,QAAA,oPAAAC,aAAyhCC,KAAA,KAAAC,MAAA,WAA+BN,MAAQC,GAAA,kGAAAC,KAAA,qsKAAkyKC,QAAA,wPAAAC,aAAsSC,KAAA,KAAAC,MAAA,aAAiCN,MAAQC,GAAA,oGAAAC,KAAA,6lFAAwgDC,QAAA,0OAAAC,aAAggDC,KAAA,KAAAC,MAAA,mBAAuCN,MAAQC,GAAA,yGAAAC,KAAA,opEAA2PC,QAAA,8PAAsqEC,aAAqKC,KAAA,KAAAC,MAAA,UAA8BN,MAAQC,GAAA,oGAAAC,KAAA,2zKAAyjKC,QAAA,sPAA0ZC,aAA+OC,KAAA,KAAAC,MAAA,aAAiCN,MAAQC,GAAA,8GAAAC,KAAA;AAA66OC,QAAA,mNAAAC,aAA+cC,KAAA,KAAAC,MAAA,gBAAoCN,MAAQC,GAAA,kGAAAC,KAAA,2/IAAu8IC,QAAA,oNAAAC,aAAidC,KAAA,KAAAC,MAAA,WAA8BC","file":"path---index-cbfb748ba7b6881303ab.js","sourcesContent":["webpackJsonp([142629428675168],{\n\n/***/ 886:\n/***/ (function(module, exports) {\n\n\tmodule.exports = {\"data\":{\"allMarkdownRemark\":{\"edges\":[{\"node\":{\"id\":\"/Users/luz/code/js/binstd.github.io/markdown/info.md absPath of file >>> MarkdownRemark\",\"html\":\"<p>binstd以程序员为核心建设技术信用,对开发者实现数据化的了解，理解。推动开发生态建设，建立技术生态底层的公用数据服务资源，区块链跨链云服务;发行技术生态标准数字资产STD。成为技术落地的最后一公里，引领开发潮流。\\n<img src=\\\"https://ws4.sinaimg.cn/large/006tKfTcgy1ftjtbu2fuej30w60lawf1.jpg\\\"></p>\\n<p><strong>跨链云服务</strong>\\n建立区块链云服务平台，支持多个公链网络的跨链层建设，多种语言的封装服务。逐步建设跨链 基础链和状态数据链。</p>\\n<p><strong>公用资源服务及工具</strong>\\n打造程序(框架/库)、数据(云数据 API)的公用服务资源平台，实现开发能力和数据能力的组 件化、插件化、云端化，让开发变得更为简单。</p>\\n<p>提供版本控制系统、IDE、聊天/协作/Bug问题追踪、持续集成与交付部署与容器等云端工具服 务，为程序员创造便捷的线上协作开发体验。</p>\\n<p><strong>翻译计划</strong>\\n推动优质区块链技术普及，建设技术开发生态和开发者社群。</p>\",\"excerpt\":\"binstd以程序员为核心建设技术信用,对开发者实现数据化的了解，理解。推动开发生态建设，建立技术生态底层的公用数据服务资源，区块链跨链云服务;发行技术生态标准数字资产STD。成为技术落地的最后一公里，引领开发潮流。\\n 跨链云服务 \\n建立区块链云服务平台，支持多个公链网络的跨链层建设，多种语言的封装服务。逐步建设跨链 基础链和状态数据链。 公用资源服务及工具 \\n打造程序(框架/库)、数据(云数据 API…\",\"frontmatter\":{\"path\":\"/info\",\"title\":\"关于我们\"}}},{\"node\":{\"id\":\"/Users/luz/code/js/binstd.github.io/markdown/blog/index.1.md absPath of file >>> MarkdownRemark\",\"html\":\"<h3><strong>一.简单说下货币&#x26;积分</strong></h3>\\n<h6><strong>原始：黄金白银 贝壳</strong></h6>\\n<p>最早时期，交通不发达，内陆地区使用沿海才有的贝壳做为交换媒介，去换取物品，得到贝壳的人又用它去换取其他物品。后来交通发达后，人们可以轻易获得贝壳，于是贝壳不在做为货币（货币的总量是否要优先，是否要防范增发？）\\n为什么不是铜铁，木头？而是黄金，白银，和稀缺是不是有关系。因为稀缺所有值钱，因为之前，所以不需要太多黄金，就可以换取大部分物品。</p>\\n<h6><strong>山西票号</strong></h6>\\n<p>清明晚期，晋商遍布各地做生意，甚至生意做到海外，由于地域广，商人携带大量黄金白银有些不方便和不安全。山西票号适应了这个需求，它在各地建立票号，商户去票号保存银子，会得到一个票据，凭借票据可以异地提取。大大降低了商人出行携带大量银两的安全隐患和运输成本。</p>\\n<h6><strong>传统的数据库下的单节点（中心化）-积分</strong></h6>\\n<p>互联网重构很多行业，大家日常在使用各种app&#x26;网站时都有一个积分，比如早期的qq币，大家想一下这个东西如何实现？\\n<strong>大家大概都能想到一个数据仓库（专业点说叫数据库），记录着：</strong>\\n账号信息（用户名，昵称，秘密），你的qq币额度（还有多少qq币），你的消费记录（记录你的币怎么获得的，怎么消费的，你购买了什么东西）\\n<strong>这是什么呢，这是一个单节点维持的账本，腾讯这家公司控制的账本，这个账本能否做为货币？</strong></p>\\n<h3><strong>二.比特币的诞生</strong></h3>\\n<p>2008经济危机背景下，中本聪发表了比特币-点对点的电子支付系统，次年比特币诞生。2009年比特币正式上线。\\n并且在创世区块中写入了泰晤士报09年1.3号的头版标题，讽刺了一把银行。\\n大家肯定好奇比特币这套系统为什么得到那么多人推崇，为什么可以做到一枚2万美金？</p>\\n<p><strong>比特币是如何实现货币功能的？</strong></p>\\n<h6>1.多节点维持的账本（数据库）</h6>\\n<p>比特币创造了一个没有任何主体控制的系统，上文提到的积分是单个节点说了算，例如q币，就是腾讯说了算的，而比特币有多对等节点。且每个对等节点都有相同的完整的数据库记录或者说账本。\\n<strong>先看一下这个图，理解一下什么叫对等的节点，没有控制者：</strong></p>\\n<p><img src=\\\"https://blockluz-1253389096.cos.ap-beijing.myqcloud.com/blockman/qft6j.jpg\\\"></p>\\n<p><strong>一个经典问题：拜占庭军事问题，怎么解决这个问题？怎么保证数据一致，又怎么保证鼓励大家做比特币的节点（激励层）？这里先卖个关子，先从单个节点的数据结构上说：</strong></p>\\n<h6>2.比特币的单节点的数据结构</h6>\\n<p>区块+链，简单说就是一个个区块一环扣一环，链接而成：</p>\\n<p><img src=\\\"https://blockluz-1253389096.cos.ap-beijing.myqcloud.com/blockman/le9ng.jpg\\\"></p>\\n<p>听到区块这个词不必紧张，你把它当作一个有固定结构和规范的容器就行，就像一个楼层，一个房间。其中区块这个容器构成：包括区块头，交易记录两部分。\\n如图其中区块头中又包含三个部分父区块hash值，merkle树根，挖矿相关的难度值，时间戳等。大家先不用关系他们代表什么，我会在下文一一说明。\\n<strong>1.重点说父区块hash：</strong>（大家可以把hash值换成地址方便理解），这个父区块hash值呢，也可以说是上一个区块的hash值或者说地址（方便理解）。它的作用主要就是知道了前一个区块地址，从而连接前一个区块，形成一环扣一环的所谓区块链：</p>\\n<p><img src=\\\"https://blockluz-1253389096.cos.ap-beijing.myqcloud.com/blockman/xewx9.jpg\\\"></p>\\n<p>大家看图就会明白，这个一环扣一环既，如果其中一个区块的hash值出现变化，那整个链就断了。而上文提到上一个区块的hash值，那这个hash值是怎么来的呢？其实是对真个区块容器里，装载的所有信息或者说东西做一个运算得来的唯一值（hash运算），也就是说，区块中装载的信息出现改变，hash值一定会改变。从而提高了造假成本。</p>\\n<p><strong>接下来说区块头的的第二个信息merkle树根</strong>，这个词很飘，其实它的用途是做一个标记，刚才跟大家介绍了区块分成两个部分，一个区块头&#x26;一个是交易信息。其中交易信息是比特币的所有的转账记录（比特币的一个区块规定了所能装载的交易记录是1m，也就是大约500笔交易。当装满的时候，就会在区块头加上merkle树根信息，做为标识）</p>\\n<p><strong>而挖矿相关的信息</strong>，主要是用于生成下一个区块，以及发现该区块，这个知识点下文会说。</p>\\n<p>那么之前留下的问题是非可以解答了呢？<strong>即如何没有服务端控制，p2p之间如何协调一致，没有将军，士兵之间如何协调？如何刺激大家做比特币的节点，成为一个p？如何取代央行做货币的发行？</strong></p>\\n<h6>3.共识算法：pow&#x26;运行原理</h6>\\n<p>比特币的解决办法就是pow共识机制，想了解它，我们先来了解一个古老的问题，<strong>即拜占庭军事问题：</strong>\\n讲一个小故事，古时候有一个国家叫拜占庭，他很有钱也很强大，周围有几个小国，他们希望得到拜占庭的财富，但是呢，他们单个国家又无法攻破拜占庭，去攻击拜占庭一定会被消灭，他们之间呢，又各怀鬼胎，企图占领他国。\\n唯一能攻破拜占庭的方案就是他们几个国家一起攻击。这里就涉及到一个问题，就是这个几个互不信任的国家，如何同步的问题。</p>\\n<p>前面提到比特币是区块+链的结构，且区块头中有父区块的hash值，也就知道了父区块的位置，<strong>然后比特币里有个出块的概念，既每隔一段时间产生一个新区块（空的）</strong>中本聪发明了一个游戏，谁先踩中下一个区块的hash值，就全网停止继续运算，全网也去同步他的区块。并准备猜下一个区块的hash值。\\n如何猜中hash值，控制难度呢？由前面提到的区块头的挖矿相关的nonce值，时间戳等控制。</p>\\n<p><img src=\\\"https://blockluz-1253389096.cos.ap-beijing.myqcloud.com/blockman/ez1rn.jpg\\\"></p>\\n<p><strong>那么比特币如何鼓励大家成为它的节点呢？</strong>猜出新区块hash值的矿工，可以获得一个叫coinbase交易的奖励，以及转账的手续费奖励。\\n<strong>这里就要提到区块结构的第二部分：交易信息（merkle树）</strong>\\n首先明确一个概念，比特币是没有账户概念的，所以的额度，都是通过遍历整个的交易信息获取到，并做+-运算的来。\\n所以的比特币客户端出了区块链这个库，还有一个交易池的概念，既你的每次转账都会广播全网的所有节点，并将该转账信息加入到他们各种的交易池中，而非直接放到区块链里。\\n<strong>如何将交易池中保存的交易记录放到区块链中呢？</strong>\\n每次挖出新块后矿工，即将交易数据打包放到到新区块中，其中挖矿获得的奖励和交易手续费也将加入到区块中。直到区块装满（比特币是1m的交易容量），和上文提到的踩中hash后的广播是同一次的。 </p>\\n<p><img src=\\\"media/15219667839362/15221343606583.jpg\\\">                                                                                  </p>\\n<h6>4.<strong>比特币的公钥匙私</strong></h6>\\n<p>比特币生成一个私钥，对私钥做算法运算得到公钥。这个运算是有一个固定算法的，所以可以离线生成比特币的私钥。（硬件钱包，纸钱包原理），且不可逆转。\\n<img src=\\\"https://blockluz-1253389096.cos.ap-beijing.myqcloud.com/blockman/939e3.jpg\\\"></p>\\n<h6><strong>钱包说明</strong></h6>\\n<p>这个私钥是意味着控制权。联想到上面的区块链的交易记录，他会记录转账地址和金额。这个地址就是公钥。所以你可以在任何钱包上使用这个私钥。\\n在交易所中，只提供给你币的地址，没有提供私钥。所以你的转账，其实最终的控制是交易所完成的。而非你自己。但是在钱包里就不一样了。</p>\\n<p>钱包是不是比特币的节点？不一定，有集成节点的钱包，也有调取的比特币网络节点接口的钱包。</p>\\n<h3>附录</h3>\\n<h6>名词解释避坑：</h6>\\n<p><strong>共识：</strong>\\n共识机制的共识是指不同节点直接的数据同步，以及奖励的分配的共识。\\n而在民生，在大众认同等问题上也会提到共识。比如比特币靠什么能赢？很多人说共识，其实这个共识的意思是大众的认同，也就是多少人认可你。在区块链项目里，通常有个社区治理的概念，即有多少人支持一个项目，对这个项目生态又有什么意见。往往涉及到投票等。这里大家可以预先查一下，dac，dao这些概念。了解下社区治理。同时后面解释一个项目：比特股也会在探讨他。</p>\\n<p><strong>节点：</strong>\\n很多资料只会给你解释比特币的区块链里是保存交易记录的。但是没有说明这个交易记录是一种树结构，这种树结构是很多区块链项目都有涉及到的。树就有节点。这里要和区块链网络的节点区分开。</p>\\n<h6><strong>课外常识：</strong></h6>\\n<p><strong>不要怂，就是干，一把梭</strong>\\n对梭的解释：\\n早期出现在股票市场里，主要指不管3721，把前投进去就是了。常常被大家用来自嘲。\\n<strong>会所嫩模</strong>\\n通常是大家对炒币的一种期许，希望币百倍，千倍增长。从而实现财富自由。\\n<strong>韭菜</strong>\\n一般指散户，在区块链项目上的投资通常就是买项目发行的币。门槛很低，基本什么人都能参与。\\n也被用于指不讲技巧的投。比如前面提到的“不要怂，就是干，一把梭”，可用于自嘲，或讽刺他人</p>\\n<h6><strong>问题：</strong></h6>\\n<p>如何定义区块链？只是比特币的区块+链的结构嘛？如果没有对等的节点呢？\\n如果没有p2p分散的节点，或者有人占据了大部分节点，是否能串改数据？区块+链的结构不好改，如果是先搞一个任务池，重构整个区块链呢？也就是一次升级的是吧。</p>\\n<p>区块链还能干做什么？只是做币嘛？没有别的用途嘛？这里先卖个关子。比特币只是一个功能机，后面会讲到一个项目，它把比特币创造的区块链的智能机时代。赋予区块链更多的想象力。</p>\",\"excerpt\":\"…\",\"frontmatter\":{\"path\":\"/blog1\",\"title\":\"比特币的诞生和区块链\"}}},{\"node\":{\"id\":\"/Users/luz/code/js/binstd.github.io/markdown/blog/index.2.md absPath of file >>> MarkdownRemark\",\"html\":\"<h3><strong>一.简单说下货币&#x26;积分</strong></h3>\\n<h6><strong>原始：黄金白银 贝壳</strong></h6>\\n<p>最早时期，交通不发达，内陆地区使用沿海才有的贝壳做为交换媒介，去换取物品，得到贝壳的人又用它去换取其他物品。后来交通发达后，人们可以轻易获得贝壳，于是贝壳不在做为货币（货币的总量是否要优先，是否要防范增发？）\\n为什么不是铜铁，木头？而是黄金，白银，和稀缺是不是有关系。因为稀缺所有值钱，因为之前，所以不需要太多黄金，就可以换取大部分物品。</p>\\n<h6><strong>山西票号</strong></h6>\\n<p>清明晚期，晋商遍布各地做生意，甚至生意做到海外，由于地域广，商人携带大量黄金白银有些不方便和不安全。山西票号适应了这个需求，它在各地建立票号，商户去票号保存银子，会得到一个票据，凭借票据可以异地提取。大大降低了商人出行携带大量银两的安全隐患和运输成本。</p>\\n<h6><strong>传统的数据库下的单节点（中心化）-积分</strong></h6>\\n<p>互联网重构很多行业，大家日常在使用各种app&#x26;网站时都有一个积分，比如早期的qq币，大家想一下这个东西如何实现？\\n<strong>大家大概都能想到一个数据仓库（专业点说叫数据库），记录着：</strong>\\n账号信息（用户名，昵称，秘密），你的qq币额度（还有多少qq币），你的消费记录（记录你的币怎么获得的，怎么消费的，你购买了什么东西）\\n<strong>这是什么呢，这是一个单节点维持的账本，腾讯这家公司控制的账本，这个账本能否做为货币？</strong></p>\\n<h3><strong>二.比特币的诞生</strong></h3>\\n<p>2008经济危机背景下，中本聪发表了比特币-点对点的电子支付系统，次年比特币诞生。2009年比特币正式上线。\\n并且在创世区块中写入了泰晤士报09年1.3号的头版标题，讽刺了一把银行。\\n大家肯定好奇比特币这套系统为什么得到那么多人推崇，为什么可以做到一枚2万美金？</p>\\n<p><strong>比特币是如何实现货币功能的？</strong></p>\\n<h6>1.多节点维持的账本（数据库）</h6>\\n<p>比特币创造了一个没有任何主体控制的系统，上文提到的积分是单个节点说了算，例如q币，就是腾讯说了算的，而比特币有多对等节点。且每个对等节点都有相同的完整的数据库记录或者说账本。\\n<strong>先看一下这个图，理解一下什么叫对等的节点，没有控制者：</strong></p>\\n<p><img src=\\\"https://blockluz-1253389096.cos.ap-beijing.myqcloud.com/blockman/qft6j.jpg\\\"></p>\\n<p><strong>一个经典问题：拜占庭军事问题，怎么解决这个问题？怎么保证数据一致，又怎么保证鼓励大家做比特币的节点（激励层）？这里先卖个关子，先从单个节点的数据结构上说：</strong></p>\\n<h6>2.比特币的单节点的数据结构</h6>\\n<p>区块+链，简单说就是一个个区块一环扣一环，链接而成：</p>\\n<p><img src=\\\"https://blockluz-1253389096.cos.ap-beijing.myqcloud.com/blockman/le9ng.jpg\\\"></p>\\n<p>听到区块这个词不必紧张，你把它当作一个有固定结构和规范的容器就行，就像一个楼层，一个房间。其中区块这个容器构成：包括区块头，交易记录两部分。\\n如图其中区块头中又包含三个部分父区块hash值，merkle树根，挖矿相关的难度值，时间戳等。大家先不用关系他们代表什么，我会在下文一一说明。\\n<strong>1.重点说父区块hash：</strong>（大家可以把hash值换成地址方便理解），这个父区块hash值呢，也可以说是上一个区块的hash值或者说地址（方便理解）。它的作用主要就是知道了前一个区块地址，从而连接前一个区块，形成一环扣一环的所谓区块链：</p>\\n<p><img src=\\\"https://blockluz-1253389096.cos.ap-beijing.myqcloud.com/blockman/xewx9.jpg\\\"></p>\\n<p>大家看图就会明白，这个一环扣一环既，如果其中一个区块的hash值出现变化，那整个链就断了。而上文提到上一个区块的hash值，那这个hash值是怎么来的呢？其实是对真个区块容器里，装载的所有信息或者说东西做一个运算得来的唯一值（hash运算），也就是说，区块中装载的信息出现改变，hash值一定会改变。从而提高了造假成本。</p>\\n<p><strong>接下来说区块头的的第二个信息merkle树根</strong>，这个词很飘，其实它的用途是做一个标记，刚才跟大家介绍了区块分成两个部分，一个区块头&#x26;一个是交易信息。其中交易信息是比特币的所有的转账记录（比特币的一个区块规定了所能装载的交易记录是1m，也就是大约500笔交易。当装满的时候，就会在区块头加上merkle树根信息，做为标识）</p>\\n<p><strong>而挖矿相关的信息</strong>，主要是用于生成下一个区块，以及发现该区块，这个知识点下文会说。</p>\\n<p>那么之前留下的问题是非可以解答了呢？<strong>即如何没有服务端控制，p2p之间如何协调一致，没有将军，士兵之间如何协调？如何刺激大家做比特币的节点，成为一个p？如何取代央行做货币的发行？</strong></p>\\n<h6>3.共识算法：pow&#x26;运行原理</h6>\\n<p>比特币的解决办法就是pow共识机制，想了解它，我们先来了解一个古老的问题，<strong>即拜占庭军事问题：</strong>\\n讲一个小故事，古时候有一个国家叫拜占庭，他很有钱也很强大，周围有几个小国，他们希望得到拜占庭的财富，但是呢，他们单个国家又无法攻破拜占庭，去攻击拜占庭一定会被消灭，他们之间呢，又各怀鬼胎，企图占领他国。\\n唯一能攻破拜占庭的方案就是他们几个国家一起攻击。这里就涉及到一个问题，就是这个几个互不信任的国家，如何同步的问题。</p>\\n<p>前面提到比特币是区块+链的结构，且区块头中有父区块的hash值，也就知道了父区块的位置，<strong>然后比特币里有个出块的概念，既每隔一段时间产生一个新区块（空的）</strong>中本聪发明了一个游戏，谁先踩中下一个区块的hash值，就全网停止继续运算，全网也去同步他的区块。并准备猜下一个区块的hash值。\\n如何猜中hash值，控制难度呢？由前面提到的区块头的挖矿相关的nonce值，时间戳等控制。</p>\\n<p><img src=\\\"https://blockluz-1253389096.cos.ap-beijing.myqcloud.com/blockman/ez1rn.jpg\\\"></p>\\n<p><strong>那么比特币如何鼓励大家成为它的节点呢？</strong>猜出新区块hash值的矿工，可以获得一个叫coinbase交易的奖励，以及转账的手续费奖励。\\n<strong>这里就要提到区块结构的第二部分：交易信息（merkle树）</strong>\\n首先明确一个概念，比特币是没有账户概念的，所以的额度，都是通过遍历整个的交易信息获取到，并做+-运算的来。\\n所以的比特币客户端出了区块链这个库，还有一个交易池的概念，既你的每次转账都会广播全网的所有节点，并将该转账信息加入到他们各种的交易池中，而非直接放到区块链里。\\n<strong>如何将交易池中保存的交易记录放到区块链中呢？</strong>\\n每次挖出新块后矿工，即将交易数据打包放到到新区块中，其中挖矿获得的奖励和交易手续费也将加入到区块中。直到区块装满（比特币是1m的交易容量），和上文提到的踩中hash后的广播是同一次的。 </p>\\n<p><img src=\\\"media/15219667839362/15221343606583.jpg\\\">                                                                                  </p>\\n<h6>4.<strong>比特币的公钥匙私</strong></h6>\\n<p>比特币生成一个私钥，对私钥做算法运算得到公钥。这个运算是有一个固定算法的，所以可以离线生成比特币的私钥。（硬件钱包，纸钱包原理），且不可逆转。\\n<img src=\\\"https://blockluz-1253389096.cos.ap-beijing.myqcloud.com/blockman/939e3.jpg\\\"></p>\\n<h6><strong>钱包说明</strong></h6>\\n<p>这个私钥是意味着控制权。联想到上面的区块链的交易记录，他会记录转账地址和金额。这个地址就是公钥。所以你可以在任何钱包上使用这个私钥。\\n在交易所中，只提供给你币的地址，没有提供私钥。所以你的转账，其实最终的控制是交易所完成的。而非你自己。但是在钱包里就不一样了。</p>\\n<p>钱包是不是比特币的节点？不一定，有集成节点的钱包，也有调取的比特币网络节点接口的钱包。</p>\\n<h3>附录</h3>\\n<h6>名词解释避坑：</h6>\\n<p><strong>共识：</strong>\\n共识机制的共识是指不同节点直接的数据同步，以及奖励的分配的共识。\\n而在民生，在大众认同等问题上也会提到共识。比如比特币靠什么能赢？很多人说共识，其实这个共识的意思是大众的认同，也就是多少人认可你。在区块链项目里，通常有个社区治理的概念，即有多少人支持一个项目，对这个项目生态又有什么意见。往往涉及到投票等。这里大家可以预先查一下，dac，dao这些概念。了解下社区治理。同时后面解释一个项目：比特股也会在探讨他。</p>\\n<p><strong>节点：</strong>\\n很多资料只会给你解释比特币的区块链里是保存交易记录的。但是没有说明这个交易记录是一种树结构，这种树结构是很多区块链项目都有涉及到的。树就有节点。这里要和区块链网络的节点区分开。</p>\\n<h6><strong>课外常识：</strong></h6>\\n<p><strong>不要怂，就是干，一把梭</strong>\\n对梭的解释：\\n早期出现在股票市场里，主要指不管3721，把前投进去就是了。常常被大家用来自嘲。\\n<strong>会所嫩模</strong>\\n通常是大家对炒币的一种期许，希望币百倍，千倍增长。从而实现财富自由。\\n<strong>韭菜</strong>\\n一般指散户，在区块链项目上的投资通常就是买项目发行的币。门槛很低，基本什么人都能参与。\\n也被用于指不讲技巧的投。比如前面提到的“不要怂，就是干，一把梭”，可用于自嘲，或讽刺他人</p>\\n<h6><strong>问题：</strong></h6>\\n<p>如何定义区块链？只是比特币的区块+链的结构嘛？如果没有对等的节点呢？\\n如果没有p2p分散的节点，或者有人占据了大部分节点，是否能串改数据？区块+链的结构不好改，如果是先搞一个任务池，重构整个区块链呢？也就是一次升级的是吧。</p>\\n<p>区块链还能干做什么？只是做币嘛？没有别的用途嘛？这里先卖个关子。比特币只是一个功能机，后面会讲到一个项目，它把比特币创造的区块链的智能机时代。赋予区块链更多的想象力。</p>\",\"excerpt\":\"…\",\"frontmatter\":{\"path\":\"/blog2\",\"title\":\"比特币的诞生和区块链\"}}},{\"node\":{\"id\":\"/Users/luz/code/js/binstd.github.io/markdown/blog/index.3.md absPath of file >>> MarkdownRemark\",\"html\":\"<h3><strong>一.简单说下货币&#x26;积分</strong></h3>\\n<h6><strong>原始：黄金白银 贝壳</strong></h6>\\n<p>最早时期，交通不发达，内陆地区使用沿海才有的贝壳做为交换媒介，去换取物品，得到贝壳的人又用它去换取其他物品。后来交通发达后，人们可以轻易获得贝壳，于是贝壳不在做为货币（货币的总量是否要优先，是否要防范增发？）\\n为什么不是铜铁，木头？而是黄金，白银，和稀缺是不是有关系。因为稀缺所有值钱，因为之前，所以不需要太多黄金，就可以换取大部分物品。</p>\\n<h6><strong>山西票号</strong></h6>\\n<p>清明晚期，晋商遍布各地做生意，甚至生意做到海外，由于地域广，商人携带大量黄金白银有些不方便和不安全。山西票号适应了这个需求，它在各地建立票号，商户去票号保存银子，会得到一个票据，凭借票据可以异地提取。大大降低了商人出行携带大量银两的安全隐患和运输成本。</p>\\n<h6><strong>传统的数据库下的单节点（中心化）-积分</strong></h6>\\n<p>互联网重构很多行业，大家日常在使用各种app&#x26;网站时都有一个积分，比如早期的qq币，大家想一下这个东西如何实现？\\n<strong>大家大概都能想到一个数据仓库（专业点说叫数据库），记录着：</strong>\\n账号信息（用户名，昵称，秘密），你的qq币额度（还有多少qq币），你的消费记录（记录你的币怎么获得的，怎么消费的，你购买了什么东西）\\n<strong>这是什么呢，这是一个单节点维持的账本，腾讯这家公司控制的账本，这个账本能否做为货币？</strong></p>\\n<h3><strong>二.比特币的诞生</strong></h3>\\n<p>2008经济危机背景下，中本聪发表了比特币-点对点的电子支付系统，次年比特币诞生。2009年比特币正式上线。\\n并且在创世区块中写入了泰晤士报09年1.3号的头版标题，讽刺了一把银行。\\n大家肯定好奇比特币这套系统为什么得到那么多人推崇，为什么可以做到一枚2万美金？</p>\\n<p><strong>比特币是如何实现货币功能的？</strong></p>\\n<h6>1.多节点维持的账本（数据库）</h6>\\n<p>比特币创造了一个没有任何主体控制的系统，上文提到的积分是单个节点说了算，例如q币，就是腾讯说了算的，而比特币有多对等节点。且每个对等节点都有相同的完整的数据库记录或者说账本。\\n<strong>先看一下这个图，理解一下什么叫对等的节点，没有控制者：</strong></p>\\n<p><img src=\\\"https://blockluz-1253389096.cos.ap-beijing.myqcloud.com/blockman/qft6j.jpg\\\"></p>\\n<p><strong>一个经典问题：拜占庭军事问题，怎么解决这个问题？怎么保证数据一致，又怎么保证鼓励大家做比特币的节点（激励层）？这里先卖个关子，先从单个节点的数据结构上说：</strong></p>\\n<h6>2.比特币的单节点的数据结构</h6>\\n<p>区块+链，简单说就是一个个区块一环扣一环，链接而成：</p>\\n<p><img src=\\\"https://blockluz-1253389096.cos.ap-beijing.myqcloud.com/blockman/le9ng.jpg\\\"></p>\\n<p>听到区块这个词不必紧张，你把它当作一个有固定结构和规范的容器就行，就像一个楼层，一个房间。其中区块这个容器构成：包括区块头，交易记录两部分。\\n如图其中区块头中又包含三个部分父区块hash值，merkle树根，挖矿相关的难度值，时间戳等。大家先不用关系他们代表什么，我会在下文一一说明。\\n<strong>1.重点说父区块hash：</strong>（大家可以把hash值换成地址方便理解），这个父区块hash值呢，也可以说是上一个区块的hash值或者说地址（方便理解）。它的作用主要就是知道了前一个区块地址，从而连接前一个区块，形成一环扣一环的所谓区块链：</p>\\n<p><img src=\\\"https://blockluz-1253389096.cos.ap-beijing.myqcloud.com/blockman/xewx9.jpg\\\"></p>\\n<p>大家看图就会明白，这个一环扣一环既，如果其中一个区块的hash值出现变化，那整个链就断了。而上文提到上一个区块的hash值，那这个hash值是怎么来的呢？其实是对真个区块容器里，装载的所有信息或者说东西做一个运算得来的唯一值（hash运算），也就是说，区块中装载的信息出现改变，hash值一定会改变。从而提高了造假成本。</p>\\n<p><strong>接下来说区块头的的第二个信息merkle树根</strong>，这个词很飘，其实它的用途是做一个标记，刚才跟大家介绍了区块分成两个部分，一个区块头&#x26;一个是交易信息。其中交易信息是比特币的所有的转账记录（比特币的一个区块规定了所能装载的交易记录是1m，也就是大约500笔交易。当装满的时候，就会在区块头加上merkle树根信息，做为标识）</p>\\n<p><strong>而挖矿相关的信息</strong>，主要是用于生成下一个区块，以及发现该区块，这个知识点下文会说。</p>\\n<p>那么之前留下的问题是非可以解答了呢？<strong>即如何没有服务端控制，p2p之间如何协调一致，没有将军，士兵之间如何协调？如何刺激大家做比特币的节点，成为一个p？如何取代央行做货币的发行？</strong></p>\\n<h6>3.共识算法：pow&#x26;运行原理</h6>\\n<p>比特币的解决办法就是pow共识机制，想了解它，我们先来了解一个古老的问题，<strong>即拜占庭军事问题：</strong>\\n讲一个小故事，古时候有一个国家叫拜占庭，他很有钱也很强大，周围有几个小国，他们希望得到拜占庭的财富，但是呢，他们单个国家又无法攻破拜占庭，去攻击拜占庭一定会被消灭，他们之间呢，又各怀鬼胎，企图占领他国。\\n唯一能攻破拜占庭的方案就是他们几个国家一起攻击。这里就涉及到一个问题，就是这个几个互不信任的国家，如何同步的问题。</p>\\n<p>前面提到比特币是区块+链的结构，且区块头中有父区块的hash值，也就知道了父区块的位置，<strong>然后比特币里有个出块的概念，既每隔一段时间产生一个新区块（空的）</strong>中本聪发明了一个游戏，谁先踩中下一个区块的hash值，就全网停止继续运算，全网也去同步他的区块。并准备猜下一个区块的hash值。\\n如何猜中hash值，控制难度呢？由前面提到的区块头的挖矿相关的nonce值，时间戳等控制。</p>\\n<p><img src=\\\"https://blockluz-1253389096.cos.ap-beijing.myqcloud.com/blockman/ez1rn.jpg\\\"></p>\\n<p><strong>那么比特币如何鼓励大家成为它的节点呢？</strong>猜出新区块hash值的矿工，可以获得一个叫coinbase交易的奖励，以及转账的手续费奖励。\\n<strong>这里就要提到区块结构的第二部分：交易信息（merkle树）</strong>\\n首先明确一个概念，比特币是没有账户概念的，所以的额度，都是通过遍历整个的交易信息获取到，并做+-运算的来。\\n所以的比特币客户端出了区块链这个库，还有一个交易池的概念，既你的每次转账都会广播全网的所有节点，并将该转账信息加入到他们各种的交易池中，而非直接放到区块链里。\\n<strong>如何将交易池中保存的交易记录放到区块链中呢？</strong>\\n每次挖出新块后矿工，即将交易数据打包放到到新区块中，其中挖矿获得的奖励和交易手续费也将加入到区块中。直到区块装满（比特币是1m的交易容量），和上文提到的踩中hash后的广播是同一次的。 </p>\\n<p><img src=\\\"media/15219667839362/15221343606583.jpg\\\">                                                                                  </p>\\n<h6>4.<strong>比特币的公钥匙私</strong></h6>\\n<p>比特币生成一个私钥，对私钥做算法运算得到公钥。这个运算是有一个固定算法的，所以可以离线生成比特币的私钥。（硬件钱包，纸钱包原理），且不可逆转。\\n<img src=\\\"https://blockluz-1253389096.cos.ap-beijing.myqcloud.com/blockman/939e3.jpg\\\"></p>\\n<h6><strong>钱包说明</strong></h6>\\n<p>这个私钥是意味着控制权。联想到上面的区块链的交易记录，他会记录转账地址和金额。这个地址就是公钥。所以你可以在任何钱包上使用这个私钥。\\n在交易所中，只提供给你币的地址，没有提供私钥。所以你的转账，其实最终的控制是交易所完成的。而非你自己。但是在钱包里就不一样了。</p>\\n<p>钱包是不是比特币的节点？不一定，有集成节点的钱包，也有调取的比特币网络节点接口的钱包。</p>\\n<h3>附录</h3>\\n<h6>名词解释避坑：</h6>\\n<p><strong>共识：</strong>\\n共识机制的共识是指不同节点直接的数据同步，以及奖励的分配的共识。\\n而在民生，在大众认同等问题上也会提到共识。比如比特币靠什么能赢？很多人说共识，其实这个共识的意思是大众的认同，也就是多少人认可你。在区块链项目里，通常有个社区治理的概念，即有多少人支持一个项目，对这个项目生态又有什么意见。往往涉及到投票等。这里大家可以预先查一下，dac，dao这些概念。了解下社区治理。同时后面解释一个项目：比特股也会在探讨他。</p>\\n<p><strong>节点：</strong>\\n很多资料只会给你解释比特币的区块链里是保存交易记录的。但是没有说明这个交易记录是一种树结构，这种树结构是很多区块链项目都有涉及到的。树就有节点。这里要和区块链网络的节点区分开。</p>\\n<h6><strong>课外常识：</strong></h6>\\n<p><strong>不要怂，就是干，一把梭</strong>\\n对梭的解释：\\n早期出现在股票市场里，主要指不管3721，把前投进去就是了。常常被大家用来自嘲。\\n<strong>会所嫩模</strong>\\n通常是大家对炒币的一种期许，希望币百倍，千倍增长。从而实现财富自由。\\n<strong>韭菜</strong>\\n一般指散户，在区块链项目上的投资通常就是买项目发行的币。门槛很低，基本什么人都能参与。\\n也被用于指不讲技巧的投。比如前面提到的“不要怂，就是干，一把梭”，可用于自嘲，或讽刺他人</p>\\n<h6><strong>问题：</strong></h6>\\n<p>如何定义区块链？只是比特币的区块+链的结构嘛？如果没有对等的节点呢？\\n如果没有p2p分散的节点，或者有人占据了大部分节点，是否能串改数据？区块+链的结构不好改，如果是先搞一个任务池，重构整个区块链呢？也就是一次升级的是吧。</p>\\n<p>区块链还能干做什么？只是做币嘛？没有别的用途嘛？这里先卖个关子。比特币只是一个功能机，后面会讲到一个项目，它把比特币创造的区块链的智能机时代。赋予区块链更多的想象力。</p>\",\"excerpt\":\"…\",\"frontmatter\":{\"path\":\"/blog3\",\"title\":\"比特币的诞生和区块链\"}}},{\"node\":{\"id\":\"/Users/luz/code/js/binstd.github.io/markdown/blog/index.4.md absPath of file >>> MarkdownRemark\",\"html\":\"<h3><strong>一.简单说下货币&#x26;积分</strong></h3>\\n<h6><strong>原始：黄金白银 贝壳</strong></h6>\\n<p>最早时期，交通不发达，内陆地区使用沿海才有的贝壳做为交换媒介，去换取物品，得到贝壳的人又用它去换取其他物品。后来交通发达后，人们可以轻易获得贝壳，于是贝壳不在做为货币（货币的总量是否要优先，是否要防范增发？）\\n为什么不是铜铁，木头？而是黄金，白银，和稀缺是不是有关系。因为稀缺所有值钱，因为之前，所以不需要太多黄金，就可以换取大部分物品。</p>\\n<h6><strong>山西票号</strong></h6>\\n<p>清明晚期，晋商遍布各地做生意，甚至生意做到海外，由于地域广，商人携带大量黄金白银有些不方便和不安全。山西票号适应了这个需求，它在各地建立票号，商户去票号保存银子，会得到一个票据，凭借票据可以异地提取。大大降低了商人出行携带大量银两的安全隐患和运输成本。</p>\\n<h6><strong>传统的数据库下的单节点（中心化）-积分</strong></h6>\\n<p>互联网重构很多行业，大家日常在使用各种app&#x26;网站时都有一个积分，比如早期的qq币，大家想一下这个东西如何实现？\\n<strong>大家大概都能想到一个数据仓库（专业点说叫数据库），记录着：</strong>\\n账号信息（用户名，昵称，秘密），你的qq币额度（还有多少qq币），你的消费记录（记录你的币怎么获得的，怎么消费的，你购买了什么东西）\\n<strong>这是什么呢，这是一个单节点维持的账本，腾讯这家公司控制的账本，这个账本能否做为货币？</strong></p>\\n<h3><strong>二.比特币的诞生</strong></h3>\\n<p>2008经济危机背景下，中本聪发表了比特币-点对点的电子支付系统，次年比特币诞生。2009年比特币正式上线。\\n并且在创世区块中写入了泰晤士报09年1.3号的头版标题，讽刺了一把银行。\\n大家肯定好奇比特币这套系统为什么得到那么多人推崇，为什么可以做到一枚2万美金？</p>\\n<p><strong>比特币是如何实现货币功能的？</strong></p>\\n<h6>1.多节点维持的账本（数据库）</h6>\\n<p>比特币创造了一个没有任何主体控制的系统，上文提到的积分是单个节点说了算，例如q币，就是腾讯说了算的，而比特币有多对等节点。且每个对等节点都有相同的完整的数据库记录或者说账本。\\n<strong>先看一下这个图，理解一下什么叫对等的节点，没有控制者：</strong></p>\\n<p><img src=\\\"https://blockluz-1253389096.cos.ap-beijing.myqcloud.com/blockman/qft6j.jpg\\\"></p>\\n<p><strong>一个经典问题：拜占庭军事问题，怎么解决这个问题？怎么保证数据一致，又怎么保证鼓励大家做比特币的节点（激励层）？这里先卖个关子，先从单个节点的数据结构上说：</strong></p>\\n<h6>2.比特币的单节点的数据结构</h6>\\n<p>区块+链，简单说就是一个个区块一环扣一环，链接而成：</p>\\n<p><img src=\\\"https://blockluz-1253389096.cos.ap-beijing.myqcloud.com/blockman/le9ng.jpg\\\"></p>\\n<p>听到区块这个词不必紧张，你把它当作一个有固定结构和规范的容器就行，就像一个楼层，一个房间。其中区块这个容器构成：包括区块头，交易记录两部分。\\n如图其中区块头中又包含三个部分父区块hash值，merkle树根，挖矿相关的难度值，时间戳等。大家先不用关系他们代表什么，我会在下文一一说明。\\n<strong>1.重点说父区块hash：</strong>（大家可以把hash值换成地址方便理解），这个父区块hash值呢，也可以说是上一个区块的hash值或者说地址（方便理解）。它的作用主要就是知道了前一个区块地址，从而连接前一个区块，形成一环扣一环的所谓区块链：</p>\\n<p><img src=\\\"https://blockluz-1253389096.cos.ap-beijing.myqcloud.com/blockman/xewx9.jpg\\\"></p>\\n<p>大家看图就会明白，这个一环扣一环既，如果其中一个区块的hash值出现变化，那整个链就断了。而上文提到上一个区块的hash值，那这个hash值是怎么来的呢？其实是对真个区块容器里，装载的所有信息或者说东西做一个运算得来的唯一值（hash运算），也就是说，区块中装载的信息出现改变，hash值一定会改变。从而提高了造假成本。</p>\\n<p><strong>接下来说区块头的的第二个信息merkle树根</strong>，这个词很飘，其实它的用途是做一个标记，刚才跟大家介绍了区块分成两个部分，一个区块头&#x26;一个是交易信息。其中交易信息是比特币的所有的转账记录（比特币的一个区块规定了所能装载的交易记录是1m，也就是大约500笔交易。当装满的时候，就会在区块头加上merkle树根信息，做为标识）</p>\\n<p><strong>而挖矿相关的信息</strong>，主要是用于生成下一个区块，以及发现该区块，这个知识点下文会说。</p>\\n<p>那么之前留下的问题是非可以解答了呢？<strong>即如何没有服务端控制，p2p之间如何协调一致，没有将军，士兵之间如何协调？如何刺激大家做比特币的节点，成为一个p？如何取代央行做货币的发行？</strong></p>\\n<h6>3.共识算法：pow&#x26;运行原理</h6>\\n<p>比特币的解决办法就是pow共识机制，想了解它，我们先来了解一个古老的问题，<strong>即拜占庭军事问题：</strong>\\n讲一个小故事，古时候有一个国家叫拜占庭，他很有钱也很强大，周围有几个小国，他们希望得到拜占庭的财富，但是呢，他们单个国家又无法攻破拜占庭，去攻击拜占庭一定会被消灭，他们之间呢，又各怀鬼胎，企图占领他国。\\n唯一能攻破拜占庭的方案就是他们几个国家一起攻击。这里就涉及到一个问题，就是这个几个互不信任的国家，如何同步的问题。</p>\\n<p>前面提到比特币是区块+链的结构，且区块头中有父区块的hash值，也就知道了父区块的位置，<strong>然后比特币里有个出块的概念，既每隔一段时间产生一个新区块（空的）</strong>中本聪发明了一个游戏，谁先踩中下一个区块的hash值，就全网停止继续运算，全网也去同步他的区块。并准备猜下一个区块的hash值。\\n如何猜中hash值，控制难度呢？由前面提到的区块头的挖矿相关的nonce值，时间戳等控制。</p>\\n<p><img src=\\\"https://blockluz-1253389096.cos.ap-beijing.myqcloud.com/blockman/ez1rn.jpg\\\"></p>\\n<p><strong>那么比特币如何鼓励大家成为它的节点呢？</strong>猜出新区块hash值的矿工，可以获得一个叫coinbase交易的奖励，以及转账的手续费奖励。\\n<strong>这里就要提到区块结构的第二部分：交易信息（merkle树）</strong>\\n首先明确一个概念，比特币是没有账户概念的，所以的额度，都是通过遍历整个的交易信息获取到，并做+-运算的来。\\n所以的比特币客户端出了区块链这个库，还有一个交易池的概念，既你的每次转账都会广播全网的所有节点，并将该转账信息加入到他们各种的交易池中，而非直接放到区块链里。\\n<strong>如何将交易池中保存的交易记录放到区块链中呢？</strong>\\n每次挖出新块后矿工，即将交易数据打包放到到新区块中，其中挖矿获得的奖励和交易手续费也将加入到区块中。直到区块装满（比特币是1m的交易容量），和上文提到的踩中hash后的广播是同一次的。 </p>\\n<p><img src=\\\"media/15219667839362/15221343606583.jpg\\\">                                                                                  </p>\\n<h6>4.<strong>比特币的公钥匙私</strong></h6>\\n<p>比特币生成一个私钥，对私钥做算法运算得到公钥。这个运算是有一个固定算法的，所以可以离线生成比特币的私钥。（硬件钱包，纸钱包原理），且不可逆转。\\n<img src=\\\"https://blockluz-1253389096.cos.ap-beijing.myqcloud.com/blockman/939e3.jpg\\\"></p>\\n<h6><strong>钱包说明</strong></h6>\\n<p>这个私钥是意味着控制权。联想到上面的区块链的交易记录，他会记录转账地址和金额。这个地址就是公钥。所以你可以在任何钱包上使用这个私钥。\\n在交易所中，只提供给你币的地址，没有提供私钥。所以你的转账，其实最终的控制是交易所完成的。而非你自己。但是在钱包里就不一样了。</p>\\n<p>钱包是不是比特币的节点？不一定，有集成节点的钱包，也有调取的比特币网络节点接口的钱包。</p>\\n<h3>附录</h3>\\n<h6>名词解释避坑：</h6>\\n<p><strong>共识：</strong>\\n共识机制的共识是指不同节点直接的数据同步，以及奖励的分配的共识。\\n而在民生，在大众认同等问题上也会提到共识。比如比特币靠什么能赢？很多人说共识，其实这个共识的意思是大众的认同，也就是多少人认可你。在区块链项目里，通常有个社区治理的概念，即有多少人支持一个项目，对这个项目生态又有什么意见。往往涉及到投票等。这里大家可以预先查一下，dac，dao这些概念。了解下社区治理。同时后面解释一个项目：比特股也会在探讨他。</p>\\n<p><strong>节点：</strong>\\n很多资料只会给你解释比特币的区块链里是保存交易记录的。但是没有说明这个交易记录是一种树结构，这种树结构是很多区块链项目都有涉及到的。树就有节点。这里要和区块链网络的节点区分开。</p>\\n<h6><strong>课外常识：</strong></h6>\\n<p><strong>不要怂，就是干，一把梭</strong>\\n对梭的解释：\\n早期出现在股票市场里，主要指不管3721，把前投进去就是了。常常被大家用来自嘲。\\n<strong>会所嫩模</strong>\\n通常是大家对炒币的一种期许，希望币百倍，千倍增长。从而实现财富自由。\\n<strong>韭菜</strong>\\n一般指散户，在区块链项目上的投资通常就是买项目发行的币。门槛很低，基本什么人都能参与。\\n也被用于指不讲技巧的投。比如前面提到的“不要怂，就是干，一把梭”，可用于自嘲，或讽刺他人</p>\\n<h6><strong>问题：</strong></h6>\\n<p>如何定义区块链？只是比特币的区块+链的结构嘛？如果没有对等的节点呢？\\n如果没有p2p分散的节点，或者有人占据了大部分节点，是否能串改数据？区块+链的结构不好改，如果是先搞一个任务池，重构整个区块链呢？也就是一次升级的是吧。</p>\\n<p>区块链还能干做什么？只是做币嘛？没有别的用途嘛？这里先卖个关子。比特币只是一个功能机，后面会讲到一个项目，它把比特币创造的区块链的智能机时代。赋予区块链更多的想象力。</p>\",\"excerpt\":\"…\",\"frontmatter\":{\"path\":\"/blog4\",\"title\":\"比特币的诞生和区块链\"}}},{\"node\":{\"id\":\"/Users/luz/code/js/binstd.github.io/markdown/blog/index.md absPath of file >>> MarkdownRemark\",\"html\":\"<h3><strong>一.简单说下货币&#x26;积分</strong></h3>\\n<h6><strong>原始：黄金白银 贝壳</strong></h6>\\n<p>最早时期，交通不发达，内陆地区使用沿海才有的贝壳做为交换媒介，去换取物品，得到贝壳的人又用它去换取其他物品。后来交通发达后，人们可以轻易获得贝壳，于是贝壳不在做为货币（货币的总量是否要优先，是否要防范增发？）\\n为什么不是铜铁，木头？而是黄金，白银，和稀缺是不是有关系。因为稀缺所有值钱，因为之前，所以不需要太多黄金，就可以换取大部分物品。</p>\\n<h6><strong>山西票号</strong></h6>\\n<p>清明晚期，晋商遍布各地做生意，甚至生意做到海外，由于地域广，商人携带大量黄金白银有些不方便和不安全。山西票号适应了这个需求，它在各地建立票号，商户去票号保存银子，会得到一个票据，凭借票据可以异地提取。大大降低了商人出行携带大量银两的安全隐患和运输成本。</p>\\n<h6><strong>传统的数据库下的单节点（中心化）-积分</strong></h6>\\n<p>互联网重构很多行业，大家日常在使用各种app&#x26;网站时都有一个积分，比如早期的qq币，大家想一下这个东西如何实现？\\n<strong>大家大概都能想到一个数据仓库（专业点说叫数据库），记录着：</strong>\\n账号信息（用户名，昵称，秘密），你的qq币额度（还有多少qq币），你的消费记录（记录你的币怎么获得的，怎么消费的，你购买了什么东西）\\n<strong>这是什么呢，这是一个单节点维持的账本，腾讯这家公司控制的账本，这个账本能否做为货币？</strong></p>\\n<h3><strong>二.比特币的诞生</strong></h3>\\n<p>2008经济危机背景下，中本聪发表了比特币-点对点的电子支付系统，次年比特币诞生。2009年比特币正式上线。\\n并且在创世区块中写入了泰晤士报09年1.3号的头版标题，讽刺了一把银行。\\n大家肯定好奇比特币这套系统为什么得到那么多人推崇，为什么可以做到一枚2万美金？</p>\\n<p><strong>比特币是如何实现货币功能的？</strong></p>\\n<h6>1.多节点维持的账本（数据库）</h6>\\n<p>比特币创造了一个没有任何主体控制的系统，上文提到的积分是单个节点说了算，例如q币，就是腾讯说了算的，而比特币有多对等节点。且每个对等节点都有相同的完整的数据库记录或者说账本。\\n<strong>先看一下这个图，理解一下什么叫对等的节点，没有控制者：</strong></p>\\n<p><img src=\\\"https://blockluz-1253389096.cos.ap-beijing.myqcloud.com/blockman/qft6j.jpg\\\"></p>\\n<p><strong>一个经典问题：拜占庭军事问题，怎么解决这个问题？怎么保证数据一致，又怎么保证鼓励大家做比特币的节点（激励层）？这里先卖个关子，先从单个节点的数据结构上说：</strong></p>\\n<h6>2.比特币的单节点的数据结构</h6>\\n<p>区块+链，简单说就是一个个区块一环扣一环，链接而成：</p>\\n<p><img src=\\\"https://blockluz-1253389096.cos.ap-beijing.myqcloud.com/blockman/le9ng.jpg\\\"></p>\\n<p>听到区块这个词不必紧张，你把它当作一个有固定结构和规范的容器就行，就像一个楼层，一个房间。其中区块这个容器构成：包括区块头，交易记录两部分。\\n如图其中区块头中又包含三个部分父区块hash值，merkle树根，挖矿相关的难度值，时间戳等。大家先不用关系他们代表什么，我会在下文一一说明。\\n<strong>1.重点说父区块hash：</strong>（大家可以把hash值换成地址方便理解），这个父区块hash值呢，也可以说是上一个区块的hash值或者说地址（方便理解）。它的作用主要就是知道了前一个区块地址，从而连接前一个区块，形成一环扣一环的所谓区块链：</p>\\n<p><img src=\\\"https://blockluz-1253389096.cos.ap-beijing.myqcloud.com/blockman/xewx9.jpg\\\"></p>\\n<p>大家看图就会明白，这个一环扣一环既，如果其中一个区块的hash值出现变化，那整个链就断了。而上文提到上一个区块的hash值，那这个hash值是怎么来的呢？其实是对真个区块容器里，装载的所有信息或者说东西做一个运算得来的唯一值（hash运算），也就是说，区块中装载的信息出现改变，hash值一定会改变。从而提高了造假成本。</p>\\n<p><strong>接下来说区块头的的第二个信息merkle树根</strong>，这个词很飘，其实它的用途是做一个标记，刚才跟大家介绍了区块分成两个部分，一个区块头&#x26;一个是交易信息。其中交易信息是比特币的所有的转账记录（比特币的一个区块规定了所能装载的交易记录是1m，也就是大约500笔交易。当装满的时候，就会在区块头加上merkle树根信息，做为标识）</p>\\n<p><strong>而挖矿相关的信息</strong>，主要是用于生成下一个区块，以及发现该区块，这个知识点下文会说。</p>\\n<p>那么之前留下的问题是非可以解答了呢？<strong>即如何没有服务端控制，p2p之间如何协调一致，没有将军，士兵之间如何协调？如何刺激大家做比特币的节点，成为一个p？如何取代央行做货币的发行？</strong></p>\\n<h6>3.共识算法：pow&#x26;运行原理</h6>\\n<p>比特币的解决办法就是pow共识机制，想了解它，我们先来了解一个古老的问题，<strong>即拜占庭军事问题：</strong>\\n讲一个小故事，古时候有一个国家叫拜占庭，他很有钱也很强大，周围有几个小国，他们希望得到拜占庭的财富，但是呢，他们单个国家又无法攻破拜占庭，去攻击拜占庭一定会被消灭，他们之间呢，又各怀鬼胎，企图占领他国。\\n唯一能攻破拜占庭的方案就是他们几个国家一起攻击。这里就涉及到一个问题，就是这个几个互不信任的国家，如何同步的问题。</p>\\n<p>前面提到比特币是区块+链的结构，且区块头中有父区块的hash值，也就知道了父区块的位置，<strong>然后比特币里有个出块的概念，既每隔一段时间产生一个新区块（空的）</strong>中本聪发明了一个游戏，谁先踩中下一个区块的hash值，就全网停止继续运算，全网也去同步他的区块。并准备猜下一个区块的hash值。\\n如何猜中hash值，控制难度呢？由前面提到的区块头的挖矿相关的nonce值，时间戳等控制。</p>\\n<p><img src=\\\"https://blockluz-1253389096.cos.ap-beijing.myqcloud.com/blockman/ez1rn.jpg\\\"></p>\\n<p><strong>那么比特币如何鼓励大家成为它的节点呢？</strong>猜出新区块hash值的矿工，可以获得一个叫coinbase交易的奖励，以及转账的手续费奖励。\\n<strong>这里就要提到区块结构的第二部分：交易信息（merkle树）</strong>\\n首先明确一个概念，比特币是没有账户概念的，所以的额度，都是通过遍历整个的交易信息获取到，并做+-运算的来。\\n所以的比特币客户端出了区块链这个库，还有一个交易池的概念，既你的每次转账都会广播全网的所有节点，并将该转账信息加入到他们各种的交易池中，而非直接放到区块链里。\\n<strong>如何将交易池中保存的交易记录放到区块链中呢？</strong>\\n每次挖出新块后矿工，即将交易数据打包放到到新区块中，其中挖矿获得的奖励和交易手续费也将加入到区块中。直到区块装满（比特币是1m的交易容量），和上文提到的踩中hash后的广播是同一次的。 </p>\\n<p><img src=\\\"media/15219667839362/15221343606583.jpg\\\">                                                                                  </p>\\n<h6>4.<strong>比特币的公钥匙私</strong></h6>\\n<p>比特币生成一个私钥，对私钥做算法运算得到公钥。这个运算是有一个固定算法的，所以可以离线生成比特币的私钥。（硬件钱包，纸钱包原理），且不可逆转。\\n<img src=\\\"https://blockluz-1253389096.cos.ap-beijing.myqcloud.com/blockman/939e3.jpg\\\"></p>\\n<h6><strong>钱包说明</strong></h6>\\n<p>这个私钥是意味着控制权。联想到上面的区块链的交易记录，他会记录转账地址和金额。这个地址就是公钥。所以你可以在任何钱包上使用这个私钥。\\n在交易所中，只提供给你币的地址，没有提供私钥。所以你的转账，其实最终的控制是交易所完成的。而非你自己。但是在钱包里就不一样了。</p>\\n<p>钱包是不是比特币的节点？不一定，有集成节点的钱包，也有调取的比特币网络节点接口的钱包。</p>\\n<h3>附录</h3>\\n<h6>名词解释避坑：</h6>\\n<p><strong>共识：</strong>\\n共识机制的共识是指不同节点直接的数据同步，以及奖励的分配的共识。\\n而在民生，在大众认同等问题上也会提到共识。比如比特币靠什么能赢？很多人说共识，其实这个共识的意思是大众的认同，也就是多少人认可你。在区块链项目里，通常有个社区治理的概念，即有多少人支持一个项目，对这个项目生态又有什么意见。往往涉及到投票等。这里大家可以预先查一下，dac，dao这些概念。了解下社区治理。同时后面解释一个项目：比特股也会在探讨他。</p>\\n<p><strong>节点：</strong>\\n很多资料只会给你解释比特币的区块链里是保存交易记录的。但是没有说明这个交易记录是一种树结构，这种树结构是很多区块链项目都有涉及到的。树就有节点。这里要和区块链网络的节点区分开。</p>\\n<h6><strong>课外常识：</strong></h6>\\n<p><strong>不要怂，就是干，一把梭</strong>\\n对梭的解释：\\n早期出现在股票市场里，主要指不管3721，把前投进去就是了。常常被大家用来自嘲。\\n<strong>会所嫩模</strong>\\n通常是大家对炒币的一种期许，希望币百倍，千倍增长。从而实现财富自由。\\n<strong>韭菜</strong>\\n一般指散户，在区块链项目上的投资通常就是买项目发行的币。门槛很低，基本什么人都能参与。\\n也被用于指不讲技巧的投。比如前面提到的“不要怂，就是干，一把梭”，可用于自嘲，或讽刺他人</p>\\n<h6><strong>问题：</strong></h6>\\n<p>如何定义区块链？只是比特币的区块+链的结构嘛？如果没有对等的节点呢？\\n如果没有p2p分散的节点，或者有人占据了大部分节点，是否能串改数据？区块+链的结构不好改，如果是先搞一个任务池，重构整个区块链呢？也就是一次升级的是吧。</p>\\n<p>区块链还能干做什么？只是做币嘛？没有别的用途嘛？这里先卖个关子。比特币只是一个功能机，后面会讲到一个项目，它把比特币创造的区块链的智能机时代。赋予区块链更多的想象力。</p>\",\"excerpt\":\"…\",\"frontmatter\":{\"path\":\"/eth\",\"title\":\"比特币的诞生和区块链\"}}},{\"node\":{\"id\":\"/Users/luz/code/js/binstd.github.io/markdown/docs/en/composite-component.md absPath of file >>> MarkdownRemark\",\"html\":\"<h1>Assemble a composite component</h1>\\n<p>Last chapter we built our first component; this chapter extends what we learned to build TaskList, a list of Tasks. Let’s combine components together and see what happens when more complexity is introduced.</p>\\n<h2>Tasklist</h2>\\n<p>Taskbox emphasizes pinned tasks by positioning them above default tasks. This yields two variations of <code>TaskList</code> you need to create stories for: default items and default and pinned items.</p>\\n<p><img src=\\\"/tasklist-states-1.png\\\" alt=\\\"default and pinned tasks\\\"></p>\\n<p>Since <code>Task</code> data can be sent asynchronously, we <strong>also</strong> need a loading state to render in the absence of a connection. In addition, an empty state is required when there are no tasks.</p>\\n<p><img src=\\\"/tasklist-states-2.png\\\" alt=\\\"empty and loading tasks\\\"></p>\\n<h2>Get setup</h2>\\n<p>A composite component isn’t much different than the basic components it contains. Create a <code>TaskList</code> component and an accompanying story file: <code>src/components/TaskList.js</code> and <code>src/components/TaskList.stories.js</code>.</p>\\n<p>Start with a rough implementation of the <code>TaskList</code>. You’ll need to import the <code>Task</code> component from earlier and pass in the attributes and actions as inputs.</p>\\n<pre><code class=\\\"language-javascript\\\">import React from 'react';\\n\\nimport Task from './Task';\\n\\nfunction TaskList({ loading, tasks, onPinTask, onArchiveTask }) {\\n  const events = {\\n    onPinTask,\\n    onArchiveTask,\\n  };\\n\\n  if (loading) {\\n    return &#x3C;div className=\\\"list-items\\\">loading&#x3C;/div>;\\n  }\\n\\n  if (tasks.length === 0) {\\n    return &#x3C;div className=\\\"list-items\\\">empty&#x3C;/div>;\\n  }\\n\\n  return (\\n    &#x3C;div className=\\\"list-items\\\">\\n      {tasks.map(task => &#x3C;Task key={task.id} task={task} {...events} />)}\\n    &#x3C;/div>\\n  );\\n}\\n\\nexport default TaskList;\\n</code></pre>\\n<p>Next create <code>Tasklist</code>’s test states in the story file.</p>\\n<pre><code class=\\\"language-javascript\\\">import React from 'react';\\nimport { storiesOf } from '@storybook/react';\\n\\nimport TaskList from './TaskList';\\nimport { task, actions } from './Task.stories';\\n\\nexport const defaultTasks = [\\n  { ...task, id: '1', title: 'Task 1' },\\n  { ...task, id: '2', title: 'Task 2' },\\n  { ...task, id: '3', title: 'Task 3' },\\n  { ...task, id: '4', title: 'Task 4' },\\n  { ...task, id: '5', title: 'Task 5' },\\n  { ...task, id: '6', title: 'Task 6' },\\n];\\n\\nexport const withPinnedTasks = [\\n  ...defaultTasks.slice(0, 5),\\n  { id: '6', title: 'Task 6 (pinned)', state: 'TASK_PINNED' },\\n];\\n\\nstoriesOf('TaskList', module)\\n  .addDecorator(story => &#x3C;div style={{ padding: '3rem' }}>{story()}&#x3C;/div>)\\n  .add('default', () => &#x3C;TaskList tasks={defaultTasks} {...actions} />)\\n  .add('withPinnedTasks', () => &#x3C;TaskList tasks={withPinnedTasks} {...actions} />)\\n  .add('loading', () => &#x3C;TaskList loading tasks={[]} {...actions} />)\\n  .add('empty', () => &#x3C;TaskList tasks={[]} {...actions} />);\\n</code></pre>\\n<p><code>addDecorator()</code> allows us to add some “context” to the rendering of each task. In this case we add padding around the list to make it easier to visually verify.</p>\\n<div class=\\\"aside\\\">\\n<a href=\\\"https://storybook.js.org/addons/introduction/#1-decorators\\\"><b>Decorators</b></a> are a way to provide arbitrary wrappers to stories. In this case we’re using a decorator to add styling. They can also be used to wrap stories in “providers” –i.e. library components that set React context.\\n</div>\\n<p><code>task</code> supplies the shape of a <code>Task</code> that we created and exported from the <code>Task.stories.js</code> file. Similarly, <code>actions</code> defines the actions (mocked callbacks) that a <code>Task</code> component expects, which the <code>TaskList</code> also needs.</p>\\n<p>Now check Storybook for the new <code>TaskList</code> stories.</p>\\n<video autoPlay muted playsInline loop>\\n  <source\\n    src=\\\"/inprogress-tasklist-states.mp4\\\"\\n    type=\\\"video/mp4\\\"\\n  />\\n</video>\\n<h2>Build out the states</h2>\\n<p>Our component is still rough but now we have an idea of the stories to work toward. You might be thinking that the <code>.list-items</code> wrapper is overly simplistic. You're right – in most cases we wouldn’t create a new component just to add a wrapper. But the <strong>real complexity</strong> of <code>TaskList</code> component is revealed in the edge cases <code>withPinnedTasks</code>, <code>loading</code>, and <code>empty</code>.</p>\\n<pre><code class=\\\"language-javascript\\\">import React from 'react';\\n\\nimport Task from './Task';\\n\\nfunction TaskList({ loading, tasks, onPinTask, onArchiveTask }) {\\n  const events = {\\n    onPinTask,\\n    onArchiveTask,\\n  };\\n\\n  const LoadingRow = (\\n    &#x3C;div className=\\\"loading-item\\\">\\n      &#x3C;span className=\\\"glow-checkbox\\\" />\\n      &#x3C;span className=\\\"glow-text\\\">\\n        &#x3C;span>Loading&#x3C;/span> &#x3C;span>cool&#x3C;/span> &#x3C;span>state&#x3C;/span>\\n      &#x3C;/span>\\n    &#x3C;/div>\\n  );\\n\\n  if (loading) {\\n    return (\\n      &#x3C;div className=\\\"list-items\\\">\\n        {LoadingRow}\\n        {LoadingRow}\\n        {LoadingRow}\\n        {LoadingRow}\\n        {LoadingRow}\\n        {LoadingRow}\\n      &#x3C;/div>\\n    );\\n  }\\n\\n  if (tasks.length === 0) {\\n    return (\\n      &#x3C;div className=\\\"list-items\\\">\\n        &#x3C;div className=\\\"wrapper-message\\\">\\n          &#x3C;span className=\\\"icon-check\\\" />\\n          &#x3C;div className=\\\"title-message\\\">You have no tasks&#x3C;/div>\\n          &#x3C;div className=\\\"subtitle-message\\\">Sit back and relax&#x3C;/div>\\n        &#x3C;/div>\\n      &#x3C;/div>\\n    );\\n  }\\n\\n  const tasksInOrder = [\\n    ...tasks.filter(t => t.state === 'TASK_PINNED'),\\n    ...tasks.filter(t => t.state !== 'TASK_PINNED'),\\n  ];\\n\\n  return (\\n    &#x3C;div className=\\\"list-items\\\">\\n      {tasksInOrder.map(task => &#x3C;Task key={task.id} task={task} {...events} />)}\\n    &#x3C;/div>\\n  );\\n}\\n\\nexport default TaskList;\\n</code></pre>\\n<p>The added markup results in the following UI:</p>\\n<video autoPlay muted playsInline loop>\\n  <source\\n    src=\\\"/finished-tasklist-states.mp4\\\"\\n    type=\\\"video/mp4\\\"\\n  />\\n</video>\\n<p>Note the position of the pinned item in the list. We want the pinned item to render at the top of the list to make it a priority for our users.</p>\\n<h2>Data requirements and props</h2>\\n<p>As the component grows, so too do input requirements. Define the prop requirements of <code>TaskList</code>. Because <code>Task</code> is a child component, make sure to provide data in the right shape to render it. To save time and headache, reuse the propTypes you defined in <code>Task</code> earlier.</p>\\n<pre><code class=\\\"language-javascript\\\">import React from 'react';\\nimport PropTypes from 'prop-types';\\n\\nfunction TaskList() {\\n  ...\\n}\\n\\n\\nTaskList.propTypes = {\\n  loading: PropTypes.bool,\\n  tasks: PropTypes.arrayOf(Task.propTypes.task).isRequired,\\n  onPinTask: PropTypes.func.isRequired,\\n  onArchiveTask: PropTypes.func.isRequired,\\n};\\n\\nTaskList.defaultProps = {\\n  loading: false,\\n};\\n\\nexport default TaskList;\\n</code></pre>\\n<h2>Automated testing</h2>\\n<p>In the previous chapter we learned how to snapshot test stories using Storyshots. With <code>Task</code> there wasn’t a lot of complexity to test beyond that it renders OK. Since <code>TaskList</code> adds another layer of complexity we want to verify that certain inputs produce certain outputs in a way amenable to automatic testing. To do this we’ll create unit tests using <a href=\\\"https://facebook.github.io/jest/\\\">Jest</a> coupled with a test renderer such as <a href=\\\"http://airbnb.io/enzyme/\\\">Enzyme</a>.</p>\\n<p><img src=\\\"/logo-jest.png\\\" alt=\\\"Jest logo\\\"></p>\\n<h3>Unit tests with Jest</h3>\\n<p>Storybook stories paired with manual visual tests and snapshot tests (see above) go a long way to avoiding UI bugs. If stories cover a wide variety of component use cases, and we use tools that ensure a human checks any change to the story, errors are much less likely.</p>\\n<p>However, sometimes the devil is in the details. A test framework that is explicit about those details is needed. Which brings us to unit tests.</p>\\n<p>In our case, we want our <code>TaskList</code> to render any pinned tasks <strong>before</strong> unpinned tasks that it is passed in the <code>tasks</code> prop. Although we have a story (<code>withPinnedTasks</code>) to test this exact scenario; it can be ambiguous to a human reviewer that if the component <strong>stops</strong> ordering the tasks like this, it is a bug. It certainly won’t scream <strong>“Wrong!”</strong> to the casual eye.</p>\\n<p>So, to avoid this problem, we can use Jest to render the story to the DOM and run some DOM querying code to verify salient features of the output.</p>\\n<p>Create a test file called <code>TaskList.test.js</code>. Here we’ll build out our tests that make assertions about the output.</p>\\n<pre><code class=\\\"language-javascript\\\">import React from 'react';\\nimport ReactDOM from 'react-dom';\\nimport TaskList from './TaskList';\\nimport { withPinnedTasks } from './TaskList.stories';\\n\\nit('renders pinned tasks at the start of the list', () => {\\n  const div = document.createElement('div');\\n  const events = { onPinTask: jest.fn(), onArchiveTask: jest.fn() };\\n  ReactDOM.render(&#x3C;TaskList tasks={withPinnedTasks} {...events} />, div);\\n\\n  // We expect the task titled \\\"Task 6 (pinned)\\\" to be rendered first, not at the end\\n  const lastTaskInput = div.querySelector('.list-item:nth-child(1) input[value=\\\"Task 6 (pinned)\\\"]');\\n  expect(lastTaskInput).not.toBe(null);\\n\\n  ReactDOM.unmountComponentAtNode(div);\\n});\\n</code></pre>\\n<p><img src=\\\"/tasklist-testrunner.png\\\" alt=\\\"TaskList test runner\\\"></p>\\n<p>Note that we’ve been able to reuse the <code>withPinnedTasks</code> list of tasks in both story and unit test; in this way we can continue to leverage an existing resource (the examples that represent interesting configurations of a component) in more and more ways.</p>\\n<p>Notice as well that this test is quite brittle. It's possible that as the project matures, and the exact implementation of the <code>Task</code> changes --perhaps using a different classname or a <code>textarea</code> rather than an <code>input</code>--the test will fail, and need to be updated. This is not necessarily a problem, but rather an indication to be careful liberally using unit tests for UI. They're not easy to maintain. Instead rely on visual, snapshot, and visual regression (see <a href=\\\"/test/\\\">testing chapter</a>) tests where possible.</p>\",\"excerpt\":\"Assemble a composite component Last chapter we built our first component; this chapter extends what we learned to build TaskList, a list of Tasks. Let’s combine components together and see what happens when more complexity is introduced. Tasklist…\",\"frontmatter\":{\"path\":null,\"title\":\"Assemble a composite component\"}}},{\"node\":{\"id\":\"/Users/luz/code/js/binstd.github.io/markdown/docs/en/conclusion.md absPath of file >>> MarkdownRemark\",\"html\":\"<h1>Conclusion</h1>\\n<p>Congratulations! You created your first UI in Storybook. Along the way you learned how to build, compose, test, and deploy UI components. If you’ve been following, your repo and deployed Storybook should look like this:</p>\\n<p><a href=\\\"https://github.com/hichroma/learnstorybook-code\\\">📕 <strong>GitHub repo: hichroma/learnstorybook-code</strong></a>\\n<br/>\\n<a href=\\\"https://clever-banach-415c03.netlify.com/\\\">🌎 <strong>Deployed Storybook</strong></a></p>\\n<p>Storybook is a powerful tool for React, Vue, and Angular. It has a thriving developer community and a wealth of addons. This introduction scratches the surface of what’s possible. We’re confident that once you adopt Storybook, you’ll be impressed by how productive it is to build durable UIs.</p>\\n<h2>Learn more</h2>\\n<p>Want to dive deeper? Here are helpful resources.</p>\\n<ul>\\n<li>\\n<p><a href=\\\"https://storybook.js.org/basics/introduction/\\\"><strong>Official Storybook documentation</strong></a> has API documentation, community links, and the addon gallery.</p>\\n</li>\\n<li>\\n<p><a href=\\\"https://blog.hichroma.com/the-delightful-storybook-workflow-b322b76fd07\\\"><strong>The Delightful Storybook Workflow</strong></a> highlights workflow best practices used by high-velocity teams at Squarespace, Major League Soccer, Discovery Network, and Apollo GraphQL.</p>\\n</li>\\n<li>\\n<p><a href=\\\"https://www.chromaticqa.com/book/visual-testing-handbook\\\"><strong>Visual Testing Handbook</strong></a> dives deep into using Storybook to visual test components. Free 31-page ebook.</p>\\n</li>\\n</ul>\\n<h2>Who made LearnStorybook.com?</h2>\\n<p>The text, code, and production were contributed by <a href=\\\"http://blog.hichroma.com/\\\">Chroma</a>. The tutorial was inspired by Chroma’s popular <a href=\\\"https://blog.hichroma.com/graphql-react-tutorial-part-1-6-d0691af25858\\\">GraphQL + React tutorial series</a>.</p>\\n<p>Want more tutorials and articles like this? Sign up to the Chroma mailing list.</p>\\n<iframe style=\\\"height:400px;width:100%;max-width:800px;margin:30px auto;\\\" src=\\\"https://upscri.be/bface0?as_embed\\\"></iframe>\",\"excerpt\":\"Conclusion Congratulations! You created your first UI in Storybook. Along the way you learned how to build, compose, test, and deploy UI components. If you’ve been following, your repo and deployed Storybook should look like this: 📕  GitHub repo…\",\"frontmatter\":{\"path\":\"/blog\",\"title\":\"Conclusion\"}}},{\"node\":{\"id\":\"/Users/luz/code/js/binstd.github.io/markdown/docs/en/contribute.md absPath of file >>> MarkdownRemark\",\"html\":\"<h1>Contribute</h1>\\n<p>Contributions to Learn Storybook are encouraged! If it’s something small like grammar or punctuation, open up a pull request. If it’s a bigger change, <a href=\\\"https://github.com/hichroma/learnstorybook.com/issues\\\">add an issue</a> for discussion.</p>\\n<h2>Vue and Angular editions</h2>\\n<p>We’re looking for assistance updating our React/Redux example code to Vue and Angular. Comment on the <a href=\\\"https://github.com/hichroma/learnstorybook.com/issues/1\\\">Vue</a> or <a href=\\\"https://github.com/hichroma/learnstorybook.com/issues/2\\\">Angular</a> GitHub issue.</p>\\n<p><img src=\\\"/logos-angular-vue.png\\\" alt=\\\"Vue and Angular contributors wanted\\\"></p>\\n<h2>Translations</h2>\\n<p>Our goal is to make Storybook approachable to all people. Help translate this tutorial into other languages. We’re especially open to Chinese and Spanish translations. Comment on the <a href=\\\"https://github.com/hichroma/learnstorybook.com/issues/3\\\">issue here</a>.</p>\",\"excerpt\":\"Contribute Contributions to Learn Storybook are encouraged! If it’s something small like grammar or punctuation, open up a pull request. If it’s a bigger change,  add an issue  for discussion. Vue and Angular editions We’re looking for assistance…\",\"frontmatter\":{\"path\":\"/eth2\",\"title\":\"Contribute\"}}},{\"node\":{\"id\":\"/Users/luz/code/js/binstd.github.io/markdown/docs/en/data.md absPath of file >>> MarkdownRemark\",\"html\":\"<h1>Wire in data</h1>\\n<p>So far we created isolated stateless components –great for Storybook, but ultimately not useful until we give them some data in our app.</p>\\n<p>This tutorial doesn’t focus on the particulars of building an app so we won’t dig into those details here. But we will take a moment to look at a common pattern for wiring in data with container components.</p>\\n<h2>Container components</h2>\\n<p>Our <code>TaskList</code> component as currently written is “presentational” (see <a href=\\\"https://medium.com/@dan_abramov/smart-and-dumb-components-7ca2f9a7c7d0\\\">this blog post</a>) in that it doesn’t talk to anything external to its own implementation. To get data into it, we need a “container”.</p>\\n<p>This example uses <a href=\\\"https://redux.js.org/\\\">Redux</a>, the most popular React library for storing data, to build a simple data model for our app. However, the pattern used here applies just as well to other data management libraries like <a href=\\\"https://www.apollographql.com/client/\\\">Apollo</a> and <a href=\\\"https://mobx.js.org/\\\">MobX</a>.</p>\\n<p>First we’ll construct a simple Redux store that responds to actions that change the state of tasks, in a file called <code>lib/redux.js</code> in the <code>src</code> folder (intentionally kept simple):</p>\\n<pre><code class=\\\"language-javascript\\\">// A simple redux store/actions/reducer implementation.\\n// A true app would be more complex and separated into different files.\\nimport { createStore } from 'redux';\\n\\n// The actions are the \\\"names\\\" of the changes that can happen to the store\\nexport const actions = {\\n  ARCHIVE_TASK: 'ARCHIVE_TASK',\\n  PIN_TASK: 'PIN_TASK',\\n};\\n\\n// The action creators are how you bundle actions with the data required to execute them\\nexport const archiveTask = id => ({ type: actions.ARCHIVE_TASK, id });\\nexport const pinTask = id => ({ type: actions.PIN_TASK, id });\\n\\n// All our reducers simply change the state of a single task.\\nfunction taskStateReducer(taskState) {\\n  return (state, action) => {\\n    return {\\n      ...state,\\n      tasks: state.tasks.map(\\n        task => (task.id === action.id ? { ...task, state: taskState } : task)\\n      ),\\n    };\\n  };\\n}\\n\\n// The reducer describes how the contents of the store change for each action\\nexport const reducer = (state, action) => {\\n  switch (action.type) {\\n    case actions.ARCHIVE_TASK:\\n      return taskStateReducer('TASK_ARCHIVED')(state, action);\\n    case actions.PIN_TASK:\\n      return taskStateReducer('TASK_PINNED')(state, action);\\n    default:\\n      return state;\\n  }\\n};\\n\\n// The initial state of our store when the app loads.\\n// Usually you would fetch this from a server\\nconst defaultTasks = [\\n  { id: '1', title: 'Something', state: 'TASK_INBOX' },\\n  { id: '2', title: 'Something more', state: 'TASK_INBOX' },\\n  { id: '3', title: 'Something else', state: 'TASK_INBOX' },\\n  { id: '4', title: 'Something again', state: 'TASK_INBOX' },\\n];\\n\\n// We export the constructed redux store\\nexport default createStore(reducer, { tasks: defaultTasks });\\n</code></pre>\\n<p>Then we’ll update the default export from the <code>TaskList</code> component to connect to the Redux store and render the tasks we are interested in:</p>\\n<pre><code class=\\\"language-javascript\\\">import React from 'react';\\nimport PropTypes from 'prop-types';\\n\\nimport Task from './Task';\\nimport { connect } from 'react-redux';\\nimport { archiveTask, pinTask } from '../lib/redux';\\n\\nexport function PureTaskList({ loading, tasks, onPinTask, onArchiveTask }) {\\n  /* previous implementation of TaskList */\\n}\\n\\nPureTaskList.propTypes = {\\n  loading: PropTypes.bool,\\n  tasks: PropTypes.arrayOf(Task.propTypes.task).isRequired,\\n  onPinTask: PropTypes.func.isRequired,\\n  onArchiveTask: PropTypes.func.isRequired,\\n};\\n\\nPureTaskList.defaultProps = {\\n  loading: false,\\n};\\n\\nexport default connect(\\n  ({ tasks }) => ({\\n    tasks: tasks.filter(t => t.state === 'TASK_INBOX' || t.state === 'TASK_PINNED'),\\n  }),\\n  dispatch => ({\\n    onArchiveTask: id => dispatch(archiveTask(id)),\\n    onPinTask: id => dispatch(pinTask(id)),\\n  })\\n)(PureTaskList);\\n</code></pre>\\n<p>At this stage our Storybook tests will have stopped working, as the <code>TaskList</code> is now a container, and no longer expects any props, instead it connects to the store and sets the props on the <code>PureTaskList</code> component it wraps.</p>\\n<p>However, we can easily solve this problem by simply rendering the <code>PureTaskList</code> --the presentational component-- in our Storybook stories:</p>\\n<pre><code class=\\\"language-javascript\\\">import React from 'react';\\nimport { storiesOf } from '@storybook/react';\\n\\nimport { PureTaskList } from './TaskList';\\nimport { task, actions } from './Task.stories';\\n\\nexport const defaultTasks = [\\n  { ...task, id: '1', title: 'Task 1' },\\n  { ...task, id: '2', title: 'Task 2' },\\n  { ...task, id: '3', title: 'Task 3' },\\n  { ...task, id: '4', title: 'Task 4' },\\n  { ...task, id: '5', title: 'Task 5' },\\n  { ...task, id: '6', title: 'Task 6' },\\n];\\n\\nexport const withPinnedTasks = [\\n  ...defaultTasks.slice(0, 5),\\n  { id: '6', title: 'Task 6 (pinned)', state: 'TASK_PINNED' },\\n];\\n\\nstoriesOf('TaskList', module)\\n  .addDecorator(story => &#x3C;div style={{ padding: '3rem' }}>{story()}&#x3C;/div>)\\n  .add('default', () => &#x3C;PureTaskList tasks={defaultTasks} {...actions} />)\\n  .add('withPinnedTasks', () => &#x3C;PureTaskList tasks={withPinnedTasks} {...actions} />)\\n  .add('loading', () => &#x3C;PureTaskList loading tasks={[]} {...actions} />)\\n  .add('empty', () => &#x3C;PureTaskList tasks={[]} {...actions} />);\\n</code></pre>\\n<video autoPlay muted playsInline loop>\\n  <source\\n    src=\\\"/finished-tasklist-states.mp4\\\"\\n    type=\\\"video/mp4\\\"\\n  />\\n</video>\\n<p>Similarly, we need to use <code>PureTaskList</code> in our Jest test:</p>\\n<pre><code class=\\\"language-js\\\">import React from 'react';\\nimport ReactDOM from 'react-dom';\\nimport { PureTaskList } from './TaskList';\\nimport { withPinnedTasks } from './TaskList.stories';\\n\\nit('renders pinned tasks at the start of the list', () => {\\n  const div = document.createElement('div');\\n  const events = { onPinTask: jest.fn(), onArchiveTask: jest.fn() };\\n  ReactDOM.render(&#x3C;PureTaskList tasks={withPinnedTasks} {...events} />, div);\\n\\n  // We expect the task titled \\\"Task 6 (pinned)\\\" to be rendered first, not at the end\\n  const lastTaskInput = div.querySelector('.list-item:nth-child(1) input[value=\\\"Task 6 (pinned)\\\"]');\\n  expect(lastTaskInput).not.toBe(null);\\n\\n  ReactDOM.unmountComponentAtNode(div);\\n});\\n</code></pre>\",\"excerpt\":\"Wire in data So far we created isolated stateless components –great for Storybook, but ultimately not useful until we give them some data in our app. This tutorial doesn’t focus on the particulars of building an app so we won’t dig into those details…\",\"frontmatter\":{\"path\":null,\"title\":\"Wire in data\"}}},{\"node\":{\"id\":\"/Users/luz/code/js/binstd.github.io/markdown/docs/en/deploy.md absPath of file >>> MarkdownRemark\",\"html\":\"<h1>Deploy Storybook</h1>\\n<p>In this tutorial we ran Storybook on our development machine. You may also want to share that Storybook with the team, especially the non-technical members. Thankfully, it’s easy to deploy Storybook online.</p>\\n<div class=\\\"aside\\\">\\n<strong>Did you setup Chromatic testing earlier?</strong>\\n<br/>\\n🎉 Your stories are already deployed! Chromatic securely indexes your stories online and tracks them across branches and commits. Skip this chapter and go to the <a href=\\\"/conclusion\\\">conclusion</a>.\\n</div>\\n<h2>Exporting as a static app</h2>\\n<p>To deploy Storybook we first need to export it as a static web app. This functionality is already built into Storybook, we just need to activate it by adding a script to <code>package.json</code>.</p>\\n<pre><code class=\\\"language-javascript\\\">{\\n  \\\"scripts\\\": {\\n    \\\"build-storybook\\\": \\\"build-storybook -c .storybook -o .storybook-static\\\"\\n  }\\n}\\n</code></pre>\\n<p>Now when you build Storybook via <code>npm run build-storybook</code>, it will output a static Storybook in the <code>storybook-static</code> directory.</p>\\n<h2>Continuous deploy</h2>\\n<p>We want to share the latest version of components whenever we push code. To do this we need to continuous deploy Storybook. We’ll rely on GitHub and Netlify to deploy our static site. We’re using the Netlify free plan.</p>\\n<h3>GitHub</h3>\\n<p>First you want to setup Git for your project in the local directory. If you're following along from the previous testing chapter jump to setting up a repository on GitHub.</p>\\n<pre><code class=\\\"language-bash\\\">$ git init\\n</code></pre>\\n<p>Next add files to the first commit.</p>\\n<pre><code class=\\\"language-bash\\\">$ git add .\\n</code></pre>\\n<p>Now commit the files.</p>\\n<pre><code class=\\\"language-bash\\\">$ git commit -m \\\"taskbox UI\\\"\\n</code></pre>\\n<p>Go to GitHub and setup a repository <a href=\\\"https://github.com/new\\\">here</a>. Name your repo “taskbox”.</p>\\n<p><img src=\\\"/github-create-taskbox.png\\\" alt=\\\"GitHub setup\\\"></p>\\n<p>In the new repo setup copy the origin URL of the repo and add it to your git project with this command:</p>\\n<pre><code class=\\\"language-bash\\\">$ git remote add origin https://github.com/&#x3C;your username>/taskbox.git\\n</code></pre>\\n<p>Finally push the repo to GitHub</p>\\n<pre><code class=\\\"language-bash\\\">$ git push -u origin master\\n</code></pre>\\n<h3>Netlify</h3>\\n<p>Netlify has a continuous deployment service built in which will allow us to deploy Storybook without needing to configure our own CI.</p>\\n<div class=\\\"aside\\\">\\nIf you use CI at your company, add a deploy script to your config that uploads <code>storybook-static</code> to a static hosting service like S3.\\n</div>\\n<p><a href=\\\"https://app.netlify.com/start\\\">Create an account on Netlify</a> and click to “create site”.</p>\\n<p><img src=\\\"/netlify-create-site.png\\\" alt=\\\"Netlify create site\\\"></p>\\n<p>Next click the GitHub button to connect Netlify to GitHub. This allows it to access our remote Taskbox repo.</p>\\n<p>Now select the taskbox GitHub repo from the list of options.</p>\\n<p><img src=\\\"/netlify-account-picker.png\\\" alt=\\\"Netlify connect to repo\\\"></p>\\n<p>Configure Netlify by highlighting which build command to run in its CI and which directory the static site is outputted in. For branch choose <code>master</code>. Directory is <code>storybook-static</code>. Build command use <code>yarn build-storybook</code>.</p>\\n<p><img src=\\\"/netlify-settings.png\\\" alt=\\\"Netlify settings\\\"></p>\\n<p>Submit the form to build and deploy the code on the <code>master</code> branch of taskbox.</p>\\n<p>When that's finished we'll see a confirmation message on Netlify with a link to Taskbox’ Storybook online. If you're following along, your deployed Storybook should be online <a href=\\\"https://clever-banach-415c03.netlify.com/\\\">like so</a>.</p>\\n<p><img src=\\\"/netlify-storybook-deploy.png\\\" alt=\\\"Netlify Storybook deploy\\\"></p>\\n<p>We finished setting up continuous deployment of your Storybook! Now we can share our stories with teammates via a link.</p>\\n<p>This is helpful for visual review as part of the standard app development process or simply to show off work 💅.</p>\",\"excerpt\":\"Deploy Storybook In this tutorial we ran Storybook on our development machine. You may also want to share that Storybook with the team, especially the non-technical members. Thankfully, it’s easy to deploy Storybook online. Exporting as a static app…\",\"frontmatter\":{\"path\":null,\"title\":\"Deploy Storybook\"}}},{\"node\":{\"id\":\"/Users/luz/code/js/binstd.github.io/markdown/docs/en/get-started.md absPath of file >>> MarkdownRemark\",\"html\":\"<h1>Get started</h1>\\n<p>Storybook runs alongside your app in development mode. It helps you build UI components isolated from the business logic and context of your app. This edition of Learn Storybook is for React; other editions for Vue and Angular are coming soon.</p>\\n<p><img src=\\\"/storybook-relationship.jpg\\\" alt=\\\"Storybook and your app\\\"></p>\\n<h2>Setup React Storybook</h2>\\n<p>We’ll need to follow a few steps to get the build process set up in your environment. To start with, we want to use <a href=\\\"https://github.com/facebook/create-react-app\\\">Create React App</a> (CRA) to setup our build system, and enable <a href=\\\"https://storybook.js.org/\\\">Storybook</a> and <a href=\\\"https://facebook.github.io/jest/\\\">Jest</a> testing in our created app. Let’s run the following commands:</p>\\n<pre><code class=\\\"language-bash\\\"># Create our application:\\nnpx create-react-app taskbox\\ncd taskbox\\n\\n# Add Storybook:\\nnpx -p @storybook/cli getstorybook\\n</code></pre>\\n<p>We can quickly check that the various environments of our application are working properly:</p>\\n<pre><code class=\\\"language-bash\\\"># Run the test runner (Jest) in a terminal:\\nyarn test\\n\\n# Start the component explorer on port 9009:\\nyarn run storybook\\n\\n# Run the frontend app proper on port 3000:\\nyarn start\\n</code></pre>\\n<div class=\\\"aside\\\">\\n  NOTE: If <code>yarn test</code> throws an error, you may need to install <code>watchman</code> as advised in <a href=\\\"https://github.com/facebook/create-react-app/issues/871#issuecomment-252297884\\\">this issue</a>.\\n</div>\\n<p>Our three frontend app modalities: automated test (Jest), component development (Storybook), and the app itself.</p>\\n<p><img src=\\\"/app-three-modalities.png\\\" alt=\\\"3 modalities\\\"></p>\\n<p>Depending on what part of the app you’re working on, you may want to run one or more of these simultaneously. Since our current focus is creating a single UI component, we’ll stick with running Storybook.</p>\\n<h2>Reuse CSS</h2>\\n<p>Taskbox reuses design elements from the GraphQL and React Tutorial <a href=\\\"https://blog.hichroma.com/graphql-react-tutorial-part-1-6-d0691af25858\\\">example app</a>, so we won’t need to write CSS in this tutorial. We’ll simply compile the LESS to a single CSS file and include it in our app. Copy and paste <a href=\\\"https://github.com/hichroma/learnstorybook-code/blob/master/src/index.css\\\">this compiled CSS</a> into the src/index.css file per CRA’s convention.</p>\\n<p><img src=\\\"/ss-browserchrome-taskbox-learnstorybook.png\\\" alt=\\\"Taskbox UI\\\"></p>\\n<div class=\\\"aside\\\">\\nIf you want to modify the styling, the source LESS files are provided in the GitHub repo.\\n</div>\\n<h2>Add assets</h2>\\n<p>We also need to add the font and icon <a href=\\\"https://github.com/hichroma/learnstorybook-code/tree/master/public\\\">directories</a> to the <code>public/</code> folder. After adding styling and assets, the app will render a bit strangely. That’s OK. We aren’t working on the app right now. We’re starting off with building our first component!</p>\",\"excerpt\":\"Get started Storybook runs alongside your app in development mode. It helps you build UI components isolated from the business logic and context of your app. This edition of Learn Storybook is for React; other editions for Vue and Angular are coming…\",\"frontmatter\":{\"path\":null,\"title\":\"Get started\"}}},{\"node\":{\"id\":\"/Users/luz/code/js/binstd.github.io/markdown/docs/en/screen.md absPath of file >>> MarkdownRemark\",\"html\":\"<h1>Construct a screen</h1>\\n<p>We've concentrated on building UIs from the bottom up; starting small and adding complexity. Doing so has allowed us to develop each component in isolation, figure out its data needs, and play with it in Storybook. All without needing to stand up a server or build out screens!</p>\\n<p>In this chapter we continue to increase the sophistication by combining components in a screen and developing that screen in Storybook.</p>\\n<h2>Nested container components</h2>\\n<p>As our app is very simple, the screen we’ll build is pretty trivial, simply wrapping the <code>TaskList</code> component (which supplies its own data via Redux) in some layout and pulling a top-level <code>error</code> field out of redux (let's assume we'll set that field if we have some problem connecting to our server). Create <code>InboxScreen.js</code> in your <code>components</code> folder:</p>\\n<pre><code class=\\\"language-javascript\\\">import React from 'react';\\nimport PropTypes from 'prop-types';\\nimport { connect } from 'react-redux';\\n\\nimport TaskList from './TaskList';\\n\\nexport function PureInboxScreen({ error }) {\\n  if (error) {\\n    return (\\n      &#x3C;div className=\\\"page lists-show\\\">\\n        &#x3C;div className=\\\"wrapper-message\\\">\\n          &#x3C;span className=\\\"icon-face-sad\\\" />\\n          &#x3C;div className=\\\"title-message\\\">Oh no!&#x3C;/div>\\n          &#x3C;div className=\\\"subtitle-message\\\">Something went wrong&#x3C;/div>\\n        &#x3C;/div>\\n      &#x3C;/div>\\n    );\\n  }\\n\\n  return (\\n    &#x3C;div className=\\\"page lists-show\\\">\\n      &#x3C;nav>\\n        &#x3C;h1 className=\\\"title-page\\\">\\n          &#x3C;span className=\\\"title-wrapper\\\">Taskbox&#x3C;/span>\\n        &#x3C;/h1>\\n      &#x3C;/nav>\\n      &#x3C;TaskList />\\n    &#x3C;/div>\\n  );\\n}\\n\\nPureInboxScreen.propTypes = {\\n  error: PropTypes.string,\\n};\\n\\nPureInboxScreen.defaultProps = {\\n  error: null,\\n};\\n\\nexport default connect(({ error }) => ({ error }))(PureInboxScreen);\\n</code></pre>\\n<p>We also change the <code>App</code> component to render the <code>InboxScreen</code> (eventually we would use a router to choose the correct screen, but let's not worry about that here):</p>\\n<pre><code class=\\\"language-javascript\\\">import React, { Component } from 'react';\\nimport { Provider } from 'react-redux';\\nimport store from './lib/redux';\\n\\nimport InboxScreen from './components/InboxScreen';\\n\\nclass App extends Component {\\n  render() {\\n    return (\\n      &#x3C;Provider store={store}>\\n        &#x3C;InboxScreen />\\n      &#x3C;/Provider>\\n    );\\n  }\\n}\\n\\nexport default App;\\n</code></pre>\\n<p>However, where things get interesting is in rendering the story in Storybook.</p>\\n<p>As we saw previously, the <code>TaskList</code> component is a <strong>container</strong> that renders the <code>PureTaskList</code> presentational component. By definition container components cannot be simply rendered in isolation; they expect to be passed some context or to connect to a service. What this means is that to render a container in Storybook, we must mock (i.e. provide a pretend version) the context or service it requires.</p>\\n<p>When placing the <code>TaskList</code> into Storybook, we were able to dodge this issue by simply rendering the <code>PureTaskList</code> and avoiding the container. We'll do something similar and render the <code>PureInboxScreen</code> in Storybook also.</p>\\n<p>However, for the <code>PureInboxScreen</code> we have a problem because although the <code>PureInboxScreen</code> itself is presentational, its child, the <code>TaskList</code>, is not. In a sense the <code>PureInboxScreen</code> has been polluted by “container-ness”. So when we setup our stories in <code>InboxScreen.stories.js</code>:</p>\\n<pre><code class=\\\"language-javascript\\\">import React from 'react';\\nimport { storiesOf } from '@storybook/react';\\n\\nimport { PureInboxScreen } from './InboxScreen';\\n\\nstoriesOf('InboxScreen', module)\\n  .add('default', () => &#x3C;PureInboxScreen />)\\n  .add('error', () => &#x3C;PureInboxScreen error=\\\"Something\\\" />);\\n</code></pre>\\n<p>We see that although the <code>error</code> story works just fine, we have an issue in the <code>default</code> story, because the <code>TaskList</code> has no Redux store to connect to. (You also would encounter similar problems when trying to test the <code>PureInboxScreen</code> with a unit test).</p>\\n<p><img src=\\\"/broken-inboxscreen.png\\\" alt=\\\"Broken inbox\\\"></p>\\n<p>One way to sidestep this problem is to never render container components anywhere in your app except at the highest level and instead pass all data-requirements down the component hierarchy.</p>\\n<p>However, developers <strong>will</strong> inevitably need to render containers further down the component hierarchy. If we want to render most or all of the app in Storybook (we do!), we need a solution to this issue.</p>\\n<div class=\\\"aside\\\">\\nAs an aside, passing data down the hierarchy is a legitimate approach, especially when using <a href=\\\"http://graphql.org/\\\">GraphQL</a>. It’s how we have built <a href=\\\"https://chromaticqa.com\\\">Chromatic</a> alongside 670+ stories.\\n</div>\\n<h2>Supplying context with decorators</h2>\\n<p>The good news is that it is easy to supply a Redux store to the <code>InboxScreen</code> in a story! We can just use a mocked version of the Redux store provided in a decorator:</p>\\n<pre><code class=\\\"language-javascript\\\">import React from 'react';\\nimport { storiesOf } from '@storybook/react';\\nimport { action } from '@storybook/addon-actions';\\nimport { Provider } from 'react-redux';\\n\\nimport { PureInboxScreen } from './InboxScreen';\\nimport { defaultTasks } from './TaskList.stories';\\n\\n// A super-simple mock of a redux store\\nconst store = {\\n  getState: () => {\\n    return {\\n      tasks: defaultTasks,\\n    };\\n  },\\n  subscribe: () => 0,\\n  dispatch: action('dispatch'),\\n};\\n\\nstoriesOf('InboxScreen', module)\\n  .addDecorator(story => &#x3C;Provider store={store}>{story()}&#x3C;/Provider>)\\n  .add('default', () => &#x3C;PureInboxScreen />)\\n  .add('error', () => &#x3C;PureInboxScreen error=\\\"Something\\\" />);\\n</code></pre>\\n<p>Similar approaches exist to provide mocked context for other data libraries, such as <a href=\\\"https://www.npmjs.com/package/apollo-storybook-decorator\\\">Apollo</a>, <a href=\\\"https://github.com/orta/react-storybooks-relay-container\\\">Relay</a> and others.</p>\\n<p>Cycling through states in Storybook makes it easy to test we’ve done this correctly:</p>\\n<video autoPlay muted playsInline loop >\\n  <source\\n    src=\\\"/finished-inboxscreen-states.mp4\\\"\\n    type=\\\"video/mp4\\\"\\n  />\\n</video>\\n<h2>Component-Driven Development</h2>\\n<p>We started from the bottom with <code>Task</code>, then progressed to <code>TaskList</code>, now we’re here with a whole screen UI. Our <code>InboxScreen</code> accommodates a nested container component and includes accompanying stories.</p>\\n<video autoPlay muted playsInline loop style=\\\"width:480px; height:auto; margin: 0 auto;\\\">\\n  <source\\n    src=\\\"/component-driven-development-optimized.mp4\\\"\\n    type=\\\"video/mp4\\\"\\n  />\\n</video>\\n<p><a href=\\\"https://blog.hichroma.com/component-driven-development-ce1109d56c8e\\\"><strong>Component-Driven Development</strong></a> allows you to gradually expand complexity as you move up the component hierarchy. Among the benefits are a more focused development process and increased coverage of all possible UI permutations. In short, CDD helps you build higher-quality and more complex user interfaces.</p>\\n<p>We’re not done yet - the job doesn't end when the UI is built. We also need to ensure that it remains durable over time.</p>\",\"excerpt\":\"Construct a screen We've concentrated on building UIs from the bottom up; starting small and adding complexity. Doing so has allowed us to develop each component in isolation, figure out its data needs, and play with it in Storybook. All without…\",\"frontmatter\":{\"path\":null,\"title\":\"Construct a screen\"}}},{\"node\":{\"id\":\"/Users/luz/code/js/binstd.github.io/markdown/docs/en/simple-component.md absPath of file >>> MarkdownRemark\",\"html\":\"<h1>Build a simple component</h1>\\n<p>We’ll build our UI following a <a href=\\\"https://blog.hichroma.com/component-driven-development-ce1109d56c8e\\\">Component-Driven Development</a> (CDD) methodology. It’s a process that builds UIs from the “bottom up” starting with components and ending with screens. CDD helps you scale the amount of complexity you’re faced with as you build out the UI.</p>\\n<h2>Task</h2>\\n<p><img src=\\\"/task-states-learnstorybook.png\\\" alt=\\\"Task component in three states\\\"></p>\\n<p><code>Task</code> is the core component in our app. Each task displays slightly differently depending on exactly what state it’s in. We display a checked (or unchecked) checkbox, some information about the task, and a “pin” button, allowing us to move tasks up and down the list. Putting this together, we’ll need these props:</p>\\n<ul>\\n<li><code>title</code> – a string describing the task</li>\\n<li><code>state</code> - which list is the task currently in and is it checked off?</li>\\n</ul>\\n<p>As we start to build <code>Task</code>, we first write our test states that correspond to the different types of tasks sketch above. Then we use Storybook to build the component in isolation using mocked data. We’ll “visual test” the component’s appearance given each state as we go.</p>\\n<p>This process is similar to <a href=\\\"https://en.wikipedia.org/wiki/Test-driven_development\\\">Test-driven development</a> (TDD) that we can call “<a href=\\\"https://blog.hichroma.com/visual-test-driven-development-aec1c98bed87\\\">Visual TDD</a>”.</p>\\n<h2>Get setup</h2>\\n<p>First, let’s create the task component and its accompanying story file: <code>src/components/Task.js</code> and <code>src/components/Task.stories.js</code>.</p>\\n<p>We’ll begin with a basic implementation of the <code>Task</code>, simply taking in the attributes we know we’ll need and the two actions you can take on a task (to move it between lists):</p>\\n<pre><code class=\\\"language-javascript\\\">import React from 'react';\\n\\nexport default function Task({ task: { id, title, state }, onArchiveTask, onPinTask }) {\\n  return (\\n    &#x3C;div className=\\\"list-item\\\">\\n      &#x3C;input type=\\\"text\\\" value={title} readOnly={true} />\\n    &#x3C;/div>\\n  );\\n}\\n</code></pre>\\n<p>Above, we render straightforward markup for <code>Task</code> based on the existing HTML structure of the Todos app.</p>\\n<p>Below we build out Task’s three test states in the story file:</p>\\n<pre><code class=\\\"language-javascript\\\">import React from 'react';\\nimport { storiesOf } from '@storybook/react';\\nimport { action } from '@storybook/addon-actions';\\n\\nimport Task from './Task';\\n\\nexport const task = {\\n  id: '1',\\n  title: 'Test Task',\\n  state: 'TASK_INBOX',\\n  updatedAt: new Date(2018, 0, 1, 9, 0),\\n};\\n\\nexport const actions = {\\n  onPinTask: action('onPinTask'),\\n  onArchiveTask: action('onArchiveTask'),\\n};\\n\\nstoriesOf('Task', module)\\n  .add('default', () => &#x3C;Task task={task} {...actions} />)\\n  .add('pinned', () => &#x3C;Task task={{ ...task, state: 'TASK_PINNED' }} {...actions} />)\\n  .add('archived', () => &#x3C;Task task={{ ...task, state: 'TASK_ARCHIVED' }} {...actions} />);\\n</code></pre>\\n<p>There are two basic levels of organization in Storybook. The component and its child stories. Think of each story as a permutation of a component. You can have as many stories per component as you need.</p>\\n<ul>\\n<li>\\n<p><strong>Component</strong></p>\\n<ul>\\n<li>Story</li>\\n<li>Story</li>\\n<li>Story</li>\\n</ul>\\n</li>\\n</ul>\\n<p>To initiate Storybook we first call the <code>storiesOf()</code> function to register the component. We add a display name for the component –the name that appears on the sidebar in the Storybook app.</p>\\n<p><code>action()</code> allows us to create a callback that appears in the <strong>actions</strong> panel of the Storybook UI when clicked. So when we build a pin button, we’ll be able to determine in the test UI if a button click is successful.</p>\\n<p>As we need to pass the same set of actions to all permutations of our component, it is convenient to bundle them up into a single <code>actions</code> variable and use React's <code>{...actions}</code> props expansion to pass them all at once. <code>&#x3C;Task {...actions}></code> is equivalent to <code>&#x3C;Task onPinTask={actions.onPinTask} onArchiveTask={actions.onArchiveTask}></code>.</p>\\n<p>Another nice thing about bundling the <code>actions</code> that a component needs is that you can <code>export</code> them and use them in stories for components that reuse this component, as we'll see later.</p>\\n<p>To define our stories, we call <code>add()</code> once for each of our test states to generate a story. The action story is a function that returns a rendered element (i.e. a component class with a set of props) in a given state---exactly like a React <a href=\\\"https://reactjs.org/docs/components-and-props.html\\\">Stateless Functional Component</a>.</p>\\n<p>When creating a story we use a base task (<code>task</code>) to build out the shape of the task the component expects. This is typically modelled from what the true data looks like. Again, <code>export</code>-ing this shape will enable us to reuse it in later stories, as we'll see.</p>\\n<div class=\\\"aside\\\">\\n<a href=\\\"https://storybook.js.org/addons/introduction/#2-native-addons\\\"><b>Actions</b></a> help you verify interactions when building UI components in isolation. Oftentimes you won't have access to the functions and state you have in context of the app. Use <code>action()</code> to stub them in.\\n</div>\\n<h2>Config</h2>\\n<p>We also have to make one small change to the Storybook configuration setup (<code>.storybook/config.js</code>) so it notices our <code>.stories.js</code> files and uses our CSS file. By default Storybook looks for stories in a <code>/stories</code> directory; this tutorial uses a naming scheme that is similar to the <code>.test.js</code> naming scheme favoured by CRA for automated tests.</p>\\n<pre><code class=\\\"language-javascript\\\">import { configure } from '@storybook/react';\\nimport '../src/index.css';\\n\\nconst req = require.context('../src', true, /.stories.js$/);\\n\\nfunction loadStories() {\\n  req.keys().forEach(filename => req(filename));\\n}\\n\\nconfigure(loadStories, module);\\n</code></pre>\\n<p>Once we’ve done this, restarting the Storybook server should yield test cases for the three Task states:</p>\\n<video autoPlay muted playsInline controls >\\n  <source\\n    src=\\\"/inprogress-task-states.mp4\\\"\\n    type=\\\"video/mp4\\\"\\n  />\\n</video>\\n<h2>Build out the states</h2>\\n<p>Now we have Storybook setup, styles imported, and test cases built out, we can quickly start the work of implementing the HTML of the component to match the design.</p>\\n<p>The component is still basic at the moment. First write the code that achieves the design without going into too much detail:</p>\\n<pre><code class=\\\"language-javascript\\\">import React from 'react';\\n\\nexport default function Task({ task: { id, title, state }, onArchiveTask, onPinTask }) {\\n  return (\\n    &#x3C;div className={`list-item ${state}`}>\\n      &#x3C;label className=\\\"checkbox\\\">\\n        &#x3C;input\\n          type=\\\"checkbox\\\"\\n          defaultChecked={state === 'TASK_ARCHIVED'}\\n          disabled={true}\\n          name=\\\"checked\\\"\\n        />\\n        &#x3C;span className=\\\"checkbox-custom\\\" onClick={() => onArchiveTask(id)} />\\n      &#x3C;/label>\\n      &#x3C;div className=\\\"title\\\">\\n        &#x3C;input type=\\\"text\\\" value={title} readOnly={true} placeholder=\\\"Input title\\\" />\\n      &#x3C;/div>\\n\\n      &#x3C;div className=\\\"actions\\\" onClick={event => event.stopPropagation()}>\\n        {state !== 'TASK_ARCHIVED' &#x26;&#x26; (\\n          &#x3C;a onClick={() => onPinTask(id)}>\\n            &#x3C;span className={`icon-star`} />\\n          &#x3C;/a>\\n        )}\\n      &#x3C;/div>\\n    &#x3C;/div>\\n  );\\n}\\n</code></pre>\\n<p>The additional markup from above combined with the CSS we imported earlier yields the following UI:</p>\\n<video autoPlay muted playsInline loop>\\n  <source\\n    src=\\\"/finished-task-states.mp4\\\"\\n    type=\\\"video/mp4\\\"\\n  />\\n</video>\\n<h2>Specify data requirements</h2>\\n<p>It’s best practice to use <code>propTypes</code> in React to specify the shape of data that a component expects. Not only is it self documenting, it also helps catch problems early.</p>\\n<pre><code class=\\\"language-javascript\\\">import React from 'react';\\nimport PropTypes from 'prop-types';\\n\\nfunction Task() {\\n  ...\\n}\\n\\nTask.propTypes = {\\n  task: PropTypes.shape({\\n    id: PropTypes.string.isRequired,\\n    title: PropTypes.string.isRequired,\\n    state: PropTypes.string.isRequired,\\n  }),\\n  onArchiveTask: PropTypes.func,\\n  onPinTask: PropTypes.func,\\n};\\n\\nexport default Task;\\n</code></pre>\\n<p>Now a warning in development will appear if the Task component is misused.</p>\\n<div class=\\\"aside\\\">\\nAn alternative way to achieve the same purpose is to use a JavaScript type system like TypeScript to create a type for the component properties.\\n</div>\\n<h2>Component built!</h2>\\n<p>We’ve now successfully built out a component without needing a server or running the entire frontend application. The next step is to build out the remaining Taskbox components one by one in a similar fashion.</p>\\n<p>As you can see, getting started building components in in isolation is easy and fast. We can expect to produce a higher-quality UI with less bugs and more polish because it’s possible to dig in and test every possible state.</p>\\n<h2>Automated Testing</h2>\\n<p>Storybook gave us a great way to visually test our application during construction. The ‘stories’ will help ensure we don’t break our Task visually as we continue to develop the app. However, it is a completely manual process at this stage, and someone has to go to the effort of clicking through each test state and ensuring it renders well and without errors or warnings. Can’t we do that automatically?</p>\\n<h3>Snapshot testing</h3>\\n<p>Snapshot testing refers to the practice of recording the “known good” output of a component for a given input and then flagging the component whenever the output changes in future. This complements Storybook, because it’s a quick way to view the new version of a component and check out the changes.</p>\\n<div class=\\\"aside\\\">\\nMake sure your components render data that doesn't change, so that your snapshot tests won't fail each time. Watch out for things like dates or randomly generated values.\\n</div>\\n<p>With the <a href=\\\"https://github.com/storybooks/storybook/tree/master/addons/storyshots\\\">Storyshots addon</a> a snapshot test is created for each of the stories. Use it by adding a development dependency on the package:</p>\\n<pre><code class=\\\"language-bash\\\">yarn add --dev @storybook/addon-storyshots react-test-renderer\\n</code></pre>\\n<p>Then create an <code>src/storybook.test.js</code> file with the following in it:</p>\\n<pre><code class=\\\"language-javascript\\\">import initStoryshots from '@storybook/addon-storyshots';\\ninitStoryshots();\\n</code></pre>\\n<p>Once the above is done, we can run <code>yarn test</code> and see the following output:</p>\\n<p><img src=\\\"/task-testrunner.png\\\" alt=\\\"Task test runner\\\"></p>\\n<p>We now have a snapshot test for each of our <code>Task</code> stories. If we change the implementation of <code>Task</code>, we’ll be prompted to verify the changes.</p>\",\"excerpt\":\"Build a simple component We’ll build our UI following a  Component-Driven Development  (CDD) methodology. It’s a process that builds UIs from the “bottom up” starting with components and ending with screens. CDD helps you scale the amount of…\",\"frontmatter\":{\"path\":null,\"title\":\"Build a simple component\"}}},{\"node\":{\"id\":\"/Users/luz/code/js/binstd.github.io/markdown/docs/en/test.md absPath of file >>> MarkdownRemark\",\"html\":\"<h1>Test UI components</h1>\\n<p>No Storybook tutorial would be complete without testing. Testing is essential to creating high quality UIs. In modular systems, miniscule tweaks can result in major regressions. So far we encountered three types of tests:</p>\\n<ul>\\n<li><strong>Visual tests</strong> rely on developers to manually look at a component to verify it for correctness. They help us sanity check a component’s appearance as we build.</li>\\n<li><strong>Snapshot tests</strong> with Storyshots capture a component’s rendered markup. They help us stay abreast of markup changes that cause rendering errors and warnings.</li>\\n<li><strong>Unit tests</strong> with Jest verify that the output of a component remains the same given an fixed input. They’re great for testing the functional qualities of a component.</li>\\n</ul>\\n<h2>“But does it look right?”</h2>\\n<p>Unfortunately, the aforementioned testing methods alone aren’t enough to prevent UI bugs. UIs are tricky to test because design is subjective and nuanced. Visual tests are too manual, snapshot tests trigger too many false positives when used for UI, and pixel-level unit tests are poor value. A complete Storybook testing strategy also includes visual regression tests.</p>\\n<h2>Visual regression testing for Storybook</h2>\\n<p>Visual regression tests are designed to catch changes in appearance. They work by capturing screenshots of every story and comparing them commit-to-commit to surface changes. This is perfect for verifying graphical elements like layout, color, size, and contrast.</p>\\n<video autoPlay muted playsInline loop style=\\\"width:480px; margin: 0 auto;\\\">\\n  <source\\n    src=\\\"/visual-regression-testing.mp4\\\"\\n    type=\\\"video/mp4\\\"\\n  />\\n</video>\\n<p>Storybook is a fantastic tool for visual regression testing because every story is essentially a test specification. Each time we write or update a story we get a spec for free!</p>\\n<p>There are a number of tools for visual regression testing. For professional teams we recommend <a href=\\\"https://www.chromaticqa.com/\\\"><strong>Chromatic</strong></a>, an addon made by Storybook maintainers that runs tests in the cloud.</p>\\n<h2>Setup visual regression testing</h2>\\n<p>Chromatic is a hassle-free Storybook addon for visual regression testing and review in the cloud. Since it’s a paid service (with a free trial), it may not be for everyone. However, Chromatic is an instructive example of a production visual testing workflow that we'll try out for free. Let’s have a look.</p>\\n<h3>Initiate Git</h3>\\n<p>First you want to setup Git for your project in the local directory. Chromatic uses Git history to keep track of your UI components.</p>\\n<pre><code class=\\\"language-bash\\\">$ git init\\n</code></pre>\\n<p>Next add files to the first commit.</p>\\n<pre><code class=\\\"language-bash\\\">$ git add .\\n</code></pre>\\n<p>Now commit the files.</p>\\n<pre><code class=\\\"language-bash\\\">$ git commit -m \\\"taskbox UI\\\"\\n</code></pre>\\n<h3>Get Chromatic</h3>\\n<p>Add the package as a dependency.</p>\\n<pre><code class=\\\"language-bash\\\">yarn add storybook-chromatic\\n</code></pre>\\n<p>Import Chromatic in your <code>.storybook/config.js</code> file.</p>\\n<pre><code class=\\\"language-javascript\\\">import { configure } from '@storybook/react';\\nimport 'storybook-chromatic/storybook-addon';\\n\\nimport '../src/index.css';\\n\\nconst req = require.context('../src/components', true, /\\\\.stories\\\\.js$/);\\n\\nfunction loadStories() {\\n  req.keys().forEach(filename => req(filename));\\n}\\n\\nconfigure(loadStories, module);\\n</code></pre>\\n<p>Then <a href=\\\"https://chromaticqa.com/start\\\">login to Chromatic</a> with your GitHub account (Chromatic only asks for lightweight permissions). Create a project with name \\\"taskbox\\\" and copy your unique <code>app-code</code>.</p>\\n<video autoPlay muted playsInline loop style=\\\"width:520px; margin: 0 auto;\\\">\\n  <source\\n    src=\\\"/chromatic-setup-learnstorybook.mp4\\\"\\n    type=\\\"video/mp4\\\"\\n  />\\n</video>\\n<p>Run the test command in the command line to setup visual regression tests for Storybook. Don't forget to add your unique app code in place of <code>&#x3C;app-code></code>.</p>\\n<pre><code class=\\\"language-bash\\\">./node_modules/.bin/chromatic test --storybook-addon --app-code=&#x3C;app-code> --do-not-start\\n</code></pre>\\n<div class=\\\"aside\\\">\\n<code>--do-not-start</code> is an option that tells Chromatic not to start Storybook. Use this if you already have Storybook running. If not omit <code>--do-not-start</code>.\\n</div>\\n<p>Once the first test is complete, we have test baselines for each story. In other words, screenshots of each story known to be “good”. Future changes to those stories will be compared to the baselines.</p>\\n<p><img src=\\\"/chromatic-baselines.png\\\" alt=\\\"Chromatic baselines\\\"></p>\\n<h2>Catch a UI change</h2>\\n<p>Visual regression testing relies on comparing images of the new rendered UI code to the baseline images. If a UI change is caught you get notified. See how it works by tweaking the background of the <code>Task</code> component:</p>\\n<p><img src=\\\"/chromatic-change-to-task-component.png\\\" alt=\\\"code change\\\"></p>\\n<p>This yields a new background color for the item.</p>\\n<p><img src=\\\"/chromatic-task-change.png\\\" alt=\\\"task background change\\\"></p>\\n<p>Use the test command from earlier to run another Chromatic test.</p>\\n<pre><code class=\\\"language-bash\\\">./node_modules/.bin/chromatic test --storybook-addon --app-code=&#x3C;app-code> --do-not-start\\n</code></pre>\\n<p>Follow the link to the web UI where you’ll see changes.</p>\\n<p><img src=\\\"/chromatic-catch-changes.png\\\" alt=\\\"UI changes in Chromatic\\\"></p>\\n<p>There are a lot of changes! The component hierarchy where <code>Task</code> is a child of <code>TaskList</code> and <code>Inbox</code> means one small tweak snowballs into major regressions. This circumstance is precisely why developers need visual regression testing in addition to other testing methods.</p>\\n<p><img src=\\\"/minor-major-regressions.gif\\\" alt=\\\"UI minor tweaks major regressions\\\"></p>\\n<h2>Review changes</h2>\\n<p>Visual regression testing ensures components dont change by accident. But it’s still up to you to determine whether changes are intentional or not.</p>\\n<p>If a change is intentional you need to update the baseline so that future tests are compared to the latest version of the story. If a change is unintentional it needs to be fixed.</p>\\n<video autoPlay muted playsInline loop style=\\\"width:480px; margin: 0 auto;\\\">\\n  <source\\n    src=\\\"/website-workflow-review-merge-optimized.mp4\\\"\\n    type=\\\"video/mp4\\\"\\n  />\\n</video>\\n<p>Since modern apps are constructed from components, it’s important that we test at the level of component. Doing so helps us pinpoint the root cause of a change, the component, instead of reacting to symptoms of a change, the screens and composite components.</p>\\n<h2>Merge changes</h2>\\n<p>When we’ve finished reviewing we’re ready to merge UI changes with confidence --knowing that updates won’t accidentally introduce bugs. If you like the new <code>papayawhip</code> background then accept the changes, if not revert to the previous state.</p>\\n<p><img src=\\\"/chromatic-review-finished.png\\\" alt=\\\"Changes ready to be merged\\\"></p>\\n<p>Storybook helps you <strong>build</strong> components; testing helps you <strong>maintain</strong> them. The four types of UI testing are covered in this tutorial are visual, snapshot, unit, and visual regression testing. You can automate the last three by adding them to your CI script. This helps you ship components without worrying about stowaway bugs. The whole workflow is illustrated below.</p>\\n<p><img src=\\\"/cdd-review-workflow.png\\\" alt=\\\"Visual regression testing workflow\\\"></p>\",\"excerpt\":\"Test UI components No Storybook tutorial would be complete without testing. Testing is essential to creating high quality UIs. In modular systems, miniscule tweaks can result in major regressions. So far we encountered three types of tests: Visual…\",\"frontmatter\":{\"path\":null,\"title\":\"Testing\"}}},{\"node\":{\"id\":\"/Users/luz/code/js/binstd.github.io/markdown/docs/es/composite-component.md absPath of file >>> MarkdownRemark\",\"html\":\"<h1>Ensamblar un componente compuesto</h1>\\n<p>En el último capítulo construimos nuestro primer componente; este capítulo extiende lo que aprendimos para construir TaskList, una lista de Tareas. Combinemos componentes en conjunto y veamos qué sucede cuando se añade más complejidad.</p>\\n<h2>Lista de Tareas</h2>\\n<p>Taskbox enfatiza las tareas ancladas colocándolas por encima de las tareas predeterminadas. Esto produce dos variaciones de <code>TaskList</code> para las que necesita crear historias: ítems por defecto e ítems por defecto y anclados.</p>\\n<p><img src=\\\"/tasklist-states-1.png\\\" alt=\\\"default and pinned tasks\\\"></p>\\n<p>Dado que los datos de <code>Tareas</code> pueden enviarse asincrónicamente, <strong>también</strong> necesitamos un estado de cargando para renderizar en ausencia de alguna conexión. Además, también se requiere un estado vacío para cuando no hay tareas.</p>\\n<p><img src=\\\"/tasklist-states-2.png\\\" alt=\\\"empty and loading tasks\\\"></p>\\n<h2>Empezar la configuración</h2>\\n<p>Un componente compuesto no es muy diferente de los componentes básicos que contiene. Crea un componente <code>TaskList</code> y un archivo de historia que lo acompañe: <code>src/components/TaskList.js</code> y <code>src/components/TaskList.stories.js</code>.</p>\\n<p>Comienza con una implementación aproximada de la <code>TaskList</code>. Necesitarás importar el componente <code>Tareas</code> del capítulo anterior y pasarle los atributos y acciones como entrada.</p>\\n<pre><code class=\\\"language-javascript\\\">import React from 'react';\\n\\nimport Task from './Task';\\n\\nfunction TaskList({ loading, tasks, onPinTask, onArchiveTask }) {\\n  const events = {\\n    onPinTask,\\n    onArchiveTask,\\n  };\\n\\n  if (loading) {\\n    return &#x3C;div className=\\\"list-items\\\">loading&#x3C;/div>;\\n  }\\n\\n  if (tasks.length === 0) {\\n    return &#x3C;div className=\\\"list-items\\\">empty&#x3C;/div>;\\n  }\\n\\n  return (\\n    &#x3C;div className=\\\"list-items\\\">\\n      {tasks.map(task => &#x3C;Task key={task.id} task={task} {...events} />)}\\n    &#x3C;/div>\\n  );\\n}\\n\\nexport default TaskList;\\n</code></pre>\\n<p>A continuación, crea los estados de prueba de <code>Tasklist</code> en el archivo de historia.</p>\\n<pre><code class=\\\"language-javascript\\\">import React from 'react';\\nimport { storiesOf } from '@storybook/react';\\n\\nimport TaskList from './TaskList';\\nimport { createTask, actions } from './Task.stories';\\n\\nexport const defaultTasks = [\\n  createTask({ state: 'TASK_INBOX' }),\\n  createTask({ state: 'TASK_INBOX' }),\\n  createTask({ state: 'TASK_INBOX' }),\\n  createTask({ state: 'TASK_INBOX' }),\\n  createTask({ state: 'TASK_INBOX' }),\\n  createTask({ state: 'TASK_INBOX' }),\\n];\\n\\nexport const withPinnedTasks = [\\n  createTask({ title: 'Task 1', state: 'TASK_INBOX' }),\\n  createTask({ title: 'Task 2', state: 'TASK_INBOX' }),\\n  createTask({ title: 'Task 3', state: 'TASK_INBOX' }),\\n  createTask({ title: 'Task 4', state: 'TASK_INBOX' }),\\n  createTask({ title: 'Task 5', state: 'TASK_INBOX' }),\\n  createTask({ title: 'Task 6 (pinned)', state: 'TASK_PINNED' }),\\n];\\n\\nstoriesOf('TaskList', module)\\n  .addDecorator(story => &#x3C;div style={{ padding: '3rem' }}>{story()}&#x3C;/div>)\\n  .add('default', () => &#x3C;TaskList tasks={defaultTasks} {...actions} />)\\n  .add('withPinnedTasks', () => &#x3C;TaskList tasks={withPinnedTasks} {...actions} />)\\n  .add('loading', () => &#x3C;TaskList loading tasks={[]} {...actions} />)\\n  .add('empty', () => &#x3C;TaskList tasks={[]} {...actions} />);\\n</code></pre>\\n<p><code>addDecorator()</code> nos permite añadir algún \\\"contexto\\\" al renderizado de cada tarea. En este caso añadimos relleno alrededor de la lista para que sea más fácil de verificar visualmente.</p>\\n<div class=\\\"aside\\\">\\nLos <a href=\\\"https://storybook.js.org/addons/introduction/#1-decorators\\\"><b>Decoradores</b></a> son una forma de proporcionar envoltorios arbitrarios a las historias. En este caso estamos usando un decorador para añadir estilo. También se pueden utilizar para envolver historias en \\\"proveedores\\\", es decir, componentes de la librebría que establecen el contexto de React.\\n</div>\\n<p><code>createTask()</code> es una función de ayuda que genera la forma de una Tarea que creamos y exportamos desde el archivo <code>Task.stories.js</code>. De manera similar, las <code>acciones</code> exportadas de <code>Task.stories.js</code> definieron las acciones (comunmente llamadas mockeadas) que espera un componente <code>Task</code>, el cual también necesita la <code>TaskList</code>.</p>\\n<p>Ahora revise Storybook para ver las nuevas historias de la lista de tareas.</p>\\n<video autoPlay muted playsInline loop>\\n  <source\\n    src=\\\"/inprogress-tasklist-states.mp4\\\"\\n    type=\\\"video/mp4\\\"\\n  />\\n</video>\\n<h2>Construir los estados</h2>\\n<p>Nuestro componente sigue siendo muy rudimentario, pero ahora tenemos una idea de las historias en las que trabajaremos. Podrías estar pensando que el envoltorio de <code>.list-items</code> es demasiado simplista. Tienes razón, en la mayoría de los casos no crearíamos un nuevo componente sólo para añadir un envoltorio. Pero la <strong>complejidad real</strong> del componente <code>TaskList</code> se revela en los casos extremos <code>withPinnedTasks</code>, <code>loading</code>, y <code>empty</code>.</p>\\n<pre><code class=\\\"language-javascript\\\">import React from 'react';\\n\\nimport Task from './Task';\\n\\nfunction TaskList({ loading, tasks, onPinTask, onArchiveTask }) {\\n  const events = {\\n    onPinTask,\\n    onArchiveTask,\\n  };\\n\\n  const LoadingRow = (\\n    &#x3C;div className=\\\"loading-item\\\">\\n      &#x3C;span className=\\\"glow-checkbox\\\" />\\n      &#x3C;span className=\\\"glow-text\\\">\\n        &#x3C;span>Loading&#x3C;/span> &#x3C;span>cool&#x3C;/span> &#x3C;span>state&#x3C;/span>\\n      &#x3C;/span>\\n    &#x3C;/div>\\n  );\\n\\n  if (loading) {\\n    return (\\n      &#x3C;div className=\\\"list-items\\\">\\n        {LoadingRow}\\n        {LoadingRow}\\n        {LoadingRow}\\n        {LoadingRow}\\n        {LoadingRow}\\n        {LoadingRow}\\n      &#x3C;/div>\\n    );\\n  }\\n\\n  if (tasks.length === 0) {\\n    return (\\n      &#x3C;div className=\\\"list-items\\\">\\n        &#x3C;div className=\\\"wrapper-message\\\">\\n          &#x3C;span className=\\\"icon-check\\\" />\\n          &#x3C;div className=\\\"title-message\\\">You have no tasks&#x3C;/div>\\n          &#x3C;div className=\\\"subtitle-message\\\">Sit back and relax&#x3C;/div>\\n        &#x3C;/div>\\n      &#x3C;/div>\\n    );\\n  }\\n\\n  const tasksInOrder = [\\n    ...tasks.filter(t => t.state === 'TASK_PINNED'),\\n    ...tasks.filter(t => t.state !== 'TASK_PINNED'),\\n  ];\\n\\n  return (\\n    &#x3C;div className=\\\"list-items\\\">\\n      {tasksInOrder.map(task => &#x3C;Task key={task.id} task={task} {...events} />)}\\n    &#x3C;/div>\\n  );\\n}\\n\\nexport default TaskList;\\n</code></pre>\\n<p>El etiquetado añadido da como resultado la siguiente interfaz de usuario:</p>\\n<video autoPlay muted playsInline loop>\\n  <source\\n    src=\\\"/finished-tasklist-states.mp4\\\"\\n    type=\\\"video/mp4\\\"\\n  />\\n</video>\\n<p>Observa la posición del elemento anclado en la lista. Queremos que el elemento anclado se muestre en la parte superior de la lista para que sea prioritario para nuestros usuarios.</p>\\n<h2>Requisitos de data y props</h2>\\n<p>A medida que el componente crece, también lo hacen los parámetros de entrada requeridos de <code>TaskList</code>. Define las props requeridas de <code>TaskList</code>. Debido a que <code>Task</code> es un componente hijo, asegúrate de proporcionar los datos en la forma correcta para renderizarlo. Para ahorrar tiempo y dolores de cabeza, reutiliza los propTypes que definiste en <code>Tareas</code> anteriormente.</p>\\n<pre><code class=\\\"language-javascript\\\">import React from 'react';\\nimport PropTypes from 'prop-types';\\n\\nfunction TaskList() {\\n  ...\\n}\\n\\n\\nTaskList.propTypes = {\\n  loading: PropTypes.bool,\\n  tasks: PropTypes.arrayOf(Task.propTypes.task).isRequired,\\n  onPinTask: PropTypes.func.isRequired,\\n  onArchiveTask: PropTypes.func.isRequired,\\n};\\n\\nTaskList.defaultProps = {\\n  loading: false,\\n};\\n\\nexport default TaskList;\\n</code></pre>\\n<h2>Pruebas automatizadas</h2>\\n<p>En el capítulo anterior aprendimos a capturar historias de prueba utilizando Storyshots. Con el componente <code>Task</code> no había mucha complejidad para probar más allá de que se renderice correctamente. Dado que <code>TaskList</code> añade otra capa de complejidad, queremos verificar que ciertas entradas produzcan ciertas salidas de una manera adecuada con pruebas automáticas. Para hacer esto crearemos test unitarios utilizando <a href=\\\"https://facebook.github.io/jest/\\\">Jest</a> junto con un renderizador de prueba como <a href=\\\"http://airbnb.io/enzyme/\\\">Enzyme</a>.</p>\\n<p><img src=\\\"/logo-jest.png\\\" alt=\\\"Jest logo\\\"></p>\\n<h3>Test unitarios con Jest</h3>\\n<p>Las historias de Storybook combinadas con pruebas visuales manuales y pruebas de instantáneas (ver arriba) ayudan mucho a evitar errores de interfaz de usuario. Si las historias cubren una amplia variedad de casos de uso de los componentes, y utilizamos herramientas que aseguran que un humano compruebe cualquier cambio en la historia, los errores son mucho menos probables.</p>\\n<p>Sin embargo, a veces el diablo está en los detalles. Se necesita un framework de pruebas que sea explícito sobre esos detalles. Lo que nos lleva a hacer pruebas unitarias.</p>\\n<p>En nuestro caso, queremos que nuestra <code>TaskList</code> muestre cualquier tarea anclada <strong>antes de</strong> las tareas no ancladas que sean pasadas en la prop <code>tasks</code>. Aunque tenemos una historia (<code>withPinnedTasks</code>) para probar este escenario exacto; puede ser ambiguo para un revisor humano que si el componente <strong>no</strong> ordena las tareas de esta manera, es un error. Ciertamente no gritará <strong>\\\"¡Mal!\\\"</strong> para el ojo casual.</p>\\n<p>Por lo tanto, para evitar este problema, podemos usar Jest para renderizar la historia en el DOM y ejecutar algún código de consulta del DOM para verificar las características salientes del resultado.</p>\\n<p>Crea un archivo de prueba llamado <code>Task.test.js</code>. Aquí vamos a construir nuestras pruebas que hacen afirmaciones acerca del resultado.</p>\\n<pre><code class=\\\"language-javascript\\\">import React from 'react';\\nimport ReactDOM from 'react-dom';\\nimport TaskList from './TaskList';\\nimport { withPinnedTasks } from './TaskList.stories';\\n\\nit('renders pinned tasks at the start of the list', () => {\\n  const div = document.createElement('div');\\n  const events = { onPinTask: jest.fn(), onArchiveTask: jest.fn() };\\n  ReactDOM.render(&#x3C;TaskList tasks={withPinnedTasks} {...events} />, div);\\n\\n  // Esperamos que la tarea titulada \\\"Tarea 6 (anclada)\\\" se ejecute primero, no al final.\\n  const lastTaskInput = div.querySelector('.list-item:nth-child(1) input[value=\\\"Task 6 (pinned)\\\"]');\\n  expect(lastTaskInput).not.toBe(null);\\n\\n  ReactDOM.unmountComponentAtNode(div);\\n});\\n</code></pre>\\n<p><img src=\\\"/tasklist-testrunner.png\\\" alt=\\\"TaskList test runner\\\"></p>\\n<p>Nota que hemos sido capaces de reutilizar la lista de tareas <code>withPinnedTasks</code> tanto en la prueba de la historia como en el test unitario; de esta manera podemos continuar aprovechando un recurso existente (los ejemplos que representan configuraciones interesantes de un componente) de más y más maneras.</p>\\n<p>Note también que esta prueba es bastante frágil. Es posible que a medida que el proyecto madure y que la implementación exacta de la <code>Tarea</code> cambie --quizás usando un nombre de clase diferente o un \\\"área de texto\\\" en lugar de un \\\"input\\\" en el etiquetado-- la prueba falle y necesite ser actualizada. Esto no es necesariamente un problema, sino más bien una indicación de que hay que ser bastante cuidadoso usando pruebas unitarias para la UI. No son fáciles de mantener. En su lugar, confía en las pruebas visuales, de instantáneas y de regresión visual (mira el <a href=\\\"/test/\\\">capitulo sobre las pruebas</a>) siempre que te sea posible.</p>\",\"excerpt\":\"Ensamblar un componente compuesto En el último capítulo construimos nuestro primer componente; este capítulo extiende lo que aprendimos para construir TaskList, una lista de Tareas. Combinemos componentes en conjunto y veamos qué sucede cuando se…\",\"frontmatter\":{\"path\":null,\"title\":\"Ensamblar un componente compuesto\"}}},{\"node\":{\"id\":\"/Users/luz/code/js/binstd.github.io/markdown/docs/es/conclusion.md absPath of file >>> MarkdownRemark\",\"html\":\"<h1>Conclusion</h1>\\n<p>Felicitaciones! Creaste tu primer interfaz de usuario en Storybook. En el camino, aprendiste a construir, componer, probar e implementar componentes de interfaz de usuario. Si lo has estado siguiendo, tu repositorio y Storybook desplegado debería verse así:</p>\\n<p><a href=\\\"https://github.com/hichroma/learnstorybook-code\\\">📕 <strong>Repositorio de GitHub: hichroma/learnstorybook-code</strong></a>\\n<br/>\\n<a href=\\\"https://clever-banach-415c03.netlify.com/\\\">🌎 <strong>Storybook Desplegado</strong></a></p>\\n<p>Storybook es una poderosa herramienta para React, Vue y Angular. Cuenta con una próspera comunidad de desarrolladores y una gran cantidad de complementos. Esta introducción nos lleva superficialmente a lo que es posible. Estamos seguros de que una vez que adoptes Storybook, quedarás impresionado por lo productivo que es crear interfaces de usuario duraderas.</p>\\n<h2>Aprende más</h2>\\n<p>Quieres bucear más profundo? Aquí algunos recursos útiles:</p>\\n<ul>\\n<li>\\n<p><a href=\\\"https://storybook.js.org/basics/introduction/\\\"><strong>Documentación oficial de Storybook</strong></a> tiene la documentación del API, links comunitarios y una galería de complementos.</p>\\n</li>\\n<li>\\n<p><strong>El delicioso flujo de trabajo de Storybook</strong> (Próximamente!) destaca las mejores prácticas del flujo de trabajo utilizado por equipos de alta velocidad en Squarespace, Major League Soccer y Apollo GraphQL.</p>\\n</li>\\n<li>\\n<p><a href=\\\"https://www.chromaticqa.com/book/visual-testing-handbook\\\"><strong>Manual de pruebas visuales</strong></a> se sumerge profundamente en el uso de Storybook para probar componentes visuales. Libro electrónico gratuito de 31 páginas.</p>\\n</li>\\n</ul>\\n<h2>Quién hizo LearnStorybook.com?</h2>\\n<p>El texto, código, y producción fueron contribuidos por <a href=\\\"http://blog.hichroma.com/\\\">Chroma</a>. Los tutoriales fueron inspirados por la popular <a href=\\\"https://blog.hichroma.com/graphql-react-tutorial-part-1-6-d0691af25858\\\">serie de tutoriales GraphQL + React</a> de Chroma.</p>\\n<p>Quieres más tutoriales y artículos como este? Regístratate a la lista de correo de Chroma.</p>\\n<iframe style=\\\"height:400px;width:100%;max-width:800px;margin:30px auto;\\\" src=\\\"https://upscri.be/bface0?as_embed\\\"></iframe>\",\"excerpt\":\"Conclusion Felicitaciones! Creaste tu primer interfaz de usuario en Storybook. En el camino, aprendiste a construir, componer, probar e implementar componentes de interfaz de usuario. Si lo has estado siguiendo, tu repositorio y Storybook desplegado…\",\"frontmatter\":{\"path\":null,\"title\":\"Conclusion\"}}},{\"node\":{\"id\":\"/Users/luz/code/js/binstd.github.io/markdown/docs/es/contribute.md absPath of file >>> MarkdownRemark\",\"html\":\"<h1>Contribuir</h1>\\n<p>Contribuciones para aprender Storybook son bienvenidas! Si se trata de algo pequeño como gramática o puntuación, abre un pull request. Si es un cambio más grande, <a href=\\\"https://github.com/hichroma/learnstorybook.com/issues\\\">agrega un issue</a> para discutirlo.</p>\\n<h2>Ediciones de Vue y Angular</h2>\\n<p>Estamos buscando ayuda para actualizar nuestro código de ejemplo de React/Redux a Vue y Angular. Comenta en el issue sobre <a href=\\\"https://github.com/hichroma/learnstorybook.com/issues/1\\\">Vue</a> o sobre <a href=\\\"https://github.com/hichroma/learnstorybook.com/issues/2\\\">Angular</a>.</p>\\n<p><img src=\\\"/logos-angular-vue.png\\\" alt=\\\"Vue and Angular contributors wanted\\\"></p>\\n<h2>Traducciones</h2>\\n<p>Nuestro objetivo es hacer que Storybook sea accesible a todas las personas. Ayuda a traducir este tutorial a otros idiomas. Estamos especialmente abiertos a traducciones al chino y al japonés. Comenta en <a href=\\\"https://github.com/hichroma/learnstorybook.com/issues/3\\\">este issue</a> si deseas ayudar.</p>\",\"excerpt\":\"Contribuir Contribuciones para aprender Storybook son bienvenidas! Si se trata de algo pequeño como gramática o puntuación, abre un pull request. Si es un cambio más grande,  agrega un issue  para discutirlo. Ediciones de Vue y Angular Estamos…\",\"frontmatter\":{\"path\":null,\"title\":\"Contribuir\"}}},{\"node\":{\"id\":\"/Users/luz/code/js/binstd.github.io/markdown/docs/es/data.md absPath of file >>> MarkdownRemark\",\"html\":\"<h1>Introducir datos</h1>\\n<p>Hasta ahora hemos creado componentes aislados sin estado, muy útiles para Storybook, pero finalmente no son útiles hasta que les proporcionemos algunos datos en nuestra aplicación.</p>\\n<p>Este tutorial no se centra en los detalles de la construcción de una aplicación, por lo que no profundizaremos en esos detalles aquí. Pero, nos tomaremos un momento para observar un patrón común para introducir datos con componentes contenedores.</p>\\n<h2>Componentes contenedores</h2>\\n<p>Nuestro componente <code>TaskList</code> como lo hemos escrito es de “presentación” (ver <a href=\\\"https://medium.com/@dan_abramov/smart-and-dumb-components-7ca2f9a7c7d0\\\">artículo al respecto</a>), en el sentido que no se comunica con nada externo a su implementación. Para poder pasarle datos, necesitaremos un \\\"contenedor\\\".</p>\\n<p>Este ejemplo utiliza <a href=\\\"https://redux.js.org/\\\">Redux</a>, la librería mas popular de React para almacenar datos, que básicamente nos permite crear un modelo simple de datos para la aplicación. De todos modos, el patrón que utilizaremos también se aplica a otras librerías de manejo de datos como <a href=\\\"https://www.apollographql.com/client/\\\">Apollo</a> y <a href=\\\"https://mobx.js.org/\\\">MobX</a>.</p>\\n<p>Primero construiremos un simple store Redux que responde a acciones que cambian el estado de una tarea, en un archivo llamado <code>lib/redux.js</code>, (intencionalmente lo mantendremos simple):</p>\\n<pre><code class=\\\"language-javascript\\\">// Una implementación simple de los store/actions/reducer de Redux.\\n// Una verdadera aplicación sería más compleja y se dividiría en diferentes archivos.\\nimport { createStore } from 'redux';\\n\\n// Las acciones son los \\\"nombres\\\" de los cambios que pueden ocurrir en el store.\\nexport const actions = {\\n  ARCHIVE_TASK: 'ARCHIVE_TASK',\\n  PIN_TASK: 'PIN_TASK',\\n};\\n\\n// Los creadores de acciones son la forma en que se agrupan las acciones con los datos necesarios para ejecutarlas.\\nexport const archiveTask = id => ({ type: actions.ARCHIVE_TASK, id });\\nexport const pinTask = id => ({ type: actions.PIN_TASK, id });\\n\\n// Todos nuestros reducers simplemente cambian el estado de una sola tarea.\\nfunction taskStateReducer(taskState) {\\n  return (state, action) => {\\n    return {\\n      ...state,\\n      tasks: state.tasks.map(\\n        task => (task.id === action.id ? { ...task, state: taskState } : task)\\n      ),\\n    };\\n  };\\n}\\n\\n// El reducer describe como los contenidos del store cambian por cada acción.\\nexport const reducer = (state, action) => {\\n  switch (action.type) {\\n    case actions.ARCHIVE_TASK:\\n      return taskStateReducer('TASK_ARCHIVED')(state, action);\\n    case actions.PIN_TASK:\\n      return taskStateReducer('TASK_PINNED')(state, action);\\n    default:\\n      return state;\\n  }\\n};\\n\\n// El estado inicial de nuestro store cuando la app carga.\\n// Usualmente obtendrías esto de un servidor.\\nconst defaultTasks = [\\n  { id: '1', title: 'Something', state: 'TASK_INBOX' },\\n  { id: '2', title: 'Something more', state: 'TASK_INBOX' },\\n  { id: '3', title: 'Something else', state: 'TASK_INBOX' },\\n  { id: '4', title: 'Something again', state: 'TASK_INBOX' },\\n];\\n\\n// Exportamos el store de redux construido.\\nexport default createStore(reducer, { tasks: defaultTasks });\\n</code></pre>\\n<p>Luego actualizaremos lo exportado por defecto en el componente <code>TaskList</code> para conectarlo al Store de Redux y renderizar las tareas en las que estamos interesados.</p>\\n<pre><code class=\\\"language-javascript\\\">import React from 'react';\\nimport PropTypes from 'prop-types';\\n\\nimport Task from './Task';\\nimport { connect } from 'react-redux';\\nimport { archiveTask, pinTask, snoozeTask } from '../lib/redux';\\n\\nexport function PureTaskList({ tasks, onPinTask, onArchiveTask }) {\\n  /* antigua implementación de TaskList */\\n}\\n\\nPureTaskList.propTypes = {\\n  loading: PropTypes.bool,\\n  tasks: PropTypes.arrayOf(Task.propTypes.task).isRequired,\\n  onPinTask: PropTypes.func.isRequired,\\n  onArchiveTask: PropTypes.func.isRequired,\\n};\\n\\nPureTaskList.defaultProps = {\\n  loading: false,\\n};\\n\\nexport default connect(\\n  ({ tasks }) => ({\\n    tasks: tasks.filter(t => t.state === 'TASK_INBOX' || t.state === 'TASK_PINNED'),\\n  }),\\n  dispatch => ({\\n    onArchiveTask: id => dispatch(archiveTask(id)),\\n    onPinTask: id => dispatch(pinTask(id)),\\n  })\\n)(PureTaskList);\\n</code></pre>\\n<p>En esta etapa, nuestras pruebas de Storybook habrán dejado de funcionar, ya que la <code>TaskList</code> ahora es un contenedor y ya no espera ninguna de las props pasadas como parámetros, sino que se conecta a la store y establece las props en el componente <code>PureTaskList</code> que envuelve.</p>\\n<p>Sin embargo, podemos resolver este problema fácilmente renderizando <code>PureTaskList</code> --el componente de presentación-- en nuestras historias de Storybook:</p>\\n<pre><code class=\\\"language-javascript\\\">import React from 'react';\\nimport { storiesOf } from '@storybook/react';\\n\\nimport { PureTaskList } from './TaskList';\\nimport { createTask, actions } from './Task.stories';\\n\\nexport const defaultTasks = [\\n  createTask({ state: 'TASK_INBOX' }),\\n  createTask({ state: 'TASK_INBOX' }),\\n  createTask({ state: 'TASK_INBOX' }),\\n  createTask({ state: 'TASK_INBOX' }),\\n  createTask({ state: 'TASK_INBOX' }),\\n  createTask({ state: 'TASK_INBOX' }),\\n];\\n\\nexport const withPinnedTasks = [\\n  createTask({ title: 'Task 1', state: 'TASK_INBOX' }),\\n  createTask({ title: 'Task 2', state: 'TASK_INBOX' }),\\n  createTask({ title: 'Task 3', state: 'TASK_INBOX' }),\\n  createTask({ title: 'Task 4', state: 'TASK_INBOX' }),\\n  createTask({ title: 'Task 5', state: 'TASK_INBOX' }),\\n  createTask({ title: 'Task 6 (pinned)', state: 'TASK_PINNED' }),\\n];\\n\\nstoriesOf('TaskList', module)\\n  .addDecorator(story => &#x3C;div style={{ padding: '3rem' }}>{story()}&#x3C;/div>)\\n  .add('default', () => &#x3C;PureTaskList tasks={defaultTasks} {...actions} />)\\n  .add('withPinnedTasks', () => &#x3C;PureTaskList tasks={withPinnedTasks} {...actions} />)\\n  .add('loading', () => &#x3C;PureTaskList loading tasks={[]} {...actions} />)\\n  .add('empty', () => &#x3C;PureTaskList tasks={[]} {...actions} />);\\n</code></pre>\\n<video autoPlay muted playsInline loop>\\n  <source\\n    src=\\\"/finished-tasklist-states.mp4\\\"\\n    type=\\\"video/mp4\\\"\\n  />\\n</video>\",\"excerpt\":\"Introducir datos Hasta ahora hemos creado componentes aislados sin estado, muy útiles para Storybook, pero finalmente no son útiles hasta que les proporcionemos algunos datos en nuestra aplicación. Este tutorial no se centra en los detalles de la…\",\"frontmatter\":{\"path\":null,\"title\":\"Introducir datos\"}}},{\"node\":{\"id\":\"/Users/luz/code/js/binstd.github.io/markdown/docs/es/deploy.md absPath of file >>> MarkdownRemark\",\"html\":\"<h1>Desplegar Storybook</h1>\\n<p>En este tutorial hemos ejecutado Storybook en nuestra máquina de desarrollo. También se puede compartir ese Storybook con el equipo, especialmente con los miembros no técnicos. Afortunadamente, es fácil implementar Storybook en línea.</p>\\n<div class=\\\"aside\\\">\\n<strong>¿Hiciste los test con Chromatic antes?</strong>\\n<br/>\\n🎉 Sus historias ya están desplegadas! Chromatic indexa de forma segura sus historias en línea y las rastrea a través de ramas y commits. Salta este capítulo y ve a la <a href=\\\"/conclusion\\\">conclusión</a>.\\n</div>\\n<h2>Exportando como una app estática</h2>\\n<p>Para desplegar Storybook primero necesitamos exportarlo como una aplicación web estática. Esta funcionalidad ya está incorporada en Storybook, sólo necesitamos activarla añadiendo un script al <code>package.json</code>.</p>\\n<pre><code class=\\\"language-javascript\\\">{\\n  \\\"scripts\\\": {\\n    \\\"storybook\\\": \\\"build-storybook -c .storybook -o .storybook-static\\\"\\n  }\\n}\\n</code></pre>\\n<p>Ahora, cuando ejecutes Storybook a través de <code>npm run storybook</code>, obtendrás un Storybook estático en el directorio <code>storybook-static</code>.</p>\\n<h2>Despliegue continuo</h2>\\n<p>Queremos compartir la última versión de los componentes cada vez que hagamos push del código. Para ello necesitamos desplegar de forma continua Storybook. Confiaremos en GitHub y Netlify para desplegar nuestro sitio estático. Estaremos usando el plan gratuito de Netlify.</p>\\n<h3>GitHub</h3>\\n<p>Primero debes configurar Git para tu proyecto en el directorio local. Si estás siguiendo el capítulo anterior sobre testing, salta a la creación de un repositorio en GitHub.</p>\\n<pre><code class=\\\"language-bash\\\">$ git init\\n</code></pre>\\n<p>Agrega archivos al primer commit. </p>\\n<pre><code class=\\\"language-bash\\\">$ git add .\\n</code></pre>\\n<p>Ahora haz commit de los archivos.</p>\\n<pre><code class=\\\"language-bash\\\">$ git commit -m \\\"taskbox UI\\\"\\n</code></pre>\\n<p>Ve a Github y configura un repositorio <a href=\\\"https://github.com/new\\\">aquí</a>. Nombra tu repo “taskbox”.</p>\\n<p><img src=\\\"/github-create-taskbox.png\\\" alt=\\\"GitHub setup\\\"></p>\\n<p>En la nueva configuración del repositorio copia la URL de origen del repositorio y añádelo a tu proyecto git con este comando:</p>\\n<pre><code class=\\\"language-bash\\\">$ git remote add origin https://github.com/&#x3C;your username>/taskbox.git\\n</code></pre>\\n<p>Finalmente haz push al repo en GitHub.</p>\\n<pre><code class=\\\"language-bash\\\">$ git push -u origin master\\n</code></pre>\\n<h3>Netlify</h3>\\n<p>Netlify tiene incorporado un servicio de despliegue continuo que nos permitirá desplegar Storybook sin necesidad de configurar nuestro propio CI.</p>\\n<div class=\\\"aside\\\">\\nSi usas CI en tu empresa, añade un script de implementación a tu configuración que suba <code>storybook-static</code> a un servicio de alojamiento de estáticos como S3.\\n</div>\\n<p><a href=\\\"https://app.netlify.com/start\\\">Crea una cuenta en Netlify</a> y da click en “crear sitio”.</p>\\n<p><img src=\\\"/netlify-create-site.png\\\" alt=\\\"Crear sitio en Netlify\\\"></p>\\n<p>A continuación, haz clic en el botón de GitHub para conectar Netlify a GitHub. Esto le permite acceder a nuestro repositorio remoto Taskbox.</p>\\n<p>Ahora selecciona el repo de taskbox de GitHub de la lista de opciones.</p>\\n<p><img src=\\\"/netlify-account-picker.png\\\" alt=\\\"Conectar un repositorio en Netlify\\\"></p>\\n<p>Configura Netlify resaltando el comando build que se ejecutará en tu CI y el directorio en el que se enviará el sitio estático. Para la rama elegir <code>master</code>. El directorio es <code>storybook-static</code>. Ejecuta el comando <code>yarn build-storybook</code>.</p>\\n<p><img src=\\\"/netlify-settings.png\\\" alt=\\\"Ajustes Netlify\\\"></p>\\n<p>Ahora envía el formulario para construir e implementar el código en la rama <code>master</code> del taskbox.</p>\\n<p>Cuando esto termine veremos un mensaje de confirmación en Netlify con un enlace al Storybook de Taskbox online. Si lo estás siguiendo, tu Storybook desplegado debería estar en línea <a href=\\\"https://clever-banach-415c03.netlify.com/\\\">como este</a>.</p>\\n<p><img src=\\\"/netlify-storybook-deploy.png\\\" alt=\\\"Despliegue de Netlify Storybook\\\"></p>\\n<p>Terminamos de configurar el despliegue continuo de tu Storybook! Ahora podemos compartir nuestras historias con nuestros compañeros de equipo a través de un enlace.</p>\\n<p>Esto es útil para la revisión visual como parte del proceso de desarrollo de aplicaciones estándar o simplemente para mostrar nuestro trabajo💅.</p>\",\"excerpt\":\"Desplegar Storybook En este tutorial hemos ejecutado Storybook en nuestra máquina de desarrollo. También se puede compartir ese Storybook con el equipo, especialmente con los miembros no técnicos. Afortunadamente, es fácil implementar Storybook en…\",\"frontmatter\":{\"path\":null,\"title\":\"Desplegar Storybook\"}}},{\"node\":{\"id\":\"/Users/luz/code/js/binstd.github.io/markdown/docs/es/get-started.md absPath of file >>> MarkdownRemark\",\"html\":\"<h1>Empezando</h1>\\n<p>Storybook se ejecuta junto con tu aplicación en modo desarrollo. Te ayuda a crear componentes de UI aislados de la lógica y el contexto de tu aplicación. Esta edición de Aprende Storybook es para React; otras ediciones para Vue y Angular vendrán pronto.</p>\\n<p><img src=\\\"/storybook-relationship.jpg\\\" alt=\\\"Storybook and your app\\\"></p>\\n<h2>Configurando React Storybook</h2>\\n<p>Necesitaremos seguir algunos pasos para configurar el proceso de build de nuestro entorno. Para iniciar, vamos a usar <a href=\\\"https://github.com/facebook/create-react-app\\\">Create React App</a> (CRA) para configurar nuestro sistema de build, y añadiremos <a href=\\\"https://storybook.js.org/\\\">Storybook</a> y <a href=\\\"https://facebook.github.io/jest/\\\">Jest</a> para testear nuestra aplicación creada. Vamos a ejecutar los siguientes comandos:</p>\\n<pre><code class=\\\"language-bash\\\"># Crea nuestra aplicación:\\nnpx create-react-app taskbox\\ncd taskbox\\n\\n# Añade Storybook:\\nnpx -p @storybook/cli getstorybook\\n</code></pre>\\n<p>Podemos comprobar rápidamente que los distintos entornos de nuestra aplicación funcionan correctamente:</p>\\n<pre><code class=\\\"language-bash\\\"># Corre el test de prueba (Jest) en una terminal:\\nyarn test\\n\\n# Inicia el explorador de componentes en el puerto 9009:\\nyarn run storybook\\n\\n# Ejecuta el frontend de la aplicación en el puerto 3000:\\nyarn start\\n</code></pre>\\n<p>Nuestras tres modalidades del frontend de la aplicación: test automatizado (Jest), desarrollo de componentes (Storybook) y la propia aplicación.</p>\\n<p><img src=\\\"/app-three-modalities.png\\\" alt=\\\"3 modalidades\\\"></p>\\n<p>Dependiendo de en qué parte de la aplicación estés trabajando, es posible que quieras ejecutar uno o más de estos simultáneamente. Dado que nuestro objetivo actual es crear un único componente de UI, seguiremos ejecutando Storybook.</p>\\n<h2>Reusa CSS</h2>\\n<p>Taskbox reutiliza elementos de diseño de la aplicación de ejemplo de este <a href=\\\"https://blog.hichroma.com/graphql-react-tutorial-part-1-6-d0691af25858\\\">Tutorial de GraphQL y React</a>, por lo que no necesitaremos escribir CSS en este tutorial. Simplemente compilaremos nuestros archivos LESS en un único archivo CSS y lo incluiremos en nuestra aplicación. Copia y pega <a href=\\\"https://github.com/hichroma/learnstorybook-code/blob/master/src/index.css\\\">este CSS compilado</a> dentro del archivo src/index.css según la convención de CRA.</p>\\n<p><img src=\\\"/ss-browserchrome-taskbox-learnstorybook.png\\\" alt=\\\"Buzón de tareas UI\\\"></p>\\n<div class=\\\"aside\\\">\\nSi deseas modificar los estilos, los archivos fuente de CSS en formato LESS son proporcionados en el mismo repositorio de GitHub.</div>\\n<h2>Añade recursos</h2>\\n<p>También necesitamos añadir la fuente y el icono de este <a href=\\\"https://github.com/hichroma/learnstorybook-code/tree/master/public\\\">directorio</a> a la carpeta <code>public/</code>.\\nDespués de añadir los estilos y recursos, nuestra aplicación se renderizará de forma un poco extraña. Está bien. No estamos trabajando en la aplicación ahora mismo. Comenzamos con la construcción de nuestro primer componente!</p>\",\"excerpt\":\"Empezando Storybook se ejecuta junto con tu aplicación en modo desarrollo. Te ayuda a crear componentes de UI aislados de la lógica y el contexto de tu aplicación. Esta edición de Aprende Storybook es para React; otras ediciones para Vue y Angular…\",\"frontmatter\":{\"path\":null,\"title\":\"Empezando\"}}},{\"node\":{\"id\":\"/Users/luz/code/js/binstd.github.io/markdown/docs/es/screen.md absPath of file >>> MarkdownRemark\",\"html\":\"<h1>Construir una pantalla</h1>\\n<p>Nos hemos concentrado en crear interfaces de usuario de abajo hacia arriba; comenzando por lo pequeño y añadiendo complejidad. Esto nos ha permitido desarrollar cada componente de forma aislada, determinar los datos que necesita y jugar con ellos en Storybook. Todo sin necesidad de levantar un servidor o construir pantallas!</p>\\n<p>En este capítulo continuaremos aumentando la sofisticación combinando componentes en una pantalla y desarrollando esa pantalla en Storybook.</p>\\n<h2>Componentes de contenedor anidados</h2>\\n<p>Como nuestra aplicación es muy simple, la pantalla que construiremos es bastante trivial, simplemente envolviendo el componente <code>TaskList</code> (que proporciona sus propios datos a través de Redux) en alguna maqueta y sacando un campo <code>error</code> de primer nivel de redux (asumamos que pondremos ese campo si tenemos algún problema para conectarnos a nuestro servidor):</p>\\n<pre><code class=\\\"language-javascript\\\">import React from 'react';\\nimport PropTypes from 'prop-types';\\nimport { connect } from 'react-redux';\\n\\nimport TaskList from './TaskList';\\n\\nexport function PureInboxScreen({ error }) {\\n  if (error) {\\n    return (\\n      &#x3C;div className=\\\"page lists-show\\\">\\n        &#x3C;div className=\\\"wrapper-message\\\">\\n          &#x3C;span className=\\\"icon-face-sad\\\" />\\n          &#x3C;div className=\\\"title-message\\\">Oh no!&#x3C;/div>\\n          &#x3C;div className=\\\"subtitle-message\\\">Algo va mal&#x3C;/div>\\n        &#x3C;/div>\\n      &#x3C;/div>\\n    );\\n  }\\n\\n  return (\\n    &#x3C;div className=\\\"page lists-show\\\">\\n      &#x3C;nav>\\n        &#x3C;h1 className=\\\"title-page\\\">\\n          &#x3C;span className=\\\"title-wrapper\\\">Taskbox&#x3C;/span>\\n        &#x3C;/h1>\\n      &#x3C;/nav>\\n      &#x3C;TaskList />\\n    &#x3C;/div>\\n  );\\n}\\n\\nPureInboxScreen.propTypes = {\\n  error: PropTypes.string,\\n};\\n\\nPureInboxScreen.defaultProps = {\\n  error: null,\\n};\\n\\nexport default connect(({ error }) => ({ error }))(PureInboxScreen);\\n</code></pre>\\n<p>También cambiamos el componente <code>App</code> para renderizar la pantalla de la bandeja de entrada <code>InboxScreen</code> (normalmente usaríamos un router para elegir la pantalla correcta, pero no nos preocupemos por ello aquí):</p>\\n<pre><code class=\\\"language-javascript\\\">import React, { Component } from 'react';\\nimport { Provider } from 'react-redux';\\nimport store from './lib/redux';\\n\\nimport InboxScreen from './components/InboxScreen';\\n\\nclass App extends Component {\\n  render() {\\n    return (\\n      &#x3C;Provider store={store}>\\n        &#x3C;InboxScreen />\\n      &#x3C;/Provider>\\n    );\\n  }\\n}\\n\\nexport default App;\\n</code></pre>\\n<p>Sin embargo, donde las cosas se ponen interesantes es en la representación de la historia en Storybook.</p>\\n<p>Como vimos anteriormente, el componente <code>TaskList</code> es un <strong>contenedor</strong> que renderiza el componente de presentación <code>PureTaskList</code>. Por definición, los componentes de un contenedor no pueden simplemente hacer render de forma aislada; esperan que se les pase algún contexto o que se conecten a un servicio. Lo que esto significa es que para hacer render de un contenedor en Storybook, debemos mockearlo (es decir, proporcionar una versión ficticia) del contexto o servicio que requiere.</p>\\n<p>Al colocar la \\\"Lista de tareas\\\" <code>TaskList</code> en Storybook, pudimos esquivar este problema simplemente renderizando la <code>PureTaskList</code> y evadiendo el contenedor. Haremos algo similar y renderizaremos la <code>PureInboxScreen</code> en Storybook también.</p>\\n<p>Sin embargo, para la <code>PureInboxScreen</code> tenemos un problema porque aunque la <code>PureInboxScreen</code> en si misma es presentacional, su hijo, la <code>TaskList</code>, no lo es. En cierto sentido la <code>PureInboxScreen</code> ha sido contaminada por la \\\"contenedorización\\\". Así que cuando preparamos nuestras historias:</p>\\n<pre><code class=\\\"language-javascript\\\">import React from 'react';\\nimport { storiesOf } from '@storybook/react';\\n\\nimport { PureInboxScreen } from './InboxScreen';\\n\\nstoriesOf('InboxScreen', module)\\n  .add('default', () => &#x3C;PureInboxScreen />)\\n  .add('error', () => &#x3C;PureInboxScreen error=\\\"Something\\\" />);\\n</code></pre>\\n<p>Vemos que aunque la historia de <code>error</code> funciona bien, tenemos un problema en la historia <code>default</code>, porque la <code>TaskList</code> no tiene una store de Redux a la que conectarse. (También encontrarás problemas similares cuando intentes probar la <code>PureInboxScreen</code> con un test unitario).</p>\\n<p><img src=\\\"/broken-inboxscreen.png\\\" alt=\\\"Broken inbox\\\"></p>\\n<p>Una forma de evitar este problema es nunca renderizar componentes contenedores en ninguna parte de tu aplicación excepto en el nivel más alto y en su lugar pasar todos los datos requeridos bajo la jerarquía de componentes.</p>\\n<p>Sin embargo, los desarrolladores <strong>necesitarán</strong> inevitablemente renderizar los contenedores más abajo en la jerarquía de componentes. Si queremos renderizar la mayor parte o la totalidad de la aplicación en Storybook (¡lo hacemos!), necesitamos una solución a este problema.</p>\\n<div class=\\\"aside\\\">\\nPor otro lado, la transmisión de datos a nivel jerárquico es un enfoque legítimo, especialmente cuando utilizas <a href=\\\"http://graphql.org/\\\">GraphQL</a>. Así es como hemos construido <a href=\\\"https://chromaticqa.com\\\">Chromatic</a> junto a más de 670+ historias.\\n</div>\\n<h2>Suministrando contexto con decoradores</h2>\\n<p>La buena noticia es que es fácil suministrar una store de Redux a la <code>InboxScreen</code> en una historia! Podemos usar una versión mockeada de la store de Redux provista en un decorador:</p>\\n<pre><code class=\\\"language-javascript\\\">import React from 'react';\\nimport { storiesOf } from '@storybook/react';\\nimport { action } from '@storybook/addon-actions';\\nimport { Provider } from 'react-redux';\\n\\nimport { PureInboxScreen } from './InboxScreen';\\nimport { defaultTasks } from './TaskList.stories';\\n\\n// Un mock super simple de un store de redux\\nconst store = {\\n  getState: () => {\\n    return {\\n      tasks: defaultTasks,\\n    };\\n  },\\n  subscribe: () => 0,\\n  dispatch: action('dispatch'),\\n};\\n\\nstoriesOf('InboxScreen', module)\\n  .addDecorator(story => &#x3C;Provider store={store}>{story()}&#x3C;/Provider>)\\n  .add('default', () => &#x3C;PureInboxScreen />)\\n  .add('error', () => &#x3C;PureInboxScreen error=\\\"Something\\\" />);\\n</code></pre>\\n<p>Existen enfoques similares para proporcionar un contexto simulado para otras bibliotecas de datos, tales como <a href=\\\"https://www.npmjs.com/package/apollo-storybook-decorator\\\">Apollo</a>, <a href=\\\"https://github.com/orta/react-storybooks-relay-container\\\">Relay</a> y algunas otras.</p>\\n<p>Recorrer los estados en Storybook hace que sea fácil comprobar que lo hemos hecho correctamente:</p>\\n<video autoPlay muted playsInline loop >\\n  <source\\n    src=\\\"/finished-inboxscreen-states.mp4\\\"\\n    type=\\\"video/mp4\\\"\\n  />\\n</video>\\n<h2>Desarrollo basado en componentes</h2>\\n<p>Empezamos desde abajo con <code>Task</code>, luego progresamos a <code>TaskList</code>, ahora estamos aquí con una interfaz de usuario de pantalla completa. Nuestra <code>InboxScreen</code> contiene un componente de contenedor anidado e incluye historias de acompañamiento.</p>\\n<video autoPlay muted playsInline loop style=\\\"width:480px; height:auto; margin: 0 auto;\\\">\\n  <source\\n    src=\\\"/component-driven-development-optimized.mp4\\\"\\n    type=\\\"video/mp4\\\"\\n  />\\n</video>\\n<p><a href=\\\"https://blog.hichroma.com/component-driven-development-ce1109d56c8e\\\"><strong>El desarrollo basado en componentes</strong></a> te permite expandir gradualmente la complejidad a medida que asciendes en la jerarquía de componentes. Entre los beneficios están un proceso de desarrollo más enfocado y una mayor cobertura de todas las posibles mutaciones de la interfaz de usuario. En resumen, la CDD te ayuda a construir interfaces de usuario de mayor calidad y complejidad.</p>\\n<p>Aún no hemos terminado, el trabajo no termina cuando se construye la interfaz de usuario. También tenemos que asegurarnos de que siga siendo duradero a lo largo del tiempo.</p>\",\"excerpt\":\"Construir una pantalla Nos hemos concentrado en crear interfaces de usuario de abajo hacia arriba; comenzando por lo pequeño y añadiendo complejidad. Esto nos ha permitido desarrollar cada componente de forma aislada, determinar los datos que…\",\"frontmatter\":{\"path\":null,\"title\":\"Construir una pantalla\"}}},{\"node\":{\"id\":\"/Users/luz/code/js/binstd.github.io/markdown/docs/es/simple-component.md absPath of file >>> MarkdownRemark\",\"html\":\"<h1>Construye un componente simple</h1>\\n<p>Construiremos nuestra UI siguiendo la metodología (CDD) <a href=\\\"https://blog.hichroma.com/component-driven-development-ce1109d56c8e\\\">Component-Driven Development</a>. Es un proceso que construye UIs de “abajo hacia arriba”, empezando con los componentes y terminando con las vistas. CDD te ayudará a escalar la cantidad de complejidad con la que te enfrentas a medida que construyes la UI.</p>\\n<h2>Task - Tarea</h2>\\n<p><img src=\\\"/task-states-learnstorybook.png\\\" alt=\\\"Task component in three states\\\"></p>\\n<p><code>Task</code> (o Tarea) es el componente principal en nuestra app. Cada tarea se muestra de forma ligeramente diferente según el estado en el que se encuentre. Mostramos un checkbox marcado (o no marcado), información sobre la tarea y un botón “pin” que nos permite mover la tarea hacia arriba o abajo en la lista de tareas. Poniendo esto en conjunto, necesitaremos estas propiedades -props- :</p>\\n<ul>\\n<li><code>title</code> – un string que describe la tarea</li>\\n<li><code>state</code> - en que lista se encuentra la tarea actualmente? y, está marcado el checkbox?</li>\\n</ul>\\n<p>A medida que comencemos a construir <code>Task</code>, primero escribiremos nuestros tests para los estados que corresponden a los distintos tipos de tareas descritas anteriormente. Luego, utilizamos Storybook para construir el componente de forma aislada usando datos de prueba. Vamos a “testear visualmente” la apariencia del componente a medida que cambiemos cada estado.</p>\\n<p>Este proceso es similar a <a href=\\\"https://en.wikipedia.org/wiki/Test-driven_development\\\">Test-driven development</a> (TDD) al que podemos llamar “<a href=\\\"https://blog.hichroma.com/visual-test-driven-development-aec1c98bed87\\\">Visual TDD</a>”.</p>\\n<h2>Ajustes iniciales</h2>\\n<p>Primero, vamos a crear el componente Task y el archivo de historias de storybook que lo acompaña: <code>src/components/Task.js</code> y <code>src/components/Task.stories.js</code>.</p>\\n<p>Comenzaremos con una implementación básica de <code>Task</code>, simplemente teniendo en cuenta los atributos que sabemos que necesitaremos y las dos acciones que puedes realizar con una tarea (para moverla entre las listas):</p>\\n<pre><code class=\\\"language-javascript\\\">import React from 'react';\\n\\nexport default function Task({ task: { id, title, state }, onArchiveTask, onPinTask }) {\\n  return (\\n    &#x3C;div className=\\\"list-item\\\">\\n      &#x3C;input type=\\\"text\\\" value={title} readOnly={true} />\\n    &#x3C;/div>\\n  );\\n}\\n</code></pre>\\n<p>Arriba, renderizamos directamente <code>Task</code> basándonos en la estructura HTML existente de la app Todos.</p>\\n<p>A continuación creamos los tres estados de prueba de Task dentro del archivo de historia:</p>\\n<pre><code class=\\\"language-javascript\\\">import React from 'react';\\nimport { storiesOf } from '@storybook/react';\\nimport { action } from '@storybook/addon-actions';\\n\\nimport Task from './Task';\\n\\nexport function createTask(attrs) {\\n  return {\\n    id: Math.round(Math.random() * 1000000).toString(),\\n    title: 'Test Task',\\n    state: 'TASK_INBOX',\\n    updatedAt: Date.now(),\\n    ...attrs,\\n  };\\n}\\n\\nexport const actions = {\\n  onPinTask: action('onPinTask'),\\n  onArchiveTask: action('onArchiveTask'),\\n};\\n\\nstoriesOf('Task', module)\\n  .add('default', () => &#x3C;Task task={createTask({ state: 'TASK_INBOX' })} {...actions} />)\\n  .add('pinned', () => &#x3C;Task task={createTask({ state: 'TASK_PINNED' })} {...actions} />)\\n  .add('archived', () => &#x3C;Task task={createTask({ state: 'TASK_ARCHIVED' })} {...actions} />);\\n</code></pre>\\n<p>Existen dos niveles básicos de organización en Storybook. El componente y sus historias hijas. Piensa en cada historia como una permutación posible del componente. Puedes tener tantas historias por componente como se necesite.</p>\\n<ul>\\n<li>\\n<p><strong>Component</strong></p>\\n<ul>\\n<li>Story</li>\\n<li>Story</li>\\n<li>Story</li>\\n</ul>\\n</li>\\n</ul>\\n<p>Para iniciar Storybook, primero invocamos a la función <code>storiesOf()</code> para registrar el componente. Agregamos un nombre para mostrar el componente, que se muestra en la barra lateral de la aplicación Storybook.</p>\\n<p><code>action()</code> nos permite crear un callback que aparecerá en el panel <strong>actions</strong> de la UI de Storybook cuando es cliqueado. Entonces, cuando construyamos un botón pin, podremos determinar en la UI de prueba si un click en el botón es exitoso o no.</p>\\n<p>Como necesitamos pasarle el mismo conjunto de acciones a todas las permutaciones de nuestro componente, es conveniente agruparlas en una sola variable <code>actions</code> y utilizar <code>{...actions}</code>, la expansión de propiedades de React, para pasarlas todas a la vez. <code>&#x3C;Task {...actions}></code> es equivalente a <code>&#x3C;Task onPinTask={actions.onPinTask} onArchiveTask={actions.onArchiveTask}></code>.</p>\\n<p>Otra cosa positiva acerca de agrupar las <code>actions</code> que un componente necesita, es que puedes usar <code>export</code> y utilizarlas en historias para otros componentes que reutilicen este componente, como veremos luego.</p>\\n<p>Para definir nuestras historias, llamamos a <code>add()</code> una vez para cada uno de nuestros estados del test para generar una historia. La historia de acción - action story - es una función que retorna un elemento renderizado (es decir, una clase componente con un conjunto de props) en un estado dado---exactamente como en React <a href=\\\"https://reactjs.org/docs/components-and-props.html\\\">Stateless Functional Component</a>.</p>\\n<p>Al crear una historia utilizamos una función auxiliar (<code>createTask()</code>) para construir la forma de la task que el componente espera. Esto generalmente se modela a partir del aspecto de los datos verdaderos. Nuevamente, <code>export</code>-ando esta función nos permitirá reutilizarla en historias posteriores, como veremos.</p>\\n<div class=\\\"aside\\\">\\nLas <a href=\\\"https://storybook.js.org/addons/introduction/#2-native-addons\\\"><b>Acciones</b></a> ayudan a verificar las interacciones cuando creamos componentes UI en aislamiento. A menudo no tendrás acceso a las funciones y el estado que tienes en el contexto de la aplicación. Utiliza <code>action()</code> para agregarlas.\\n</div>\\n<h2>Configuración</h2>\\n<p>También necesitamos hacer un pequeño cambio en la configuración de Storybook (<code>.storybook/config.js</code>) para que tenga en cuenta nuestros archivos <code>.stories.js</code> y use nuestro archivo CSS. Por defecto, Storybook busca historias en el directorio <code>/stories</code>; este tutorial usa un esquema de nombres que es similar al esquema de nombres <code>.test.js</code> preferido por CRA para pruebas -tests- automatizadas.</p>\\n<pre><code class=\\\"language-javascript\\\">import { configure } from '@storybook/react';\\nimport '../src/index.css';\\n\\nconst req = require.context('../src', true, /.stories.js$/);\\n\\nfunction loadStories() {\\n  req.keys().forEach(filename => req(filename));\\n}\\n\\nconfigure(loadStories, module);\\n</code></pre>\\n<p>Una vez que hayamos hecho esto, reiniciando el servidor de Storybook debería producir casos de prueba para los tres estados de Task:</p>\\n<video autoPlay muted playsInline controls >\\n  <source\\n    src=\\\"/inprogress-task-states.mp4\\\"\\n    type=\\\"video/mp4\\\"\\n  />\\n</video>\\n<h2>Construyendo los estados</h2>\\n<p>Ahora tenemos configurado Storybook, los estilos importados y los casos de prueba construidos; podemos comenzar rápidamente el trabajo de implementar el HTML del componente para que coincida con el diseño.</p>\\n<p>El componente todavía es básico. Primero escribiremos el código que se aproxima al diseño sin entrar en demasiados detalles:</p>\\n<pre><code class=\\\"language-javascript\\\">import React from 'react';\\n\\nexport default function Task({ task: { id, title, state }, onArchiveTask, onPinTask }) {\\n  return (\\n    &#x3C;div className={`list-item ${state}`}>\\n      &#x3C;label className=\\\"checkbox\\\">\\n        &#x3C;input\\n          type=\\\"checkbox\\\"\\n          defaultChecked={state === 'TASK_ARCHIVED'}\\n          disabled={true}\\n          name=\\\"checked\\\"\\n        />\\n        &#x3C;span className=\\\"checkbox-custom\\\" onClick={() => onArchiveTask(id)} />\\n      &#x3C;/label>\\n      &#x3C;div className=\\\"title\\\">\\n        &#x3C;input type=\\\"text\\\" value={title} readOnly={true} placeholder=\\\"Input title\\\" />\\n      &#x3C;/div>\\n\\n      &#x3C;div className=\\\"actions\\\" onClick={event => event.stopPropagation()}>\\n        {state !== 'TASK_ARCHIVED' &#x26;&#x26; (\\n          &#x3C;a onClick={() => onPinTask(id)}>\\n            &#x3C;span className={`icon-star`} />\\n          &#x3C;/a>\\n        )}\\n      &#x3C;/div>\\n    &#x3C;/div>\\n  );\\n}\\n</code></pre>\\n<p>El maquetado adicional de arriba, combinado con el CSS que hemos importado antes, produce la siguiente UI:</p>\\n<video autoPlay muted playsInline loop>\\n  <source\\n    src=\\\"/finished-task-states.mp4\\\"\\n    type=\\\"video/mp4\\\"\\n  />\\n</video>\\n<h2>Especificar los requerimientos de datos</h2>\\n<p>Es una buena práctica en React utilizar <code>propTypes</code> para especificar la forma de los datos que espera recibir un componente. No sólo se auto documenta, sino que también ayuda a detectar problemas rápidamente.</p>\\n<pre><code class=\\\"language-javascript\\\">import React from 'react';\\nimport PropTypes from 'prop-types';\\n\\nfunction Task() {\\n  ...\\n}\\n\\nTask.propTypes = {\\n  task: PropTypes.shape({\\n    id: PropTypes.string.isRequired,\\n    title: PropTypes.string.isRequired,\\n    state: PropTypes.string.isRequired,\\n  }),\\n  onArchiveTask: PropTypes.func,\\n  onPinTask: PropTypes.func,\\n};\\n\\nexport default Task;\\n</code></pre>\\n<p>Ahora aparecerá una advertencia en modo desarrollo si el componente Task  se utiliza incorrectamente.</p>\\n<div class=\\\"aside\\\">\\nUna forma alternativa de lograr el mismo propósito es utilizando un sistema de tipos de JavaScript como TypeScript, para crear un tipo para las propiedades del componente.\\n</div>\\n<h2>Componente construido!</h2>\\n<p>Ahora hemos construido con éxito un componente sin necesidad de un servidor o sin ejecutar toda la aplicación frontend. El siguiente paso es construir los componentes restantes de la Taskbox, uno por uno de manera similar.</p>\\n<p>Como puedes ver, comenzar a construir componentes de forma aislada es fácil y rápido. Podemos esperar producir una UI de mayor calidad con menos errores y más pulida porque es posible profundizar y probar todos los estados posibles.</p>\\n<h2>Pruebas automatizadas</h2>\\n<p>Storybook nos dio una excelente manera de probar visualmente nuestra aplicación durante su construcción. Las 'historias' ayudarán a asegurar que no rompamos nuestra Task visualmente, a medida que continuamos desarrollando la aplicación. Sin embargo, en esta etapa, es un proceso completamente manual y alguien tiene que hacer el esfuerzo de hacer clic en cada estado de prueba y asegurarse de que se visualice bien y sin errores ni advertencias. ¿No podemos hacer eso automáticamente?</p>\\n<h3>Pruebas de instantáneas</h3>\\n<p>La prueba de instantáneas se refiere a la práctica de registrar la salida \\\"correcta\\\" de un componente para una entrada dada y luego en el futuro marcar el componente siempre que la salida cambie. Esto complementa a Storybook, porque es una manera rápida de ver la nueva versión de un componente y verificar los cambios.</p>\\n<p>Con <a href=\\\"https://github.com/storybooks/storybook/tree/master/addons/storyshots\\\">Storyshots addon</a> se crea una prueba de instantánea para cada una de las historias. Usalo agregando una dependencia en modo desarrollo en el paquete:</p>\\n<pre><code class=\\\"language-bash\\\">yarn add --dev @storybook/addon-storyshots react-test-renderer\\n</code></pre>\\n<p>Luego crea un archivo <code>src/storybook.test.js</code> con el siguiente contenido:</p>\\n<pre><code class=\\\"language-javascript\\\">import initStoryshots from '@storybook/addon-storyshots';\\ninitStoryshots();\\n</code></pre>\\n<p>Una vez hecho lo anterior, podemos ejecutar <code>yarn test</code> y veremos el siguiente resultado:</p>\\n<p><img src=\\\"/task-testrunner.png\\\" alt=\\\"Task test runner\\\"></p>\\n<p>Ahora tenemos una prueba de instantánea para cada una de las historias de <code>Task</code>. Si cambiamos la implementación de <code>Task</code>, se nos pedirá que verifiquemos los cambios.</p>\",\"excerpt\":\"Construye un componente simple Construiremos nuestra UI siguiendo la metodología (CDD)  Component-Driven Development . Es un proceso que construye UIs de “abajo hacia arriba”, empezando con los componentes y terminando con las vistas. CDD te ayudará…\",\"frontmatter\":{\"path\":null,\"title\":\"Construye un componente simple\"}}},{\"node\":{\"id\":\"/Users/luz/code/js/binstd.github.io/markdown/docs/es/test.md absPath of file >>> MarkdownRemark\",\"html\":\"<h1>Testear Componentes UI</h1>\\n<p>Ningún tutorial de Storybook estaría completo sin hacer test. Las pruebas son esenciales para crear interfaces de usuario de alta calidad. En los sistemas modulares, los ajustes minúsculos pueden dar lugar a regresiones importantes. Hasta ahora hemos encontrado tres tipos de pruebas:</p>\\n<ul>\\n<li><strong>Pruebas visuales</strong> confían en que los desarrolladores examinen manualmente un componente para verificar que esté correcto. Nos ayudan a comprobar la aparencia de un componente a medida que lo construimos.</li>\\n<li><strong>Pruebas instantáneas</strong> con Storyshots captura el marcado del renderizado de un componente. Nos ayudan a mantenernos al tanto de los cambios de marcado que causan errores de renderizado y advertencias en los componentes.</li>\\n<li><strong>Pruebas unitarias</strong> con Jest verifica que la salida de un componente permanezca igual a una entrada fija dada. Son ideales para probar las cualidades funcionales de un componente.</li>\\n</ul>\\n<h2>\\\"¿Pero se ve bien?\\\"</h2>\\n<p>Desafortunadamente, los métodos de testing mencionados no son suficientes para prevenir errores de interfaz. Las interfaces de usuario son difíciles de probar porque el diseño es subjetivo y matizado. Las pruebas visuales son demasiado manuales, las pruebas instantáneas desencadenan demasiados falsos positivos cuando se utilizan para la interfaz de usuario, y las pruebas unitarias a nivel de píxel son de poco valor. Una estrategia completa de pruebas de Storybook también incluye pruebas de regresión visual.</p>\\n<h2>Pruebas de regresión visual para Storybook</h2>\\n<p>Las pruebas de regresión visual están diseñadas para detectar cambios en la apariencia. Funcionan haciendo capturas de pantalla de todas las historias y comparando con los cambios superficiales. Esto es perfecto para verificar elementos gráficos como diseño, color, tamaño y contraste.</p>\\n<video autoPlay muted playsInline loop style=\\\"width:480px; margin: 0 auto;\\\">\\n  <source\\n    src=\\\"/visual-regression-testing.mp4\\\"\\n    type=\\\"video/mp4\\\"\\n  />\\n</video>\\n<p>Storybook es una herramienta fantástica para las pruebas de regresión visual porque cada historia es esencialmente una especificación del test. Cada vez que escribimos o actualizamos una historia recibimos una especificación gratis!</p>\\n<p>Existen varias herramientas para la prueba de regresión visual. Para equipos profesionales recomendamos <a href=\\\"https://www.chromaticqa.com/\\\"><strong>Chromatic</strong></a>, un complemento hecho por las personas de Storybook que ejecuta pruebas en la nube.</p>\\n<h2>Configurar pruebas de regresión visual</h2>\\n<p>Chromatic es un complemento de Storybook para pruebas de regresión visual y revisión en la nube. Dado que es un servicio de pago (con una prueba gratuita), puede que no sea para todos. Sin embargo, Chromatic es un ejemplo instructivo de un flujo de trabajo de pruebas visuales de producción que probaremos gratuitamente. Echemos un vistazo.</p>\\n<h3>Iniciando Git</h3>\\n<p>Primero tienes que configurar Git para tu proyecto en el directorio local. Chromatic usa el historial de Git para hacer un seguimiento de los componentes de tu interfaz de usuario.</p>\\n<pre><code class=\\\"language-bash\\\">$ git init\\n</code></pre>\\n<p>Luego agrega archivos al primer commit.</p>\\n<pre><code class=\\\"language-bash\\\">$ git add .\\n</code></pre>\\n<p>Ahora haz commit de los archivos.</p>\\n<pre><code class=\\\"language-bash\\\">$ git commit -m \\\"taskbox UI\\\"\\n</code></pre>\\n<h3>Añadiendo Chromatic</h3>\\n<p>Agregando el paquete como una dependencia.</p>\\n<pre><code class=\\\"language-bash\\\">yarn add storybook-chromatic\\n</code></pre>\\n<p>Importa Chromatic en tu archivo <code>.storybook/config.js</code>.</p>\\n<pre><code class=\\\"language-javascript\\\">import { configure } from '@storybook/react';\\nimport 'storybook-chromatic/storybook-addon';\\n\\nimport '../src/index.css';\\n\\nconst req = require.context('../src/components', true, /\\\\.stories\\\\.js$/);\\n\\nfunction loadStories() {\\n  req.keys().forEach(filename => req(filename));\\n}\\n\\nconfigure(loadStories, module);\\n</code></pre>\\n<p>Ahora <a href=\\\"https://chromaticqa.com/start\\\">logueate en Chromatic</a> con tú cuenta de GitHub (Chromatic solo te pedirá algunos permisos simples). Crea un proyecto con nombre \\\"taskbox\\\" y copia tu <code>app-code</code> único.</p>\\n<video autoPlay muted playsInline loop style=\\\"width:520px; margin: 0 auto;\\\">\\n  <source\\n    src=\\\"/chromatic-setup-learnstorybook.mp4\\\"\\n    type=\\\"video/mp4\\\"\\n  />\\n</video>\\n<p>Ejecuta el comando de prueba en la línea de comandos para configurar las pruebas de regresión visual para Storybook. No olvides añadir tu código de aplicación único en el <code>&#x3C;app-code></code>.</p>\\n<pre><code class=\\\"language-bash\\\">./node_modules/.bin/chromatic test --storybook-addon --app-code=&#x3C;app-code> --do-not-start\\n</code></pre>\\n<div class=\\\"aside\\\">\\n<code>--do-not-start</code> es una opción que le dice a Chromatic que no inicie Storybook. Usa esto si ya tienes a Storybook corriendo. Si no, omite el <code>--do-not-start</code>.\\n</div>\\n<p>Una vez el primer test esté completo, tenemos líneas base de prueba para cada historia. En otras palabras, capturas de cada historia que ya se conocen como \\\"buenas\\\". Los futuros cambios a estas historias serán comparados con estás lineas base.</p>\\n<p><img src=\\\"/chromatic-baselines.png\\\" alt=\\\"Chromatic baselines\\\"></p>\\n<h2>Capturando un cambio en la interfaz de usuario</h2>\\n<p>La prueba de regresión visual se basa en la comparación de imágenes del nuevo código de la interfaz de usuario renderizado con las imágenes de la línea base. Si se detecta un cambio en la interfaz de usuario, se notificará. Vea cómo funciona ajustando el fondo del componente <code>Tareas</code>:</p>\\n<p><img src=\\\"/chromatic-change-to-task-component.png\\\" alt=\\\"code change\\\"></p>\\n<p>Esto produce un nuevo color de fondo para el artículo.</p>\\n<p><img src=\\\"/chromatic-task-change.png\\\" alt=\\\"task background change\\\"></p>\\n<p>Usa el comando de prueba anterior para ejecutar otra prueba cromática.</p>\\n<pre><code class=\\\"language-bash\\\">./node_modules/.bin/chromatic test --storybook-addon --app-code=&#x3C;app-code> --do-not-start\\n</code></pre>\\n<p>Sigue el enlace a la interfaz de usuario web donde verá los cambios.</p>\\n<p><img src=\\\"/chromatic-catch-changes.png\\\" alt=\\\"UI changes in Chromatic\\\"></p>\\n<p>Hay muchos cambios! La jerarquía de componentes donde <code>Task</code> es hijo de <code>TaskList</code> y <code>Inbox</code> significa un pequeño giro de bolas de nieve en regresiones mayores. Esta circunstancia es precisamente la razón por la que los desarrolladores necesitan pruebas de regresión visual además de otros métodos de pruebas.</p>\\n<p><img src=\\\"/minor-major-regressions.gif\\\" alt=\\\"UI minor tweaks major regressions\\\"></p>\\n<h2>Revisando cambios</h2>\\n<p>Las pruebas de regresión visual aseguran que los componentes no cambien por accidente. Pero todavía depende de ti determinar si los cambios son intencionales o no.</p>\\n<p>Si un cambio es intencional, es necesario actualizar la línea base para que las pruebas futuras se comparen con la última versión de la historia. Si un cambio no es intencional, debe ser corregido.</p>\\n<video autoPlay muted playsInline loop style=\\\"width:480px; margin: 0 auto;\\\">\\n  <source\\n    src=\\\"/website-workflow-review-merge-optimized.mp4\\\"\\n    type=\\\"video/mp4\\\"\\n  />\\n</video>\\n<p>Dado que las aplicaciones modernas se construyen a partir de componentes, es importante que probemos a nivel de componentes. Hacerlo nos ayuda a identificar la causa raíz de un cambio, el componente, en lugar de reaccionar a los síntomas de un cambio, las pantallas y los componentes compuestos.</p>\\n<h2>Fusionando cambios</h2>\\n<p>Cuando hayamos terminado de revisar, estaremos listos para fusionar o hacer \\\"merge\\\" de los cambios en la interfaz de usuario con confianza, sabiendo que las actualizaciones no introducirán errores accidentalmente. Si te gusta el nuevo fondo <code>papayawhip</code> entonces acepta los cambios, si no, vuelve al estado anterior.</p>\\n<p><img src=\\\"/chromatic-review-finished.png\\\" alt=\\\"Changes ready to be merged\\\"></p>\\n<p>Storybook te ayuda a <strong>construir</strong> componentes; las pruebas te ayudan a <strong>mantenerlos</strong>. Los cuatro tipos de pruebas de interfaz de usuario que se tratan en este tutorial son las pruebas visuales, de instantánea, unitarios y de regresión visual. Puede automatizar los tres últimos añadiéndolos a su script CI. Esto le ayuda a enviar componentes sin tener que preocuparse por los bugs polizones. A continuación se ilustra todo el flujo de trabajo.</p>\\n<p><img src=\\\"/cdd-review-workflow.png\\\" alt=\\\"Visual regression testing workflow\\\"></p>\",\"excerpt\":\"Testear Componentes UI Ningún tutorial de Storybook estaría completo sin hacer test. Las pruebas son esenciales para crear interfaces de usuario de alta calidad. En los sistemas modulares, los ajustes minúsculos pueden dar lugar a regresiones…\",\"frontmatter\":{\"path\":null,\"title\":\"Testing\"}}},{\"node\":{\"id\":\"/Users/luz/code/js/binstd.github.io/markdown/docs/zh/composite-component.md absPath of file >>> MarkdownRemark\",\"html\":\"<h1>组装复合组件</h1>\\n<p>上一章我们构建了第一个组件; 本章 我们学习 扩展构建TaskList的任务列表. 让我们将 组件组合 在一起,看看在引入更多复杂性时会发生什么. </p>\\n<h2>任务列表</h2>\\n<p>Taskbox 通过将 固定任务 置于默认任务之上 来强调 固定任务. 这产生了两种变体<code>TaskList</code>您需要为以下内容创建故事: 默认项目 以及 默认和 固定项目. </p>\\n<p><img src=\\\"/tasklist-states-1.png\\\" alt=\\\"default and pinned tasks\\\"></p>\\n<p><code>Task</code>可以异步发送数据,我们 <strong>也</strong>需要在没有连接的情况下 loading 渲染 <em>右图</em>. 此外,当没有任务时,需要 空状态 <em>左图</em>. </p>\\n<p><img src=\\\"/tasklist-states-2.png\\\" alt=\\\"empty and loading tasks\\\"></p>\\n<h2>获取设置</h2>\\n<p>复合组件与 其包含的基本组件没有太大区别. 创建一个<code>TaskList</code>组件和 对应的故事文件: <code>src/components/TaskList.js</code>和<code>src/components/TaskList.stories.js</code>. </p>\\n<p>从粗略的实现开始<code>TaskList</code>. 你需要导入早期的<code>Task</code>组件,并将 属性和操作 作为输入传递. </p>\\n<pre><code class=\\\"language-javascript\\\">import React from 'react';\\n\\nimport Task from './Task';\\n\\nfunction TaskList({ loading, tasks, onPinTask, onArchiveTask }) {\\n  const events = {\\n    onPinTask,\\n    onArchiveTask,\\n  };\\n\\n  if (loading) {\\n    return &#x3C;div className=\\\"list-items\\\">loading&#x3C;/div>;\\n  }\\n\\n  if (tasks.length === 0) {\\n    return &#x3C;div className=\\\"list-items\\\">empty&#x3C;/div>;\\n  }\\n\\n  return (\\n    &#x3C;div className=\\\"list-items\\\">\\n      {tasks.map(task => &#x3C;Task key={task.id} task={task} {...events} />)}\\n    &#x3C;/div>\\n  );\\n}\\n\\nexport default TaskList;\\n</code></pre>\\n<p>接下来创建<code>Tasklist</code>故事文件中的测试状态. </p>\\n<pre><code class=\\\"language-javascript\\\">import React from 'react';\\nimport { storiesOf } from '@storybook/react';\\n\\nimport TaskList from './TaskList';\\nimport { task, actions } from './Task.stories';\\n\\nexport const defaultTasks = [\\n  { ...task, id: '1', title: 'Task 1' },\\n  { ...task, id: '2', title: 'Task 2' },\\n  { ...task, id: '3', title: 'Task 3' },\\n  { ...task, id: '4', title: 'Task 4' },\\n  { ...task, id: '5', title: 'Task 5' },\\n  { ...task, id: '6', title: 'Task 6' },\\n];\\n\\nexport const withPinnedTasks = [\\n  ...defaultTasks.slice(0, 5),\\n  { id: '6', title: 'Task 6 (pinned)', state: 'TASK_PINNED' },\\n];\\n\\nstoriesOf('TaskList', module)\\n  .addDecorator(story => &#x3C;div style={{ padding: '3rem' }}>{story()}&#x3C;/div>)\\n  .add('default', () => &#x3C;TaskList tasks={defaultTasks} {...actions} />)\\n  .add('withPinnedTasks', () => &#x3C;TaskList tasks={withPinnedTasks} {...actions} />)\\n  .add('loading', () => &#x3C;TaskList loading tasks={[]} {...actions} />)\\n  .add('empty', () => &#x3C;TaskList tasks={[]} {...actions} />);\\n</code></pre>\\n<p><code>addDecorator()</code>允许我们为每个任务的渲染添加一些\\\"上下文\\\". 在这种情况下,我们在列表周围添加 <em>填充-padding</em>,以便更容易进行 可视化验证. </p>\\n<div class=\\\"aside\\\">\\n<a href=\\\"https://storybook.js.org/addons/introduction/#1-decorators\\\"><b>Decorators-装饰器</b></a> 是一种为 故事 提供任意包装的方法。 在这种情况下，我们使用装饰器来添加样式。 它们还可以用于包装故事在 <b>\\\"providers\\\" - 设置 React上下文 的库组件</b>.\\n</div>\\n<p><code>task</code>提供一个<code>Task</code>的形状,这是通过我们创建和导出的<code>Task.stories.js</code>文件. 同样的,<code>actions</code>定义<code>Task</code>组件期望的操作 (模拟回调) ,其中<code>TaskList</code>也需要. </p>\\n<p>现在查看 Storybook的新内容<code>TaskList</code>故事. </p>\\n<video autoPlay muted playsInline loop>\\n  <source\\n    src=\\\"/inprogress-tasklist-states.mp4\\\"\\n    type=\\\"video/mp4\\\"\\n  />\\n</video>\\n<h2>建立状态</h2>\\n<p>我们的组件仍然很粗糙,但现在我们已经了解了 要努力的故事. 你可能会想到<code>.list-items</code>包装过于简单化. 你是对的 - 在大多数情况下,我们不会只是添加一个包装器来创建一个新的组件. 但是 <strong>真正的复杂性</strong> 的<code>TaskList</code>组件在边缘情况下会显示<code>withPinnedTasks</code>,<code>loading</code>,和<code>empty</code>. </p>\\n<pre><code class=\\\"language-javascript\\\">import React from 'react';\\n\\nimport Task from './Task';\\n\\nfunction TaskList({ loading, tasks, onPinTask, onArchiveTask }) {\\n  const events = {\\n    onPinTask,\\n    onArchiveTask,\\n  };\\n\\n  const LoadingRow = (\\n    &#x3C;div className=\\\"loading-item\\\">\\n      &#x3C;span className=\\\"glow-checkbox\\\" />\\n      &#x3C;span className=\\\"glow-text\\\">\\n        &#x3C;span>Loading&#x3C;/span> &#x3C;span>cool&#x3C;/span> &#x3C;span>state&#x3C;/span>\\n      &#x3C;/span>\\n    &#x3C;/div>\\n  );\\n\\n  if (loading) {\\n    return (\\n      &#x3C;div className=\\\"list-items\\\">\\n        {LoadingRow}\\n        {LoadingRow}\\n        {LoadingRow}\\n        {LoadingRow}\\n        {LoadingRow}\\n        {LoadingRow}\\n      &#x3C;/div>\\n    );\\n  }\\n\\n  if (tasks.length === 0) {\\n    return (\\n      &#x3C;div className=\\\"list-items\\\">\\n        &#x3C;div className=\\\"wrapper-message\\\">\\n          &#x3C;span className=\\\"icon-check\\\" />\\n          &#x3C;div className=\\\"title-message\\\">You have no tasks&#x3C;/div>\\n          &#x3C;div className=\\\"subtitle-message\\\">Sit back and relax&#x3C;/div>\\n        &#x3C;/div>\\n      &#x3C;/div>\\n    );\\n  }\\n\\n  const tasksInOrder = [\\n    ...tasks.filter(t => t.state === 'TASK_PINNED'), //&#x3C; ==== 固定顶部\\n    ...tasks.filter(t => t.state !== 'TASK_PINNED'),\\n  ];\\n\\n  return (\\n    &#x3C;div className=\\\"list-items\\\">\\n      {tasksInOrder.map(task => &#x3C;Task key={task.id} task={task} {...events} />)}\\n    &#x3C;/div>\\n  );\\n}\\n\\nexport default TaskList;\\n</code></pre>\\n<p>添加的标记会产生以下UI: </p>\\n<video autoPlay muted playsInline loop>\\n  <source\\n    src=\\\"/finished-tasklist-states.mp4\\\"\\n    type=\\\"video/mp4\\\"\\n  />\\n</video>\\n<p>请注意列表中 固定项 的位置. 我们希望固定项目在 列表顶部 呈现,以使其成为我们用户的优先事项. </p>\\n<h2>数据要求和props</h2>\\n<p>随着组件的增长,输入要求也在增长. 要求定义<code>TaskList</code>的<em>props</em>. 因为<code>Task</code>是一个子组件,请确保提供 正确形状的数据 来呈现它. 为了节省时间和头痛,请重用您定义的早期<code>Task</code>的propTypes. </p>\\n<pre><code class=\\\"language-javascript\\\">import React from 'react';\\nimport PropTypes from 'prop-types';\\n\\nfunction TaskList() {\\n  ...\\n}\\n\\n\\nTaskList.propTypes = {\\n  loading: PropTypes.bool,\\n  tasks: PropTypes.arrayOf(Task.propTypes.task).isRequired,\\n  onPinTask: PropTypes.func.isRequired,\\n  onArchiveTask: PropTypes.func.isRequired,\\n};\\n\\nTaskList.defaultProps = {\\n  loading: false,\\n};\\n\\nexport default TaskList;\\n</code></pre>\\n<h2>自动化测试</h2>\\n<p>在上一章中,我们学习了如何使用 Storyshots快照测试 故事. <code>Task</code>测试没有太多的复杂性,已然够用了. 而<code>TaskList</code>增加了另一层复杂性,我们希望 以 自动测试 的方式验证 某些输入产生某些输出. 为此,我们将使用创建单 元测试<a href=\\\"https://facebook.github.io/jest/\\\">jest-笑话</a>再加上测试渲染器等<a href=\\\"http://airbnb.io/enzyme/\\\">Enzyme</a>. </p>\\n<p><img src=\\\"/logo-jest.png\\\" alt=\\\"Jest logo\\\"></p>\\n<h3>用Jest进行单元测试</h3>\\n<p> Storybook故事 与 手动可视化测试 和 快照测试 (见上文) 相结合,可以避免 UI错误. 如果故事 涵盖了 各种各样的组件用例,并且我们使用的工具可以确保 人员检查故事的任何变化,那么错误的可能性就大大降低. </p>\\n<p>然而,有时候魔鬼是在细节中. 需要一个明确有关这些细节的测试框架. 这让我们进行了单元测试. </p>\\n<p>在我们的例子中,我们希望我们的<code>TaskList</code>,在传递 不固定tasks 之前,呈现所有固定tasks. 虽然我们有一个故事 (<code>withPinnedTasks</code>) 测试这个确切的场景; 但是如果组件停止对 这样的任务 进行排序，那么就人类看着来说，这可能是不明确的,<em>因为只看到表面与操作</em>, 这是一个bug. 它肯定不会尖叫 <strong>\\\"错误!\\\"</strong> 直怼眼睛. </p>\\n<p>因此,为了避免这个问题,我们可以使用Jest 将故事呈现给<code>DOM</code>,并运行一些<code>DOM</code>查询代码,来验证输出的显着特征. </p>\\n<p>创建一个名为的测试文件<code>TaskList.test.js</code>. 在这里,我们将构建我们的测试,对输出进行断言. </p>\\n<pre><code class=\\\"language-javascript\\\">import React from 'react';\\nimport ReactDOM from 'react-dom';\\nimport TaskList from './TaskList';\\nimport { withPinnedTasks } from './TaskList.stories';\\n\\nit('renders pinned tasks at the start of the list', () => {\\n  const div = document.createElement('div');\\n  const events = { onPinTask: jest.fn(), onArchiveTask: jest.fn() };\\n  ReactDOM.render(&#x3C;TaskList tasks={withPinnedTasks} {...events} />, div);\\n\\n  // 我们期望首先渲染标题为“任务6（固定）”的任务，而不是最后\\n  const lastTaskInput = div.querySelector('.list-item:nth-child(1) input[value=\\\"Task 6 (pinned)\\\"]');\\n  expect(lastTaskInput).not.toBe(null);\\n\\n  ReactDOM.unmountComponentAtNode(div);\\n});\\n</code></pre>\\n<p><img src=\\\"/tasklist-testrunner.png\\\" alt=\\\"TaskList test runner\\\"></p>\\n<p>请注意,我们已经能够重用<code>withPinnedTasks</code>故事 和单元测试中的任务列表;通过这种方式,我们可以继续以越来越多的方式利用现有资源(代表组件的有趣配置的示例) . </p>\\n<p>另请注意,此测试非常脆弱. 随着项目的成熟,以及项目的确切实现,这都可能是<code>Task</code>的更改 - 可能使用 不同的类名或<code>textarea</code>而不是一个<code>input</code>- 测试将失败,需要更新. 这不一定是一个问题,但使用UI的 单元测试 要小心的指示. 它们不容易维护. 替代的是依靠视觉,快照和视觉回归 (参见<a href=\\\"/test/\\\">测试章节</a>) 的 Stortbook测试. </p>\",\"excerpt\":\"组装复合组件 上一章我们构建了第一个组件; 本章 我们学习 扩展构建TaskList的任务列表. 让我们将 组件组合 在一起,看看在引入更多复杂性时会发生什么.  任务列表 Taskbox 通过将 固定任务 置于默认任务之上 来强调 固定任务. 这产生了两种变体 TaskList 您需要为以下内容创建故事: 默认项目 以及 默认和 固定项目.  Task 可以异步发送数据,我们  也 需要在没有连接的情况下 loading…\",\"frontmatter\":{\"path\":null,\"title\":\"组装复合组件\"}}},{\"node\":{\"id\":\"/Users/luz/code/js/binstd.github.io/markdown/docs/zh/conclusion.md absPath of file >>> MarkdownRemark\",\"html\":\"<h1>结论</h1>\\n<p>恭喜! 您在Storybook中创建了第一个UI. 在此过程中,您学习了如何构建,组合,测试和部署UI组件. 如果您一直关注,您的 repo和部署的Storybook 应如下所示: </p>\\n<p><a href=\\\"https://github.com/hichroma/learnstorybook-code\\\">📕<strong>GitHub回购: hichroma / learnstorybook-code</strong></a>\\n<br/>\\n<a href=\\\"https://clever-banach-415c03.netlify.com/\\\">🌎<strong>部署 Storybook</strong></a></p>\\n<p>Storybook是 React,Vue和Angular 的强大工具. 它拥有蓬勃发展的开发者社区和丰富的插件. 这篇介绍揭示了可能的表面. 我们相信,一旦您采用了Storybook,您将会对构建持久UI的效率印象深刻. </p>\\n<h2>学到更多</h2>\\n<p>想深入了解? 这是有用的资源. </p>\\n<ul>\\n<li>\\n<p><a href=\\\"https://storybook.js.org/basics/introduction/\\\"><strong>官方 Storybook文档</strong></a>有API文档,社区链接和插件库. </p>\\n</li>\\n<li>\\n<p><a href=\\\"https://blog.hichroma.com/the-delightful-storybook-workflow-b322b76fd07\\\"><strong>令人愉快的 Storybook工作流程</strong></a> 重点介绍Squarespace,Major League Soccer,Discovery Network和 Apollo GraphQL 的高速团队使用的工作流程最佳实践. </p>\\n</li>\\n<li>\\n<p><a href=\\\"https://www.chromaticqa.com/book/visual-testing-handbook\\\"><strong>视觉测试手册</strong></a>深入探讨将 Storybook 用于可视化测试组件. 免费的31页电子书. </p>\\n</li>\\n</ul>\\n<h2>谁制作了 LearnStorybook.com?</h2>\\n<p>文本,代码和制作都是由<a href=\\\"http://blog.hichroma.com/\\\">Chroma</a>. 该教程的灵感来自 Chroma的流行<a href=\\\"https://blog.hichroma.com/graphql-react-tutorial-part-1-6-d0691af25858\\\">GraphQL + React教程系列</a>. </p>\\n<p>想要更多这样的教程和文章吗? 注册 Chroma 邮件列表. </p>\\n<iframe style=\\\"height:400px;width:100%;max-width:800px;margin:30px auto;\\\" src=\\\"https://upscri.be/bface0?as_embed\\\"></iframe>\",\"excerpt\":\"结论 恭喜! 您在Storybook中创建了第一个UI. 在此过程中,您学习了如何构建,组合,测试和部署UI组件. 如果您一直关注,您的 repo和部署的Storybook 应如下所示:  📕 GitHub回购: hichroma / learnstorybook-code \\n \\n 🌎 部署 Storybook Storybook是 React,Vue和Angular 的强大工具. 它拥有蓬勃发展的开发者社区和丰富的插件. 这篇介绍揭示了可能的表面. 我们相信,一旦您采用了Storybook…\",\"frontmatter\":{\"path\":null,\"title\":\"总结\"}}},{\"node\":{\"id\":\"/Users/luz/code/js/binstd.github.io/markdown/docs/zh/contribute.md absPath of file >>> MarkdownRemark\",\"html\":\"<h1>帮忙帮忙</h1>\\n<p>鼓励学习 Storybook的贡献! 如果它像 语法或标点符号 那样小,请打开拉取请求. 如果这是一个更大的变化,<a href=\\\"https://github.com/hichroma/learnstorybook.com/issues\\\">添加一个问题</a>讨论. </p>\\n<h2>Vue和Angular版本</h2>\\n<p>我们正在寻找帮助将 React/Redux示例代码 更新为 Vue和Angular 的帮助. 评论<a href=\\\"https://github.com/hichroma/learnstorybook.com/issues/1\\\">Vue</a>要么<a href=\\\"https://github.com/hichroma/learnstorybook.com/issues/2\\\">Angular</a> GitHub问题. </p>\\n<p><img src=\\\"/logos-angular-vue.png\\\" alt=\\\"Vue and Angular contributors wanted\\\"></p>\\n<h2>翻译</h2>\\n<p>我们的目标是让所有人都能接触 Storybook. 帮助将本教程翻译成其他语言. 我们对 中文和西班牙文翻译 特别开放. 评论<a href=\\\"https://github.com/hichroma/learnstorybook.com/issues/3\\\">问题在这里</a>. </p>\",\"excerpt\":\"帮忙帮忙 鼓励学习 Storybook的贡献! 如果它像 语法或标点符号 那样小,请打开拉取请求. 如果这是一个更大的变化, 添加一个问题 讨论.  Vue和Angular版本 我们正在寻找帮助将 React/Redux示例代码 更新为 Vue和Angular 的帮助. 评论 Vue 要么 Angular  GitHub问题.  翻译 我们的目标是让所有人都能接触 Storybook. 帮助将本教程翻译成其他语言. 我们对 中文和西班牙文翻译 特别开放. 评论 问题在这里 . \",\"frontmatter\":{\"path\":null,\"title\":\"帮助我们\"}}},{\"node\":{\"id\":\"/Users/luz/code/js/binstd.github.io/markdown/docs/zh/data.md absPath of file >>> MarkdownRemark\",\"html\":\"<h1>连线数据</h1>\\n<p>到目前为止,我们创建了孤立的无状态组件 - Storybook很棒,但作用不大,除非我们在应用程序中为他们提供一些数据. </p>\\n<p>本教程不关注构建应用程序的细节,因此我们不会在此处深入研究这些细节. 但我们将花点时间研究一下 与容器组件 连接数据 的常见模式. </p>\\n<h2>容器组件</h2>\\n<p>我们的<code>TaskList</code>目前编写的组件是\\\"表现性的\\\" (见<a href=\\\"https://medium.com/@dan_abramov/smart-and-dumb-components-7ca2f9a7c7d0\\\">这篇博文</a>) 因为它不会与 其自身实现之外 的任何内容交谈. 为了获取数据,我们需要一个\\\"容器\\\". </p>\\n<p>这个例子使用<a href=\\\"https://redux.js.org/\\\">Redux</a>,最流行的React库,用于存储数据,为我们的应用程序构建一个简单的数据模型. 但是,此处使用的模式同样适用于其他数据管理库<a href=\\\"https://www.apollographql.com/client/\\\">阿波罗</a>和<a href=\\\"https://mobx.js.org/\\\">MobX</a>. </p>\\n<p>首先,我们将构建一个简单的Redux存储,它在一个<code>src/lib/redux.js</code>中定义改变任务状态的操作 (故意保持简单) : </p>\\n<pre><code class=\\\"language-javascript\\\">// 一个简单的 redux store/actions/reducer 实现。\\n// 一个真正的应用程序将更复杂，并分为不同的文件.\\nimport { createStore } from 'redux';\\n\\n// 这些行为是可能发生的store变化的“名称”\\nexport const actions = {\\n  ARCHIVE_TASK: 'ARCHIVE_TASK',\\n  PIN_TASK: 'PIN_TASK',\\n};\\n\\n// 动作创建者是将动作与 要求的数据捆绑在一起的方式\\nexport const archiveTask = id => ({ type: actions.ARCHIVE_TASK, id });\\nexport const pinTask = id => ({ type: actions.PIN_TASK, id });\\n\\n// 我们所有的Reducer都只是改变了一个任务的状态。\\nfunction taskStateReducer(taskState) {\\n  return (state, action) => {\\n    return {\\n      ...state,\\n      tasks: state.tasks.map(\\n        task => (task.id === action.id ? { ...task, state: taskState } : task)\\n      ),\\n    };\\n  };\\n}\\n\\n// reducer描述了 Store 中每个 action 如何改变内容\\n\\nexport const reducer = (state, action) => {\\n  switch (action.type) {\\n    case actions.ARCHIVE_TASK:\\n      return taskStateReducer('TASK_ARCHIVED')(state, action);\\n    case actions.PIN_TASK:\\n      return taskStateReducer('TASK_PINNED')(state, action);\\n    default:\\n      return state;\\n  }\\n};\\n\\n// 应用加载时我们Store 的初始状态。\\n\\n// 通常你会从服务器上获取它\\nconst defaultTasks = [\\n  { id: '1', title: 'Something', state: 'TASK_INBOX' },\\n  { id: '2', title: 'Something more', state: 'TASK_INBOX' },\\n  { id: '3', title: 'Something else', state: 'TASK_INBOX' },\\n  { id: '4', title: 'Something again', state: 'TASK_INBOX' },\\n];\\n\\n// 我们导出构造的 redux store\\nexport default createStore(reducer, { tasks: defaultTasks });\\n</code></pre>\\n<p>然后我们将更新默认导出<code>TaskList</code>组件连接到Redux存储,并呈现我们感兴趣的任务: </p>\\n<pre><code class=\\\"language-javascript\\\">import React from 'react';\\nimport PropTypes from 'prop-types';\\n\\nimport Task from './Task';\\nimport { connect } from 'react-redux';\\nimport { archiveTask, pinTask } from '../lib/redux';\\n\\nexport function PureTaskList({ loading, tasks, onPinTask, onArchiveTask }) {\\n  /* 以前的 TaskList 实现 */\\n}\\n\\nPureTaskList.propTypes = {\\n  loading: PropTypes.bool,\\n  tasks: PropTypes.arrayOf(Task.propTypes.task).isRequired,\\n  onPinTask: PropTypes.func.isRequired,\\n  onArchiveTask: PropTypes.func.isRequired,\\n};\\n\\nPureTaskList.defaultProps = {\\n  loading: false,\\n};\\n\\nexport default connect(\\n  ({ tasks }) => ({\\n    tasks: tasks.filter(t => t.state === 'TASK_INBOX' || t.state === 'TASK_PINNED'),\\n  }),\\n  dispatch => ({\\n    onArchiveTask: id => dispatch(archiveTask(id)),\\n    onPinTask: id => dispatch(pinTask(id)),\\n  })\\n)(PureTaskList);\\n</code></pre>\\n<p>在这个阶段,我们的 Storybook测试将停止工作,因为<code>TaskList</code>现在是一个容器,不再需要任何 props,而是连接到 Store 并设置<code>PureTaskList</code>包裹组件的props. </p>\\n<p>但是,我们可以通过简单地渲染<code>PureTaskList</code>来轻松解决这个问题 - 我们的 Storybook故事中的表现部分: </p>\\n<pre><code class=\\\"language-javascript\\\">import React from 'react';\\nimport { storiesOf } from '@storybook/react';\\n\\nimport { PureTaskList } from './TaskList';\\nimport { task, actions } from './Task.stories';\\n\\nexport const defaultTasks = [\\n  { ...task, id: '1', title: 'Task 1' },\\n  { ...task, id: '2', title: 'Task 2' },\\n  { ...task, id: '3', title: 'Task 3' },\\n  { ...task, id: '4', title: 'Task 4' },\\n  { ...task, id: '5', title: 'Task 5' },\\n  { ...task, id: '6', title: 'Task 6' },\\n];\\n\\nexport const withPinnedTasks = [\\n  ...defaultTasks.slice(0, 5),\\n  { id: '6', title: 'Task 6 (pinned)', state: 'TASK_PINNED' },\\n];\\n\\nstoriesOf('TaskList', module)\\n  .addDecorator(story => &#x3C;div style={{ padding: '3rem' }}>{story()}&#x3C;/div>)\\n  .add('default', () => &#x3C;PureTaskList tasks={defaultTasks} {...actions} />)\\n  .add('withPinnedTasks', () => &#x3C;PureTaskList tasks={withPinnedTasks} {...actions} />)\\n  .add('loading', () => &#x3C;PureTaskList loading tasks={[]} {...actions} />)\\n  .add('empty', () => &#x3C;PureTaskList tasks={[]} {...actions} />);\\n</code></pre>\\n<video autoPlay muted playsInline loop>\\n  <source\\n    src=\\\"/finished-tasklist-states.mp4\\\"\\n    type=\\\"video/mp4\\\"\\n  />\\n</video>\\n<p>同样,我们需要使用<code>PureTaskList</code>在我们的Jest测试中: </p>\\n<pre><code class=\\\"language-js\\\">import React from 'react';\\nimport ReactDOM from 'react-dom';\\nimport { PureTaskList } from './TaskList';\\nimport { withPinnedTasks } from './TaskList.stories';\\n\\nit('renders pinned tasks at the start of the list', () => {\\n  const div = document.createElement('div');\\n  const events = { onPinTask: jest.fn(), onArchiveTask: jest.fn() };\\n  ReactDOM.render(&#x3C;PureTaskList tasks={withPinnedTasks} {...events} />, div);\\n\\n  // 我们期望首先渲染标题为“任务6（固定）”的任务，而不是最后\\n  const lastTaskInput = div.querySelector('.list-item:nth-child(1) input[value=\\\"Task 6 (pinned)\\\"]');\\n  expect(lastTaskInput).not.toBe(null);\\n\\n  ReactDOM.unmountComponentAtNode(div);\\n});\\n</code></pre>\",\"excerpt\":\"连线数据 到目前为止,我们创建了孤立的无状态组件 - Storybook很棒,但作用不大,除非我们在应用程序中为他们提供一些数据.  本教程不关注构建应用程序的细节,因此我们不会在此处深入研究这些细节. 但我们将花点时间研究一下 与容器组件 连接数据 的常见模式.  容器组件 我们的 TaskList 目前编写的组件是\\\"表现性的\\\" (见 这篇博文 ) 因为它不会与 其自身实现之外 的任何内容交谈. 为了获取数据,我们需要一个\\\"容器\\\".  这个例子使用 Redux ,最流行的React…\",\"frontmatter\":{\"path\":null,\"title\":\"接连data\"}}},{\"node\":{\"id\":\"/Users/luz/code/js/binstd.github.io/markdown/docs/zh/deploy.md absPath of file >>> MarkdownRemark\",\"html\":\"<h1>部署 Storybook</h1>\\n<p>在本教程中,我们在开发机器上运行了Storybook. 您可能还想与团队分享该 Storybook,尤其是非技术成员. 值得庆幸的是,在线部署 Storybook 很容易. </p>\\n<div class=\\\"aside\\\">\\n<strong>您之前是否安装过Chromatic 测试？?</strong>\\n<br/>\\n🎉 你的故事已经部署好了！ Chromatic 在线安全地为您的故事编制索引，并在分支和提交中跟踪它们。 跳过这一章，然后转到 <a href=\\\"/conclusion\\\">总结</a>.\\n</div>\\n<h2>导出为静态应用程序</h2>\\n<p>要部署Storybook,我们首先需要将其导出为 静态Web应用程序. 这个功能已经内置到 Storybook中,我们只需要通过添加脚本来激活它<code>package.json</code>. </p>\\n<pre><code class=\\\"language-javascript\\\">{\\n  \\\"scripts\\\": {\\n    \\\"build-storybook\\\": \\\"build-storybook -c .storybook -o .storybook-static\\\"\\n  }\\n}\\n</code></pre>\\n<p>现在当你运行<code>npm run build-storybook</code>,它会输出一个 静态的<code>storybook-static</code>目录. </p>\\n<h2>持续部署</h2>\\n<p>我们希望在推送代码时共享最新版本的组件. 为此,我们需要不断部署Storybook. 我们将依靠 GitHub和Netlify 来部署我们的静态站点. 我们正在使用 Netlify免费计划. </p>\\n<h3>GitHub上</h3>\\n<p>首先,您要在本地目录中为项目设置Git. 如果您从上一个测试章节开始,请跳转到在 GitHub上 设置存储库. </p>\\n<pre><code class=\\\"language-bash\\\">$ git init\\n</code></pre>\\n<p>接下来将文件添加到第一次提交. </p>\\n<pre><code class=\\\"language-bash\\\">$ git add .\\n</code></pre>\\n<p>现在提交文件. </p>\\n<pre><code class=\\\"language-bash\\\">$ git commit -m \\\"taskbox UI\\\"\\n</code></pre>\\n<p>转到GitHub并设置存储库<a href=\\\"https://github.com/new\\\">这里</a>. 将您的仓库命名为\\\"taskbox\\\". </p>\\n<p><img src=\\\"/github-create-taskbox.png\\\" alt=\\\"GitHub setup\\\"></p>\\n<p>在新的repo设置中,复制repo的原始URL,并使用以下命令将其添加到git项目中: </p>\\n<pre><code class=\\\"language-bash\\\">$ git remote add origin https://github.com/&#x3C;your username>/taskbox.git\\n</code></pre>\\n<p>最后将回购推送到GitHub</p>\\n<pre><code class=\\\"language-bash\\\">$ git push -u origin master\\n</code></pre>\\n<h3>Netlify</h3>\\n<p>Netlify内置了持续部署服务,使我们无需配置自己的CI,即可部署Storybook. </p>\\n<div class=\\\"aside\\\">\\n如果您在公司使用CI，请在您上传的配置中添加部署脚本 <code>storybook-static</code> 到像S3这样的静态托管服务.\\n</div>\\n<p><a href=\\\"https://app.netlify.com/start\\\">在Netlify上创建一个帐户</a>然后单击\\\"创建站点\\\". </p>\\n<p><img src=\\\"/netlify-create-site.png\\\" alt=\\\"Netlify create site\\\"></p>\\n<p>然后单击GitHub按钮将,Netlify连接到GitHub. 这允许它访问我们的远程 Taskbox 仓库. </p>\\n<p>现在从选项列表中选择任务框GitHub repo. </p>\\n<p><img src=\\\"/netlify-account-picker.png\\\" alt=\\\"Netlify connect to repo\\\"></p>\\n<p>通过突出显示在其CI中运行的构建命令,以及输出静态站点的目录 来配置 Netlify. 对于分支选择 <code>master</code>. 目录是<code>storybook-static</code>. <code>yarn build-storybook</code>构建.</p>\\n<p><img src=\\\"/netlify-settings.png\\\" alt=\\\"Netlify settings\\\"></p>\\n<p>提交表单以 构建和部署代码任务箱的<code>master</code>分支. 完成后,我们将在 Netlify上 看到一条确认消息,其中包含指向 Taskbox在线 Storybook 的链接. </p>\\n<p>如果您正在跟进,您部署的 Storybook应该在线<a href=\\\"https://clever-banach-415c03.netlify.com/\\\">像这样</a>.</p>\\n<p><img src=\\\"/netlify-storybook-deploy.png\\\" alt=\\\"Netlify Storybook deploy\\\"></p>\\n<p>我们完成了 Storybook的持续部署! 现在我们可以通过链接与队友分享我们的故事. </p>\\n<p>这有助于视觉 作为 标准应用程序开发过程的 一部分审查 或 仅仅是为了展示工作💅. </p>\",\"excerpt\":\"部署 Storybook 在本教程中,我们在开发机器上运行了Storybook. 您可能还想与团队分享该 Storybook,尤其是非技术成员. 值得庆幸的是,在线部署 Storybook 很容易.  导出为静态应用程序 要部署Storybook,我们首先需要将其导出为 静态Web应用程序. 这个功能已经内置到 Storybook中,我们只需要通过添加脚本来激活它 package.json .  现在当你运行 npm run build-storybook…\",\"frontmatter\":{\"path\":null,\"title\":\"发布 Storybook\"}}},{\"node\":{\"id\":\"/Users/luz/code/js/binstd.github.io/markdown/docs/zh/get-started.md absPath of file >>> MarkdownRemark\",\"html\":\"<h1>开始吧</h1>\\n<p> Storybook 是在开发模式下 与 您的应用程序一起运行的. 它可以帮助您构建UI组件,并与 应用程序的 业务逻辑和上下文 隔离开来. 本期\\\"学习 Storybook\\\"适用于 <strong>React</strong>; <code>Vue和Angular</code>版本即将推出. </p>\\n<p><img src=\\\"/storybook-relationship.jpg\\\" alt=\\\"Storybook and your app\\\"></p>\\n<blockquote>\\n<p>整个页面 -> 拿出各种组件 -> 分隔出 <strong>每个组件</strong> /<code>组件组合</code>用来测试与文档说明</p>\\n</blockquote>\\n<h2>设置React Storybook</h2>\\n<p>我们需要按照几个步骤设置 Storybook 环境. 首先,我们想要使用<a href=\\\"https://github.com/facebook/create-react-app\\\">Create React App</a> (<strong>CRA</strong>) 快速设置我们的环境,并启用<a href=\\\"https://storybook.js.org/\\\">Storybook</a>和<a href=\\\"https://facebook.github.io/jest/\\\"> jest-笑话 </a>测试我们创建的应用. 让我们运行以下命令: </p>\\n<pre><code class=\\\"language-bash\\\"># 创建应用:\\nnpx create-react-app taskbox\\ncd taskbox\\n\\n# 加入 Storybook:\\nnpx -p @storybook/cli getstorybook\\n</code></pre>\\n<p>我们可以快速检查,我们的应用程序的各种命令是否正常工作: </p>\\n<pre><code class=\\\"language-bash\\\"># 运行 测试引擎(Jest):\\nyarn test\\n\\n# 启动 storybook 在端口:9009 :\\nyarn run storybook\\n\\n# 启动 前端 页面 在端口:3000:\\nyarn start\\n</code></pre>\\n<div class=\\\"aside\\\">\\n  注意: 如果 <code>yarn test</code> 运行错误, 你可能需要安装 <code>watchman</code> 具体问题来自 <a href=\\\"https://github.com/facebook/create-react-app/issues/871#issuecomment-252297884\\\">这个Issue</a>.\\n</div>\\n<p>我们的三个前端应用程序模式: 自动化测试 (Jest) ,组件开发 (Storybook) 和 应用程序本身. </p>\\n<p><img src=\\\"/app-three-modalities.png\\\" alt=\\\"3 modalities\\\"></p>\\n<p>根据您正在处理的应用程序的哪个部分,您可能希望同时运行其中一个或多个. 由于我们目前的重点是创建单个UI组件,因此我们将坚持运行 Storybook. </p>\\n<h2>重用CSS</h2>\\n<p>本例子<code>Taskbox</code> 重用了 <a href=\\\"https://blog.hichroma.com/graphql-react-tutorial-part-1-6-d0691af25858\\\">GraphQL 和 React Tutorial示例应用</a>中的设计元素,所以我们不需要在本教程中编写CSS. 我们只需将 LESS编译为单个CSS文件, 并将其包含在我们的应用程序中. 复制和粘贴<a href=\\\"https://github.com/hichroma/learnstorybook-code/blob/master/src/index.css\\\">这个编译的CSS</a>根据 <strong>CRA</strong>的规则 进入 <strong>src/index.css</strong> 文件. </p>\\n<p><img src=\\\"/ss-browserchrome-taskbox-learnstorybook.png\\\" alt=\\\"Taskbox UI\\\"></p>\\n<div class=\\\"aside\\\">\\n如果要修改样式，在GitHub存储库中有提供 源LESS文件。\\n</div>\\n<h2>添加资源</h2>\\n<p>我们还需要添加 字体和图标<a href=\\\"https://github.com/hichroma/learnstorybook-code/tree/master/public\\\">文件夹</a>到了<code>public/</code>文件夹. 添加 样式和静态资源 后,应用程序会奇奇怪怪的. 没关系. 因为我们还没有开发应用程序. 现在我们开始构建我们的第一个组件!</p>\",\"excerpt\":\"开始吧  Storybook 是在开发模式下 与 您的应用程序一起运行的. 它可以帮助您构建UI组件,并与 应用程序的 业务逻辑和上下文 隔离开来. 本期\\\"学习 Storybook\\\"适用于  React ;  Vue和Angular 版本即将推出.  整个页面 -> 拿出各种组件 -> 分隔出  每个组件  / 组件组合 用来测试与文档说明 设置React Storybook 我们需要按照几个步骤设置 Storybook 环境. 首先,我们想要使用 Create React App  ( CRA…\",\"frontmatter\":{\"path\":null,\"title\":\"开始吧\"}}},{\"node\":{\"id\":\"/Users/luz/code/js/binstd.github.io/markdown/docs/zh/screen.md absPath of file >>> MarkdownRemark\",\"html\":\"<h1>构建一个页面</h1>\\n<p>我们专注于从下到上构建UI; 从小做起并增加复杂性. 这样做使我们能够独立开发每个组件,找出其数据需求,并在 Storybook 中使用它. 所有这些都无需 启动服务器或构建出页面!</p>\\n<p>在本章中,我们通过组合页面中的组件,并在 Storybook中开发该页面 来继续提高复杂性. </p>\\n<h2>嵌套的容器组件</h2>\\n<p>由于我们的应用程序非常简单,我们将构建的页面非常简单,只需简单地包装<code>TaskList</code>组件 (通过Redux提供自己的数据) 在某些布局中并拉出redux中顶层<code>error</code>的字段 (假设我们在连接到 服务器时遇到问题,我们将设置该字段) . 创建<code>InboxScreen.js</code>在你的<code>components</code>夹: </p>\\n<pre><code class=\\\"language-javascript\\\">import React from 'react';\\nimport PropTypes from 'prop-types';\\nimport { connect } from 'react-redux';\\n\\nimport TaskList from './TaskList';\\n\\nexport function PureInboxScreen({ error }) {\\n  if (error) {\\n    return (\\n      &#x3C;div className=\\\"page lists-show\\\">\\n        &#x3C;div className=\\\"wrapper-message\\\">\\n          &#x3C;span className=\\\"icon-face-sad\\\" />\\n          &#x3C;div className=\\\"title-message\\\">Oh no!&#x3C;/div>\\n          &#x3C;div className=\\\"subtitle-message\\\">Something went wrong&#x3C;/div>\\n        &#x3C;/div>\\n      &#x3C;/div>\\n    );\\n  }\\n\\n  return (\\n    &#x3C;div className=\\\"page lists-show\\\">\\n      &#x3C;nav>\\n        &#x3C;h1 className=\\\"title-page\\\">\\n          &#x3C;span className=\\\"title-wrapper\\\">Taskbox&#x3C;/span>\\n        &#x3C;/h1>\\n      &#x3C;/nav>\\n      &#x3C;TaskList />\\n    &#x3C;/div>\\n  );\\n}\\n\\nPureInboxScreen.propTypes = {\\n  error: PropTypes.string,\\n};\\n\\nPureInboxScreen.defaultProps = {\\n  error: null,\\n};\\n\\nexport default connect(({ error }) => ({ error }))(PureInboxScreen);\\n</code></pre>\\n<p>我们也改变了<code>App</code>,用于渲染的组件<code>InboxScreen</code> (最终我们会使用路由器来选择正确的页面,但不要在此担心) : </p>\\n<pre><code class=\\\"language-javascript\\\">import React, { Component } from 'react';\\nimport { Provider } from 'react-redux';\\nimport store from './lib/redux';\\n\\nimport InboxScreen from './components/InboxScreen';\\n\\nclass App extends Component {\\n  render() {\\n    return (\\n      &#x3C;Provider store={store}>\\n        &#x3C;InboxScreen />\\n      &#x3C;/Provider>\\n    );\\n  }\\n}\\n\\nexport default App;\\n</code></pre>\\n<p>然而,事情变得有趣的是在 Storybook中渲染故事. </p>\\n<p>正如我们之前看到的那样<code>TaskList</code>组件是一个 <strong>容器</strong>, 这使得<code>PureTaskList</code>表示组件. 根据定义,容器组件不能简单地单独呈现; 他们希望通过一些上下文或连接到服务. 这意味着要在Storybook中呈现容器,我们必须模拟 (即提供假装版本) 它所需的上下文或服务. </p>\\n<p>放置<code>TaskList</code>进入 Storybook,我们能够通过简单地渲染<code>PureTaskList</code>,并避开容器来避开这个问题. 我们会渲染<code>PureInboxScreen</code>并在 Storybook中做类似的事情. </p>\\n<p>但是,对于<code>PureInboxScreen</code>我们有一个问题,因为虽然<code>PureInboxScreen</code>本身是表现性的,它的孩子,<code>TaskList</code>, 不是. 从某种意义上说<code>PureInboxScreen</code>被\\\"容器\\\"污染了. 所以,当我们设置我们的故事<code>InboxScreen.stories.js</code>: </p>\\n<pre><code class=\\\"language-javascript\\\">import React from 'react';\\nimport { storiesOf } from '@storybook/react';\\n\\nimport { PureInboxScreen } from './InboxScreen';\\n\\nstoriesOf('InboxScreen', module)\\n  .add('default', () => &#x3C;PureInboxScreen />)\\n  .add('error', () => &#x3C;PureInboxScreen error=\\\"Something\\\" />);\\n</code></pre>\\n<p>我们看到了虽然如此<code>error</code>故事工作得很好,我们<code>default</code>故事有一个问题,因为<code>TaskList</code>没有要连接的Redux Store . (在尝试测试时,您也会遇到类似的问题<code>PureInboxScreen</code>用单元测试) . </p>\\n<p><img src=\\\"/broken-inboxscreen.png\\\" alt=\\\"Broken inbox\\\"></p>\\n<p>避免此问题的一种方法是,永远不要在应用程序中的任何位置呈现容器组件,除非在最高级别,而是将所有要求的数据 传递到 组件层次结构中. </p>\\n<p>但是,开发人员 <strong>将</strong> 不可避免地需要在组件层次结构中,进一步渲染容器. 如果我们想要在 Storybook中渲染大部分或全部应用程序 (我们这样做!) ,我们需要一个解决此问题的方法. </p>\\n<div class=\\\"aside\\\">\\n另外，在层次结构中 传递数据 是合法的方法，尤其是在使用 <a href=\\\"http://graphql.org/\\\">GraphQL</a>. 这就是我们的建设 <a href=\\\"https://chromaticqa.com\\\">Chromatic</a> 伴随着670多个故事.\\n</div>\\n<h2>用装饰器提供上下文</h2>\\n<p>好消息是 Redux Store  很容易提供给 一个<code>InboxScreen</code>故事! 我们可以使用 Redux Store 的模拟版本 提供给到装饰器中: </p>\\n<pre><code class=\\\"language-javascript\\\">import React from 'react';\\nimport { storiesOf } from '@storybook/react';\\nimport { action } from '@storybook/addon-actions';\\nimport { Provider } from 'react-redux';\\n\\nimport { PureInboxScreen } from './InboxScreen';\\nimport { defaultTasks } from './TaskList.stories';\\n\\n// A super-simple mock of a redux store\\nconst store = {\\n  getState: () => {\\n    return {\\n      tasks: defaultTasks,\\n    };\\n  },\\n  subscribe: () => 0,\\n  dispatch: action('dispatch'),\\n};\\n\\nstoriesOf('InboxScreen', module)\\n  .addDecorator(story => &#x3C;Provider store={store}>{story()}&#x3C;/Provider>)\\n  .add('default', () => &#x3C;PureInboxScreen />)\\n  .add('error', () => &#x3C;PureInboxScreen error=\\\"Something\\\" />);\\n</code></pre>\\n<p>存在类似的方法来为其他数据库提供模拟的上下文,例如<a href=\\\"https://www.npmjs.com/package/apollo-storybook-decorator\\\">阿波罗</a>,<a href=\\\"https://github.com/orta/react-storybooks-relay-container\\\">Relay</a>和别的. </p>\\n<p>在Storybook中 循环浏览状态 可以轻松测试我们是否已正确完成此操作: </p>\\n<video autoPlay muted playsInline loop >\\n  <source\\n    src=\\\"/finished-inboxscreen-states.mp4\\\"\\n    type=\\\"video/mp4\\\"\\n  />\\n</video>\\n<h2>组件驱动开发</h2>\\n<p>我们从底部开始<code>Task</code>,然后进展到<code>TaskList</code>,现在我们在这里使用全屏UI. 我们的<code>InboxScreen</code>容纳嵌套的容器组件,并包括随附的故事. </p>\\n<video autoPlay muted playsInline loop style=\\\"width:480px; height:auto; margin: 0 auto;\\\">\\n  <source\\n    src=\\\"/component-driven-development-optimized.mp4\\\"\\n    type=\\\"video/mp4\\\"\\n  />\\n</video>\\n<p><a href=\\\"https://blog.hichroma.com/component-driven-development-ce1109d56c8e\\\"><strong>组件驱动开发</strong></a>允许您在向上移动组件层次结构时,逐渐扩展复杂性. 其中的好处包括 更集中的开发过程 以及 所有可能的UI排列 的覆盖范围. 简而言之,CDD 可帮助您构建 更高质量和更复杂 的用户界面. </p>\\n<p>我们还没有完成 - 在构建UI时,工作不会结束. 我们还需要确保它随着时间的推移保持持久. </p>\",\"excerpt\":\"构建一个页面 我们专注于从下到上构建UI; 从小做起并增加复杂性. 这样做使我们能够独立开发每个组件,找出其数据需求,并在 Storybook 中使用它. 所有这些都无需 启动服务器或构建出页面! 在本章中,我们通过组合页面中的组件,并在 Storybook中开发该页面 来继续提高复杂性.  嵌套的容器组件 由于我们的应用程序非常简单,我们将构建的页面非常简单,只需简单地包装 TaskList 组件 (通过Redux提供自己的数据) 在某些布局中并拉出redux中顶层 error…\",\"frontmatter\":{\"path\":null,\"title\":\"构建一个页面\"}}},{\"node\":{\"id\":\"/Users/luz/code/js/binstd.github.io/markdown/docs/zh/simple-component.md absPath of file >>> MarkdownRemark\",\"html\":\"<h1>构建一个简单的组件</h1>\\n<p>我们将按照<a href=\\\"https://blog.hichroma.com/component-driven-development-ce1109d56c8e\\\">组件驱动开发</a> (CDD) 方法论来 构建我们的UI. 这是一个从\\\"自下而上\\\"开始构建UI的过程,从组件开始到整个页面结束. CDD 可帮助您在构建UI时,摆列您所面临的复杂程度. </p>\\n<h2>任务-Task</h2>\\n<p><img src=\\\"/task-states-learnstorybook.png\\\" alt=\\\"Task component in three states\\\"></p>\\n<p><code>Task</code>是我们的应用程序的核心组件. 每个任务的显示略有不同,具体取决于它所处的<code>状态-state</code>. 我们显示一个选中 (或未选中) 复选框,一些有关任务的信息,以及一个\\\"pin\\\"按钮,允许我们在列表中上下移动任务. 为了把各个它们摆在一起,我们需要下面的 <strong>props</strong>: </p>\\n<ul>\\n<li>\\n<p><code>title</code> - 描述任务的字符串</p>\\n</li>\\n<li>\\n<p><code>state</code> - 哪个列表是当前的任务,是否已检查?</p>\\n</li>\\n</ul>\\n<p>在我们开始构建<code>Task</code>时,我们首先编写 与 上面草图中不同类型的任务 相对应的测试状态. 然后我们使用 Storybook 模拟数据 隔离对应状态组件. 我们将\\\"视觉测试\\\"组件在每个状态下的外观. </p>\\n<p>这个过程类似于<a href=\\\"https://en.wikipedia.org/wiki/Test-driven_development\\\">测试驱动的开发(TDD)</a>,我们可以称之为<a href=\\\"https://blog.hichroma.com/visual-test-driven-development-aec1c98bed87\\\">\\\"Visual-虚拟 TDD\\\"</a></p>\\n<h2>获取设置</h2>\\n<p>首先,让我们创建任务组件 及 其附带的 <em>storybook-故事</em> 文件: </p>\\n<p><code>src/components/Task.js</code>和<code>src/components/Task.stories.js</code></p>\\n<p>我们将从基本实现开始,简单传入我们需要的<code>属性-props</code> 以及 您可以对任务执行的两个<code>on</code>操作 (在列表之间移动它) : </p>\\n<pre><code class=\\\"language-javascript\\\">import React from 'react';\\n\\nexport default function Task({ task: { id, title, state }, onArchiveTask, onPinTask }) {\\n  return (\\n    &#x3C;div className=\\\"list-item\\\">\\n      &#x3C;input type=\\\"text\\\" value={title} readOnly={true} />\\n    &#x3C;/div>\\n  );\\n}\\n</code></pre>\\n<p>上面,我们基于 Todos应用程序现有HTML结构 为 <code>Task</code>提供简单的 markup . </p>\\n<p>下面, 我们在 故事文件中 构建 Task的 三个测试状态: </p>\\n<pre><code class=\\\"language-javascript\\\">import React from 'react';\\nimport { storiesOf } from '@storybook/react';\\nimport { action } from '@storybook/addon-actions';\\n\\nimport Task from './Task';\\n\\nexport const task = {\\n  id: '1',\\n  title: 'Test Task',\\n  state: 'TASK_INBOX',\\n  updatedAt: new Date(2018, 0, 1, 9, 0),\\n};\\n\\nexport const actions = {\\n  onPinTask: action('onPinTask'),\\n  onArchiveTask: action('onArchiveTask'),\\n};\\n\\nstoriesOf('Task', module)\\n  .add('default', () => &#x3C;Task task={task} {...actions} />)\\n  .add('pinned', () => &#x3C;Task task={{ ...task, state: 'TASK_PINNED' }} {...actions} />)\\n  .add('archived', () => &#x3C;Task task={{ ...task, state: 'TASK_ARCHIVED' }} {...actions} />);\\n</code></pre>\\n<p>Storybook中有两个基本的组织级别. </p>\\n<p>该组件 及 其 child 故事. </p>\\n<p>将每个故事 视为组件的排列. 您可以根据需要为每个组件 创建 尽可能多的故事. </p>\\n<ul>\\n<li>\\n<p><strong>组件</strong></p>\\n<ul>\\n<li>故事</li>\\n<li>故事</li>\\n<li>故事</li>\\n</ul>\\n</li>\\n</ul>\\n<p>要开始 Storybook,我们先运<code>行 注册组件的</code>storiesOf()`函数. 我们为组件添加 <em>显示名称 -  Storybook应用程序侧栏上显示的名称</em>. </p>\\n<p><code>action()</code>允许我们创建一个回调, 当在Storybook UI的面板中 单击这个 <strong>action</strong> 时 回调触发. 因此,当我们构建一个pin按钮 时,我们将能够在 测试UI中 确定按钮单击 是否成功. </p>\\n<p>由于我们需要将 相同的一组操作 传递给 组件的所有排列,因此将它们捆绑到<code>actions</code>变量 并 使用React<code>{...actions}</code>的<code>porps</code>扩展以立即传递它们. <code>&#x3C;Task {...actions}></code>相当于<code>&#x3C;Task onPinTask={actions.onPinTask} onArchiveTask={actions.onArchiveTask}></code>. </p>\\n<p>关于捆绑<code>actions</code>的另一个好处就是,你可以<code>export-暴露</code>它们,用于重用该组件的组件,我们稍后会看到. </p>\\n<p>为了定义我们的故事,我们用<code>add()</code>,一次一个为我们的每个测试状态生成一个故事. <code>add</code>第二个参数是一个函数,它返回一个给定状态的渲染元素 (即带有一组<code>props</code>的组件类)  - 就像一个React<a href=\\\"https://reactjs.org/docs/components-and-props.html\\\">无状态功能组件</a>. </p>\\n<p>在创建故事时,我们使用基本任务 (<code>task</code>) 构建组件期望的 任务的形状. 这通常是 根据真实数据的模型建模的. 再次,正如我们所看到的,<code>export</code>这种形状将使我们能够在以后的故事中重复使用它. </p>\\n<div class=\\\"aside\\\">\\n<a href=\\\"https://storybook.js.org/addons/introduction/#2-native-addons\\\"><b>Actions</b></a> 帮助您在隔离构建UI组件时 验证交互. 通常，您无法访问应用程序上下文中的函数和状态。 使用 <code>action()</code> 将它们存入.\\n</div>\\n<h2>配置</h2>\\n<p>我们还必须对 Storybook的配置设置 (<code>.storybook/config.js</code>) 做一个小改动,让它注意到我们的<code>.stories.js</code>文件并使用我们的CSS文件. 默认情况下, Storybook 会查找故事<code>/stories</code>目录; 本教程使用类似于<code>.test.js</code>的命名方案, 这个命令是 <strong>CRA</strong> 赞成的用于自动化测试的方案. </p>\\n<pre><code class=\\\"language-javascript\\\">import { configure } from '@storybook/react';\\nimport '../src/index.css';\\n\\nconst req = require.context('../src', true, /.stories.js$/);\\n\\nfunction loadStories() {\\n  req.keys().forEach(filename => req(filename));\\n}\\n\\nconfigure(loadStories, module);\\n</code></pre>\\n<p>完成此操作后,重新启动 Storybook服务器 应该会产生 三个任务状态的测试用例: </p>\\n<video autoPlay muted playsInline controls >\\n  <source\\n    src=\\\"/inprogress-task-states.mp4\\\"\\n    type=\\\"video/mp4\\\"\\n  />\\n</video>\\n<h2>建立状态</h2>\\n<p>现在我们有 Storybook设置,导入的样式和构建的测试用例,我们可以快速开始实现组件的HTML,以匹配设计. </p>\\n<p>该组件目前仍然是基本的. 首先编写实现设计的代码,不用过多细节: </p>\\n<pre><code class=\\\"language-javascript\\\">import React from 'react';\\n\\nexport default function Task({ task: { id, title, state }, onArchiveTask, onPinTask }) {\\n  return (\\n    &#x3C;div className={`list-item ${state}`}>\\n      &#x3C;label className=\\\"checkbox\\\">\\n        &#x3C;input\\n          type=\\\"checkbox\\\"\\n          defaultChecked={state === 'TASK_ARCHIVED'}\\n          disabled={true}\\n          name=\\\"checked\\\"\\n        />\\n        &#x3C;span className=\\\"checkbox-custom\\\" onClick={() => onArchiveTask(id)} />\\n      &#x3C;/label>\\n      &#x3C;div className=\\\"title\\\">\\n        &#x3C;input type=\\\"text\\\" value={title} readOnly={true} placeholder=\\\"Input title\\\" />\\n      &#x3C;/div>\\n\\n      &#x3C;div className=\\\"actions\\\" onClick={event => event.stopPropagation()}>\\n        {state !== 'TASK_ARCHIVED' &#x26;&#x26; (\\n          &#x3C;a onClick={() => onPinTask(id)}>\\n            &#x3C;span className={`icon-star`} />\\n          &#x3C;/a>\\n        )}\\n      &#x3C;/div>\\n    &#x3C;/div>\\n  );\\n}\\n</code></pre>\\n<p>上面的附加 markup 与我们之前导入的CSS相结合,产生以下UI: </p>\\n<video autoPlay muted playsInline loop>\\n  <source\\n    src=\\\"/finished-task-states.mp4\\\"\\n    type=\\\"video/mp4\\\"\\n  />\\n</video>\\n<h2>特别数据要求</h2>\\n<p>最好的做法是<code>propTypes</code>在React中 指定组件所需的 数据形状. 它不仅可以自我记录,还有助于及早发现问题. </p>\\n<pre><code class=\\\"language-javascript\\\">import React from 'react';\\nimport PropTypes from 'prop-types';\\n\\nfunction Task() {\\n  ...\\n}\\n\\nTask.propTypes = {\\n  task: PropTypes.shape({\\n    id: PropTypes.string.isRequired,\\n    title: PropTypes.string.isRequired,\\n    state: PropTypes.string.isRequired,\\n  }),\\n  onArchiveTask: PropTypes.func,\\n  onPinTask: PropTypes.func,\\n};\\n\\nexport default Task;\\n</code></pre>\\n<p>现在,如果任务组件被滥用,则会出现开发警告. </p>\\n<div class=\\\"aside\\\">\\n另一种实现方法是使用 类似TypeScript的JavaScript类型系统 来为组件属性 创建类型。\\n</div>\\n<h2>组件构建!</h2>\\n<p>我们现在已成功构建了一个组件,没用到服务器或运行整个前端应用程序. 下一步是以类似的方式逐个构建剩余的 Taskbox组件. </p>\\n<p>如您所见,开始单独构建组件非常简单快捷. 我们可以期望生成更高质量的UI,减少错误和更多打磨,因为它可以挖掘并测试每个可能的状态. </p>\\n<h2>自动化测试</h2>\\n<p> Storybook 为我们提供了一种在施工期间,<code>可视化</code>测试我们的应用程序.在我们继续开发应用程序时,\\\"故事\\\"将有助于确保我们不会在视觉上打破我们的任务.\\n但是,在这个阶段,这是一个完全手动的过程,有人必须努力点击每个测试状态,并确保它呈现良好且没有错误或警告.\\n我们不能自动这样做吗?</p>\\n<h3>快照测试</h3>\\n<p>快照测试是指,记录 带一定输入的组件的\\\"已知良好\\\"输出,然后,将来 输出发生变化时标记组件 的做法.\\n这补充了 Storybook,因为快照 是查看 组件新版本 并 检查更改的快速方法. </p>\\n<div class=\\\"aside\\\">\\n确保您的组件呈现 <b>不变</b> 的数据，以便每次快照测试都不会失败。 注意日期或随机生成的值等内容。\\n</div>\\n<p>需要<a href=\\\"https://github.com/storybooks/storybook/tree/master/addons/storyshots\\\">Storyshots 插件</a>为每个故事创建 快照测试.\\n通过添加开发依赖项来使用它: </p>\\n<pre><code class=\\\"language-bash\\\">yarn add --dev @storybook/addon-storyshots react-test-renderer\\n</code></pre>\\n<p>然后创建一个<code>src/storybook.test.js</code>文件中包含以下内容: </p>\\n<pre><code class=\\\"language-javascript\\\">import initStoryshots from '@storybook/addon-storyshots';\\ninitStoryshots();\\n</code></pre>\\n<p>完成上述操作后,我们就可以运行了<code>yarn test</code>并看到以下输出: </p>\\n<p><img src=\\\"/task-testrunner.png\\\" alt=\\\"Task test runner\\\"></p>\\n<p>我们现在为每个<code>Task</code>故事进行快照测试. 如果我们改变了<code>Task</code>的实现,我们会提示您验证更改. </p>\",\"excerpt\":\"构建一个简单的组件 我们将按照 组件驱动开发  (CDD) 方法论来 构建我们的UI. 这是一个从\\\"自下而上\\\"开始构建UI的过程,从组件开始到整个页面结束. CDD 可帮助您在构建UI时,摆列您所面临的复杂程度.  任务-Task Task 是我们的应用程序的核心组件. 每个任务的显示略有不同,具体取决于它所处的 状态-state . 我们显示一个选中 (或未选中) 复选框,一些有关任务的信息,以及一个\\\"pin…\",\"frontmatter\":{\"path\":null,\"title\":\"构建一个简单的组件\"}}},{\"node\":{\"id\":\"/Users/luz/code/js/binstd.github.io/markdown/docs/zh/test.md absPath of file >>> MarkdownRemark\",\"html\":\"<h1>测试UI组件</h1>\\n<p>Storybook教程没有测试是不完整的. 测试对于创建高质量的UI至关重要. 在模块化系统中,微小的调整可能导致重大的回溯. 到目前为止,我们遇到了三种类型的测试</p>\\n<ul>\\n<li><strong>视觉测试</strong> 依赖开发人员手动查看组件以验证其正确性. 它们帮助我们在构建时检查组件的外观. </li>\\n<li><strong>快照测试</strong> 使用Storyshots捕获组件的渲染标记. 它们可以帮助我们及时了解导致 渲染错误和警告的标记更改. </li>\\n<li><strong>单元测试</strong> 使用Jest验证 在给定固定输入的情况下 组件的输出保持不变. 它们非常适合测试组件的功能质量. </li>\\n</ul>\\n<h2>\\\"但看起来不错吗?\\\"</h2>\\n<p>不幸的是,单独的上述测试方法不足以防止UI错误. 用户界面很难测试,因为设计是主观的,细致入微的. 可视化测试 过于手动,快照测试在用于UI时 会触发太多误报,而 像素级单元测试的价值很低. 完整的 Storybook测试策略 还包括视觉回溯测试. </p>\\n<h2>Storybook的视觉回溯测试</h2>\\n<p>视觉回溯测试旨在捕捉外观的变化. 他们通过捕获每个故事的屏幕截图,并将它们提交到 表面更改 进行比较工作. 这非常适合验证布局,颜色,大小和对比度等图形元素. </p>\\n<video autoPlay muted playsInline loop style=\\\"width:480px; margin: 0 auto;\\\">\\n  <source\\n    src=\\\"/visual-regression-testing.mp4\\\"\\n    type=\\\"video/mp4\\\"\\n  />\\n</video>\\n<p> Storybook 是视觉回溯测试的绝佳工具,因为每个故事本质上都是一个测试规范. 每次我们编写或更新故事时,我们都会免费获得规格!</p>\\n<p>有许多用于视觉回溯测试的工具. 对于专业团队,我们建议<a href=\\\"https://www.chromaticqa.com/\\\"><strong>Chromatic</strong></a>,由 Storybook维护者制作的插件,在云中运行测试. </p>\\n<h2>设置视觉回溯测试</h2>\\n<p>Chromatic 是一个无障碍的 Storybook插件,用于在云中进行视觉回溯测试和审查. 由于它是付费服务 (免费试用) ,因此可能并非适合所有人. 但是,Chromatic 是生产视觉测试工作流程的一个有益的例子,我们将免费试用. 我们来看一下. </p>\\n<h3>初始化Git</h3>\\n<p>首先,您要在本地目录中为项目设置Git. Chromatic 使用 Git历史记录 来跟踪您的UI组件. </p>\\n<pre><code class=\\\"language-bash\\\">$ git init\\n</code></pre>\\n<p>接下来将文件添加到第一次提交. </p>\\n<pre><code class=\\\"language-bash\\\">$ git add .\\n</code></pre>\\n<p>现在提交文件. </p>\\n<pre><code class=\\\"language-bash\\\">$ git commit -m \\\"taskbox UI\\\"\\n</code></pre>\\n<h3>获得 Chromatic</h3>\\n<p>将包添加为依赖项. </p>\\n<pre><code class=\\\"language-bash\\\">yarn add storybook-chromatic\\n</code></pre>\\n<p>导入Chromatic 到你的<code>.storybook/config.js</code>文件. </p>\\n<pre><code class=\\\"language-javascript\\\">import { configure } from '@storybook/react';\\nimport 'storybook-chromatic/storybook-addon';\\n\\nimport '../src/index.css';\\n\\nconst req = require.context('../src/components', true, /\\\\.stories\\\\.js$/);\\n\\nfunction loadStories() {\\n  req.keys().forEach(filename => req(filename));\\n}\\n\\nconfigure(loadStories, module);\\n</code></pre>\\n<p>然后<a href=\\\"https://chromaticqa.com/start\\\">登录Chromatic</a>使用您的GitHub帐户 (Chromatic仅要求轻量级权限) . 创建名为\\\"taskbox\\\"的项目并复制您的唯一项目<code>app-code</code>. </p>\\n<video autoPlay muted playsInline loop style=\\\"width:520px; margin: 0 auto;\\\">\\n  <source\\n    src=\\\"/chromatic-setup-learnstorybook.mp4\\\"\\n    type=\\\"video/mp4\\\"\\n  />\\n</video>\\n<p>在命令行中运行 test命令 以设置Storybook的可视化回溯测试. 不要忘记添加您的 唯一应用代码 来代替<code>&#x3C;app-code></code>. </p>\\n<pre><code class=\\\"language-bash\\\">./node_modules/.bin/chromatic test --storybook-addon --app-code=&#x3C;app-code> --do-not-start\\n</code></pre>\\n<div class=\\\"aside\\\">\\n<code>--do-not-start</code> 是一个选项，告诉 Chromatic 不要启动故事书。 如果您已经运行了故事书，请使用此选项。 如果没有会省略 <code>--do-not-start</code>.\\n</div>\\n<p>第一次测试完成后, 我们会为每个故事提供测试基准. 换句话说,每个故事的屏幕截图都被称为\\\"good\\\". 这些故事的未来变化 将与 基线进行比较. </p>\\n<p><img src=\\\"/chromatic-baselines.png\\\" alt=\\\"Chromatic baselines\\\"></p>\\n<h2>捕获UI更改</h2>\\n<p>视觉回溯测试 依赖于将 新呈现的UI代码的图像 与 基线图像 进行比较. 如果捕获到UI更改,则会收到通知. 通过调整背景 来了解它是如何工作的<code>Task</code>组件: </p>\\n<p><img src=\\\"/chromatic-change-to-task-component.png\\\" alt=\\\"code change\\\"></p>\\n<p>这会为项目生成新的背景颜色. </p>\\n<p><img src=\\\"/chromatic-task-change.png\\\" alt=\\\"task background change\\\"></p>\\n<p>使用之前的test命令运行另一个Chromatic测试. </p>\\n<pre><code class=\\\"language-bash\\\">./node_modules/.bin/chromatic test --storybook-addon --app-code=&#x3C;app-code> --do-not-start\\n</code></pre>\\n<p>点击您将看到 更改的网络用户界面 链接. </p>\\n<p><img src=\\\"/chromatic-catch-changes.png\\\" alt=\\\"UI changes in Chromatic\\\"></p>\\n<p>有很多变化! 组件层次结构表明 <code>Task</code>是<code>TaskList</code>的孩子和<code>Inbox</code>意味着一个小小的调整滚雪球成为主要的回溯. 这种情况正是开发人员除了其他测试方法之外,还需要视觉回溯测试的原因. </p>\\n<p><img src=\\\"/minor-major-regressions.gif\\\" alt=\\\"UI minor tweaks major regressions\\\"></p>\\n<h2>查看更改</h2>\\n<p>视觉回溯测试确保组件不会意外更改. 但是,您仍然需要确定更改是否是有意的. </p>\\n<p>如果有意更改,则需要更新基线,以便将来的测试与故事的最新版本进行比较. 如果改变是无意的,则需要修复. </p>\\n<video autoPlay muted playsInline loop style=\\\"width:480px; margin: 0 auto;\\\">\\n  <source\\n    src=\\\"/website-workflow-review-merge-optimized.mp4\\\"\\n    type=\\\"video/mp4\\\"\\n  />\\n</video>\\n<p>由于现代应用程序是 由组件构建的,因此我们在组件级别 进行测试非常重要. 这样做有助于我们找出变化的根本原因,即组件,而不是对 变化的症状,页面 和 复合组件 做出反应. </p>\\n<h2>合并更改</h2>\\n<p>当我们完成审核后,我们已准备好自信地合并 UI更改 - 知道更新不会意外地引入错误. 如果你喜欢新的<code>papayawhip</code>背景色,然后接受更改,如果不需要恢复到以前的状态. </p>\\n<p><img src=\\\"/chromatic-review-finished.png\\\" alt=\\\"Changes ready to be merged\\\"></p>\\n<p> Storybook可以帮助你 <strong>建立</strong> 组件;测试可以帮助你 <strong>保持</strong> 他们. 本教程介绍了四种类型的UI测试,包括 可视化,快照,单元和可视化回溯测试. 您可以通过将它们添加到 CI脚本 来自动执行最后三个. 这有助于您运输组件 而不必担心 偷渡漏洞. 整个工作流程如下所示. </p>\\n<p><img src=\\\"/cdd-review-workflow.png\\\" alt=\\\"Visual regression testing workflow\\\"></p>\",\"excerpt\":\"测试UI组件 Storybook教程没有测试是不完整的. 测试对于创建高质量的UI至关重要. 在模块化系统中,微小的调整可能导致重大的回溯. 到目前为止,我们遇到了三种类型的测试 视觉测试  依赖开发人员手动查看组件以验证其正确性. 它们帮助我们在构建时检查组件的外观.  快照测试  使用Storyshots捕获组件的渲染标记. 它们可以帮助我们及时了解导致 渲染错误和警告的标记更改.  单元测试  使用Jest…\",\"frontmatter\":{\"path\":null,\"title\":\"测试\"}}}]}},\"pathContext\":{}}\n\n/***/ })\n\n});\n\n\n// WEBPACK FOOTER //\n// path---index-cbfb748ba7b6881303ab.js","module.exports = {\"data\":{\"allMarkdownRemark\":{\"edges\":[{\"node\":{\"id\":\"/Users/luz/code/js/binstd.github.io/markdown/info.md absPath of file >>> MarkdownRemark\",\"html\":\"<p>binstd以程序员为核心建设技术信用,对开发者实现数据化的了解，理解。推动开发生态建设，建立技术生态底层的公用数据服务资源，区块链跨链云服务;发行技术生态标准数字资产STD。成为技术落地的最后一公里，引领开发潮流。\\n<img src=\\\"https://ws4.sinaimg.cn/large/006tKfTcgy1ftjtbu2fuej30w60lawf1.jpg\\\"></p>\\n<p><strong>跨链云服务</strong>\\n建立区块链云服务平台，支持多个公链网络的跨链层建设，多种语言的封装服务。逐步建设跨链 基础链和状态数据链。</p>\\n<p><strong>公用资源服务及工具</strong>\\n打造程序(框架/库)、数据(云数据 API)的公用服务资源平台，实现开发能力和数据能力的组 件化、插件化、云端化，让开发变得更为简单。</p>\\n<p>提供版本控制系统、IDE、聊天/协作/Bug问题追踪、持续集成与交付部署与容器等云端工具服 务，为程序员创造便捷的线上协作开发体验。</p>\\n<p><strong>翻译计划</strong>\\n推动优质区块链技术普及，建设技术开发生态和开发者社群。</p>\",\"excerpt\":\"binstd以程序员为核心建设技术信用,对开发者实现数据化的了解，理解。推动开发生态建设，建立技术生态底层的公用数据服务资源，区块链跨链云服务;发行技术生态标准数字资产STD。成为技术落地的最后一公里，引领开发潮流。\\n 跨链云服务 \\n建立区块链云服务平台，支持多个公链网络的跨链层建设，多种语言的封装服务。逐步建设跨链 基础链和状态数据链。 公用资源服务及工具 \\n打造程序(框架/库)、数据(云数据 API…\",\"frontmatter\":{\"path\":\"/info\",\"title\":\"关于我们\"}}},{\"node\":{\"id\":\"/Users/luz/code/js/binstd.github.io/markdown/blog/index.1.md absPath of file >>> MarkdownRemark\",\"html\":\"<h3><strong>一.简单说下货币&#x26;积分</strong></h3>\\n<h6><strong>原始：黄金白银 贝壳</strong></h6>\\n<p>最早时期，交通不发达，内陆地区使用沿海才有的贝壳做为交换媒介，去换取物品，得到贝壳的人又用它去换取其他物品。后来交通发达后，人们可以轻易获得贝壳，于是贝壳不在做为货币（货币的总量是否要优先，是否要防范增发？）\\n为什么不是铜铁，木头？而是黄金，白银，和稀缺是不是有关系。因为稀缺所有值钱，因为之前，所以不需要太多黄金，就可以换取大部分物品。</p>\\n<h6><strong>山西票号</strong></h6>\\n<p>清明晚期，晋商遍布各地做生意，甚至生意做到海外，由于地域广，商人携带大量黄金白银有些不方便和不安全。山西票号适应了这个需求，它在各地建立票号，商户去票号保存银子，会得到一个票据，凭借票据可以异地提取。大大降低了商人出行携带大量银两的安全隐患和运输成本。</p>\\n<h6><strong>传统的数据库下的单节点（中心化）-积分</strong></h6>\\n<p>互联网重构很多行业，大家日常在使用各种app&#x26;网站时都有一个积分，比如早期的qq币，大家想一下这个东西如何实现？\\n<strong>大家大概都能想到一个数据仓库（专业点说叫数据库），记录着：</strong>\\n账号信息（用户名，昵称，秘密），你的qq币额度（还有多少qq币），你的消费记录（记录你的币怎么获得的，怎么消费的，你购买了什么东西）\\n<strong>这是什么呢，这是一个单节点维持的账本，腾讯这家公司控制的账本，这个账本能否做为货币？</strong></p>\\n<h3><strong>二.比特币的诞生</strong></h3>\\n<p>2008经济危机背景下，中本聪发表了比特币-点对点的电子支付系统，次年比特币诞生。2009年比特币正式上线。\\n并且在创世区块中写入了泰晤士报09年1.3号的头版标题，讽刺了一把银行。\\n大家肯定好奇比特币这套系统为什么得到那么多人推崇，为什么可以做到一枚2万美金？</p>\\n<p><strong>比特币是如何实现货币功能的？</strong></p>\\n<h6>1.多节点维持的账本（数据库）</h6>\\n<p>比特币创造了一个没有任何主体控制的系统，上文提到的积分是单个节点说了算，例如q币，就是腾讯说了算的，而比特币有多对等节点。且每个对等节点都有相同的完整的数据库记录或者说账本。\\n<strong>先看一下这个图，理解一下什么叫对等的节点，没有控制者：</strong></p>\\n<p><img src=\\\"https://blockluz-1253389096.cos.ap-beijing.myqcloud.com/blockman/qft6j.jpg\\\"></p>\\n<p><strong>一个经典问题：拜占庭军事问题，怎么解决这个问题？怎么保证数据一致，又怎么保证鼓励大家做比特币的节点（激励层）？这里先卖个关子，先从单个节点的数据结构上说：</strong></p>\\n<h6>2.比特币的单节点的数据结构</h6>\\n<p>区块+链，简单说就是一个个区块一环扣一环，链接而成：</p>\\n<p><img src=\\\"https://blockluz-1253389096.cos.ap-beijing.myqcloud.com/blockman/le9ng.jpg\\\"></p>\\n<p>听到区块这个词不必紧张，你把它当作一个有固定结构和规范的容器就行，就像一个楼层，一个房间。其中区块这个容器构成：包括区块头，交易记录两部分。\\n如图其中区块头中又包含三个部分父区块hash值，merkle树根，挖矿相关的难度值，时间戳等。大家先不用关系他们代表什么，我会在下文一一说明。\\n<strong>1.重点说父区块hash：</strong>（大家可以把hash值换成地址方便理解），这个父区块hash值呢，也可以说是上一个区块的hash值或者说地址（方便理解）。它的作用主要就是知道了前一个区块地址，从而连接前一个区块，形成一环扣一环的所谓区块链：</p>\\n<p><img src=\\\"https://blockluz-1253389096.cos.ap-beijing.myqcloud.com/blockman/xewx9.jpg\\\"></p>\\n<p>大家看图就会明白，这个一环扣一环既，如果其中一个区块的hash值出现变化，那整个链就断了。而上文提到上一个区块的hash值，那这个hash值是怎么来的呢？其实是对真个区块容器里，装载的所有信息或者说东西做一个运算得来的唯一值（hash运算），也就是说，区块中装载的信息出现改变，hash值一定会改变。从而提高了造假成本。</p>\\n<p><strong>接下来说区块头的的第二个信息merkle树根</strong>，这个词很飘，其实它的用途是做一个标记，刚才跟大家介绍了区块分成两个部分，一个区块头&#x26;一个是交易信息。其中交易信息是比特币的所有的转账记录（比特币的一个区块规定了所能装载的交易记录是1m，也就是大约500笔交易。当装满的时候，就会在区块头加上merkle树根信息，做为标识）</p>\\n<p><strong>而挖矿相关的信息</strong>，主要是用于生成下一个区块，以及发现该区块，这个知识点下文会说。</p>\\n<p>那么之前留下的问题是非可以解答了呢？<strong>即如何没有服务端控制，p2p之间如何协调一致，没有将军，士兵之间如何协调？如何刺激大家做比特币的节点，成为一个p？如何取代央行做货币的发行？</strong></p>\\n<h6>3.共识算法：pow&#x26;运行原理</h6>\\n<p>比特币的解决办法就是pow共识机制，想了解它，我们先来了解一个古老的问题，<strong>即拜占庭军事问题：</strong>\\n讲一个小故事，古时候有一个国家叫拜占庭，他很有钱也很强大，周围有几个小国，他们希望得到拜占庭的财富，但是呢，他们单个国家又无法攻破拜占庭，去攻击拜占庭一定会被消灭，他们之间呢，又各怀鬼胎，企图占领他国。\\n唯一能攻破拜占庭的方案就是他们几个国家一起攻击。这里就涉及到一个问题，就是这个几个互不信任的国家，如何同步的问题。</p>\\n<p>前面提到比特币是区块+链的结构，且区块头中有父区块的hash值，也就知道了父区块的位置，<strong>然后比特币里有个出块的概念，既每隔一段时间产生一个新区块（空的）</strong>中本聪发明了一个游戏，谁先踩中下一个区块的hash值，就全网停止继续运算，全网也去同步他的区块。并准备猜下一个区块的hash值。\\n如何猜中hash值，控制难度呢？由前面提到的区块头的挖矿相关的nonce值，时间戳等控制。</p>\\n<p><img src=\\\"https://blockluz-1253389096.cos.ap-beijing.myqcloud.com/blockman/ez1rn.jpg\\\"></p>\\n<p><strong>那么比特币如何鼓励大家成为它的节点呢？</strong>猜出新区块hash值的矿工，可以获得一个叫coinbase交易的奖励，以及转账的手续费奖励。\\n<strong>这里就要提到区块结构的第二部分：交易信息（merkle树）</strong>\\n首先明确一个概念，比特币是没有账户概念的，所以的额度，都是通过遍历整个的交易信息获取到，并做+-运算的来。\\n所以的比特币客户端出了区块链这个库，还有一个交易池的概念，既你的每次转账都会广播全网的所有节点，并将该转账信息加入到他们各种的交易池中，而非直接放到区块链里。\\n<strong>如何将交易池中保存的交易记录放到区块链中呢？</strong>\\n每次挖出新块后矿工，即将交易数据打包放到到新区块中，其中挖矿获得的奖励和交易手续费也将加入到区块中。直到区块装满（比特币是1m的交易容量），和上文提到的踩中hash后的广播是同一次的。 </p>\\n<p><img src=\\\"media/15219667839362/15221343606583.jpg\\\">                                                                                  </p>\\n<h6>4.<strong>比特币的公钥匙私</strong></h6>\\n<p>比特币生成一个私钥，对私钥做算法运算得到公钥。这个运算是有一个固定算法的，所以可以离线生成比特币的私钥。（硬件钱包，纸钱包原理），且不可逆转。\\n<img src=\\\"https://blockluz-1253389096.cos.ap-beijing.myqcloud.com/blockman/939e3.jpg\\\"></p>\\n<h6><strong>钱包说明</strong></h6>\\n<p>这个私钥是意味着控制权。联想到上面的区块链的交易记录，他会记录转账地址和金额。这个地址就是公钥。所以你可以在任何钱包上使用这个私钥。\\n在交易所中，只提供给你币的地址，没有提供私钥。所以你的转账，其实最终的控制是交易所完成的。而非你自己。但是在钱包里就不一样了。</p>\\n<p>钱包是不是比特币的节点？不一定，有集成节点的钱包，也有调取的比特币网络节点接口的钱包。</p>\\n<h3>附录</h3>\\n<h6>名词解释避坑：</h6>\\n<p><strong>共识：</strong>\\n共识机制的共识是指不同节点直接的数据同步，以及奖励的分配的共识。\\n而在民生，在大众认同等问题上也会提到共识。比如比特币靠什么能赢？很多人说共识，其实这个共识的意思是大众的认同，也就是多少人认可你。在区块链项目里，通常有个社区治理的概念，即有多少人支持一个项目，对这个项目生态又有什么意见。往往涉及到投票等。这里大家可以预先查一下，dac，dao这些概念。了解下社区治理。同时后面解释一个项目：比特股也会在探讨他。</p>\\n<p><strong>节点：</strong>\\n很多资料只会给你解释比特币的区块链里是保存交易记录的。但是没有说明这个交易记录是一种树结构，这种树结构是很多区块链项目都有涉及到的。树就有节点。这里要和区块链网络的节点区分开。</p>\\n<h6><strong>课外常识：</strong></h6>\\n<p><strong>不要怂，就是干，一把梭</strong>\\n对梭的解释：\\n早期出现在股票市场里，主要指不管3721，把前投进去就是了。常常被大家用来自嘲。\\n<strong>会所嫩模</strong>\\n通常是大家对炒币的一种期许，希望币百倍，千倍增长。从而实现财富自由。\\n<strong>韭菜</strong>\\n一般指散户，在区块链项目上的投资通常就是买项目发行的币。门槛很低，基本什么人都能参与。\\n也被用于指不讲技巧的投。比如前面提到的“不要怂，就是干，一把梭”，可用于自嘲，或讽刺他人</p>\\n<h6><strong>问题：</strong></h6>\\n<p>如何定义区块链？只是比特币的区块+链的结构嘛？如果没有对等的节点呢？\\n如果没有p2p分散的节点，或者有人占据了大部分节点，是否能串改数据？区块+链的结构不好改，如果是先搞一个任务池，重构整个区块链呢？也就是一次升级的是吧。</p>\\n<p>区块链还能干做什么？只是做币嘛？没有别的用途嘛？这里先卖个关子。比特币只是一个功能机，后面会讲到一个项目，它把比特币创造的区块链的智能机时代。赋予区块链更多的想象力。</p>\",\"excerpt\":\"…\",\"frontmatter\":{\"path\":\"/blog1\",\"title\":\"比特币的诞生和区块链\"}}},{\"node\":{\"id\":\"/Users/luz/code/js/binstd.github.io/markdown/blog/index.2.md absPath of file >>> MarkdownRemark\",\"html\":\"<h3><strong>一.简单说下货币&#x26;积分</strong></h3>\\n<h6><strong>原始：黄金白银 贝壳</strong></h6>\\n<p>最早时期，交通不发达，内陆地区使用沿海才有的贝壳做为交换媒介，去换取物品，得到贝壳的人又用它去换取其他物品。后来交通发达后，人们可以轻易获得贝壳，于是贝壳不在做为货币（货币的总量是否要优先，是否要防范增发？）\\n为什么不是铜铁，木头？而是黄金，白银，和稀缺是不是有关系。因为稀缺所有值钱，因为之前，所以不需要太多黄金，就可以换取大部分物品。</p>\\n<h6><strong>山西票号</strong></h6>\\n<p>清明晚期，晋商遍布各地做生意，甚至生意做到海外，由于地域广，商人携带大量黄金白银有些不方便和不安全。山西票号适应了这个需求，它在各地建立票号，商户去票号保存银子，会得到一个票据，凭借票据可以异地提取。大大降低了商人出行携带大量银两的安全隐患和运输成本。</p>\\n<h6><strong>传统的数据库下的单节点（中心化）-积分</strong></h6>\\n<p>互联网重构很多行业，大家日常在使用各种app&#x26;网站时都有一个积分，比如早期的qq币，大家想一下这个东西如何实现？\\n<strong>大家大概都能想到一个数据仓库（专业点说叫数据库），记录着：</strong>\\n账号信息（用户名，昵称，秘密），你的qq币额度（还有多少qq币），你的消费记录（记录你的币怎么获得的，怎么消费的，你购买了什么东西）\\n<strong>这是什么呢，这是一个单节点维持的账本，腾讯这家公司控制的账本，这个账本能否做为货币？</strong></p>\\n<h3><strong>二.比特币的诞生</strong></h3>\\n<p>2008经济危机背景下，中本聪发表了比特币-点对点的电子支付系统，次年比特币诞生。2009年比特币正式上线。\\n并且在创世区块中写入了泰晤士报09年1.3号的头版标题，讽刺了一把银行。\\n大家肯定好奇比特币这套系统为什么得到那么多人推崇，为什么可以做到一枚2万美金？</p>\\n<p><strong>比特币是如何实现货币功能的？</strong></p>\\n<h6>1.多节点维持的账本（数据库）</h6>\\n<p>比特币创造了一个没有任何主体控制的系统，上文提到的积分是单个节点说了算，例如q币，就是腾讯说了算的，而比特币有多对等节点。且每个对等节点都有相同的完整的数据库记录或者说账本。\\n<strong>先看一下这个图，理解一下什么叫对等的节点，没有控制者：</strong></p>\\n<p><img src=\\\"https://blockluz-1253389096.cos.ap-beijing.myqcloud.com/blockman/qft6j.jpg\\\"></p>\\n<p><strong>一个经典问题：拜占庭军事问题，怎么解决这个问题？怎么保证数据一致，又怎么保证鼓励大家做比特币的节点（激励层）？这里先卖个关子，先从单个节点的数据结构上说：</strong></p>\\n<h6>2.比特币的单节点的数据结构</h6>\\n<p>区块+链，简单说就是一个个区块一环扣一环，链接而成：</p>\\n<p><img src=\\\"https://blockluz-1253389096.cos.ap-beijing.myqcloud.com/blockman/le9ng.jpg\\\"></p>\\n<p>听到区块这个词不必紧张，你把它当作一个有固定结构和规范的容器就行，就像一个楼层，一个房间。其中区块这个容器构成：包括区块头，交易记录两部分。\\n如图其中区块头中又包含三个部分父区块hash值，merkle树根，挖矿相关的难度值，时间戳等。大家先不用关系他们代表什么，我会在下文一一说明。\\n<strong>1.重点说父区块hash：</strong>（大家可以把hash值换成地址方便理解），这个父区块hash值呢，也可以说是上一个区块的hash值或者说地址（方便理解）。它的作用主要就是知道了前一个区块地址，从而连接前一个区块，形成一环扣一环的所谓区块链：</p>\\n<p><img src=\\\"https://blockluz-1253389096.cos.ap-beijing.myqcloud.com/blockman/xewx9.jpg\\\"></p>\\n<p>大家看图就会明白，这个一环扣一环既，如果其中一个区块的hash值出现变化，那整个链就断了。而上文提到上一个区块的hash值，那这个hash值是怎么来的呢？其实是对真个区块容器里，装载的所有信息或者说东西做一个运算得来的唯一值（hash运算），也就是说，区块中装载的信息出现改变，hash值一定会改变。从而提高了造假成本。</p>\\n<p><strong>接下来说区块头的的第二个信息merkle树根</strong>，这个词很飘，其实它的用途是做一个标记，刚才跟大家介绍了区块分成两个部分，一个区块头&#x26;一个是交易信息。其中交易信息是比特币的所有的转账记录（比特币的一个区块规定了所能装载的交易记录是1m，也就是大约500笔交易。当装满的时候，就会在区块头加上merkle树根信息，做为标识）</p>\\n<p><strong>而挖矿相关的信息</strong>，主要是用于生成下一个区块，以及发现该区块，这个知识点下文会说。</p>\\n<p>那么之前留下的问题是非可以解答了呢？<strong>即如何没有服务端控制，p2p之间如何协调一致，没有将军，士兵之间如何协调？如何刺激大家做比特币的节点，成为一个p？如何取代央行做货币的发行？</strong></p>\\n<h6>3.共识算法：pow&#x26;运行原理</h6>\\n<p>比特币的解决办法就是pow共识机制，想了解它，我们先来了解一个古老的问题，<strong>即拜占庭军事问题：</strong>\\n讲一个小故事，古时候有一个国家叫拜占庭，他很有钱也很强大，周围有几个小国，他们希望得到拜占庭的财富，但是呢，他们单个国家又无法攻破拜占庭，去攻击拜占庭一定会被消灭，他们之间呢，又各怀鬼胎，企图占领他国。\\n唯一能攻破拜占庭的方案就是他们几个国家一起攻击。这里就涉及到一个问题，就是这个几个互不信任的国家，如何同步的问题。</p>\\n<p>前面提到比特币是区块+链的结构，且区块头中有父区块的hash值，也就知道了父区块的位置，<strong>然后比特币里有个出块的概念，既每隔一段时间产生一个新区块（空的）</strong>中本聪发明了一个游戏，谁先踩中下一个区块的hash值，就全网停止继续运算，全网也去同步他的区块。并准备猜下一个区块的hash值。\\n如何猜中hash值，控制难度呢？由前面提到的区块头的挖矿相关的nonce值，时间戳等控制。</p>\\n<p><img src=\\\"https://blockluz-1253389096.cos.ap-beijing.myqcloud.com/blockman/ez1rn.jpg\\\"></p>\\n<p><strong>那么比特币如何鼓励大家成为它的节点呢？</strong>猜出新区块hash值的矿工，可以获得一个叫coinbase交易的奖励，以及转账的手续费奖励。\\n<strong>这里就要提到区块结构的第二部分：交易信息（merkle树）</strong>\\n首先明确一个概念，比特币是没有账户概念的，所以的额度，都是通过遍历整个的交易信息获取到，并做+-运算的来。\\n所以的比特币客户端出了区块链这个库，还有一个交易池的概念，既你的每次转账都会广播全网的所有节点，并将该转账信息加入到他们各种的交易池中，而非直接放到区块链里。\\n<strong>如何将交易池中保存的交易记录放到区块链中呢？</strong>\\n每次挖出新块后矿工，即将交易数据打包放到到新区块中，其中挖矿获得的奖励和交易手续费也将加入到区块中。直到区块装满（比特币是1m的交易容量），和上文提到的踩中hash后的广播是同一次的。 </p>\\n<p><img src=\\\"media/15219667839362/15221343606583.jpg\\\">                                                                                  </p>\\n<h6>4.<strong>比特币的公钥匙私</strong></h6>\\n<p>比特币生成一个私钥，对私钥做算法运算得到公钥。这个运算是有一个固定算法的，所以可以离线生成比特币的私钥。（硬件钱包，纸钱包原理），且不可逆转。\\n<img src=\\\"https://blockluz-1253389096.cos.ap-beijing.myqcloud.com/blockman/939e3.jpg\\\"></p>\\n<h6><strong>钱包说明</strong></h6>\\n<p>这个私钥是意味着控制权。联想到上面的区块链的交易记录，他会记录转账地址和金额。这个地址就是公钥。所以你可以在任何钱包上使用这个私钥。\\n在交易所中，只提供给你币的地址，没有提供私钥。所以你的转账，其实最终的控制是交易所完成的。而非你自己。但是在钱包里就不一样了。</p>\\n<p>钱包是不是比特币的节点？不一定，有集成节点的钱包，也有调取的比特币网络节点接口的钱包。</p>\\n<h3>附录</h3>\\n<h6>名词解释避坑：</h6>\\n<p><strong>共识：</strong>\\n共识机制的共识是指不同节点直接的数据同步，以及奖励的分配的共识。\\n而在民生，在大众认同等问题上也会提到共识。比如比特币靠什么能赢？很多人说共识，其实这个共识的意思是大众的认同，也就是多少人认可你。在区块链项目里，通常有个社区治理的概念，即有多少人支持一个项目，对这个项目生态又有什么意见。往往涉及到投票等。这里大家可以预先查一下，dac，dao这些概念。了解下社区治理。同时后面解释一个项目：比特股也会在探讨他。</p>\\n<p><strong>节点：</strong>\\n很多资料只会给你解释比特币的区块链里是保存交易记录的。但是没有说明这个交易记录是一种树结构，这种树结构是很多区块链项目都有涉及到的。树就有节点。这里要和区块链网络的节点区分开。</p>\\n<h6><strong>课外常识：</strong></h6>\\n<p><strong>不要怂，就是干，一把梭</strong>\\n对梭的解释：\\n早期出现在股票市场里，主要指不管3721，把前投进去就是了。常常被大家用来自嘲。\\n<strong>会所嫩模</strong>\\n通常是大家对炒币的一种期许，希望币百倍，千倍增长。从而实现财富自由。\\n<strong>韭菜</strong>\\n一般指散户，在区块链项目上的投资通常就是买项目发行的币。门槛很低，基本什么人都能参与。\\n也被用于指不讲技巧的投。比如前面提到的“不要怂，就是干，一把梭”，可用于自嘲，或讽刺他人</p>\\n<h6><strong>问题：</strong></h6>\\n<p>如何定义区块链？只是比特币的区块+链的结构嘛？如果没有对等的节点呢？\\n如果没有p2p分散的节点，或者有人占据了大部分节点，是否能串改数据？区块+链的结构不好改，如果是先搞一个任务池，重构整个区块链呢？也就是一次升级的是吧。</p>\\n<p>区块链还能干做什么？只是做币嘛？没有别的用途嘛？这里先卖个关子。比特币只是一个功能机，后面会讲到一个项目，它把比特币创造的区块链的智能机时代。赋予区块链更多的想象力。</p>\",\"excerpt\":\"…\",\"frontmatter\":{\"path\":\"/blog2\",\"title\":\"比特币的诞生和区块链\"}}},{\"node\":{\"id\":\"/Users/luz/code/js/binstd.github.io/markdown/blog/index.3.md absPath of file >>> MarkdownRemark\",\"html\":\"<h3><strong>一.简单说下货币&#x26;积分</strong></h3>\\n<h6><strong>原始：黄金白银 贝壳</strong></h6>\\n<p>最早时期，交通不发达，内陆地区使用沿海才有的贝壳做为交换媒介，去换取物品，得到贝壳的人又用它去换取其他物品。后来交通发达后，人们可以轻易获得贝壳，于是贝壳不在做为货币（货币的总量是否要优先，是否要防范增发？）\\n为什么不是铜铁，木头？而是黄金，白银，和稀缺是不是有关系。因为稀缺所有值钱，因为之前，所以不需要太多黄金，就可以换取大部分物品。</p>\\n<h6><strong>山西票号</strong></h6>\\n<p>清明晚期，晋商遍布各地做生意，甚至生意做到海外，由于地域广，商人携带大量黄金白银有些不方便和不安全。山西票号适应了这个需求，它在各地建立票号，商户去票号保存银子，会得到一个票据，凭借票据可以异地提取。大大降低了商人出行携带大量银两的安全隐患和运输成本。</p>\\n<h6><strong>传统的数据库下的单节点（中心化）-积分</strong></h6>\\n<p>互联网重构很多行业，大家日常在使用各种app&#x26;网站时都有一个积分，比如早期的qq币，大家想一下这个东西如何实现？\\n<strong>大家大概都能想到一个数据仓库（专业点说叫数据库），记录着：</strong>\\n账号信息（用户名，昵称，秘密），你的qq币额度（还有多少qq币），你的消费记录（记录你的币怎么获得的，怎么消费的，你购买了什么东西）\\n<strong>这是什么呢，这是一个单节点维持的账本，腾讯这家公司控制的账本，这个账本能否做为货币？</strong></p>\\n<h3><strong>二.比特币的诞生</strong></h3>\\n<p>2008经济危机背景下，中本聪发表了比特币-点对点的电子支付系统，次年比特币诞生。2009年比特币正式上线。\\n并且在创世区块中写入了泰晤士报09年1.3号的头版标题，讽刺了一把银行。\\n大家肯定好奇比特币这套系统为什么得到那么多人推崇，为什么可以做到一枚2万美金？</p>\\n<p><strong>比特币是如何实现货币功能的？</strong></p>\\n<h6>1.多节点维持的账本（数据库）</h6>\\n<p>比特币创造了一个没有任何主体控制的系统，上文提到的积分是单个节点说了算，例如q币，就是腾讯说了算的，而比特币有多对等节点。且每个对等节点都有相同的完整的数据库记录或者说账本。\\n<strong>先看一下这个图，理解一下什么叫对等的节点，没有控制者：</strong></p>\\n<p><img src=\\\"https://blockluz-1253389096.cos.ap-beijing.myqcloud.com/blockman/qft6j.jpg\\\"></p>\\n<p><strong>一个经典问题：拜占庭军事问题，怎么解决这个问题？怎么保证数据一致，又怎么保证鼓励大家做比特币的节点（激励层）？这里先卖个关子，先从单个节点的数据结构上说：</strong></p>\\n<h6>2.比特币的单节点的数据结构</h6>\\n<p>区块+链，简单说就是一个个区块一环扣一环，链接而成：</p>\\n<p><img src=\\\"https://blockluz-1253389096.cos.ap-beijing.myqcloud.com/blockman/le9ng.jpg\\\"></p>\\n<p>听到区块这个词不必紧张，你把它当作一个有固定结构和规范的容器就行，就像一个楼层，一个房间。其中区块这个容器构成：包括区块头，交易记录两部分。\\n如图其中区块头中又包含三个部分父区块hash值，merkle树根，挖矿相关的难度值，时间戳等。大家先不用关系他们代表什么，我会在下文一一说明。\\n<strong>1.重点说父区块hash：</strong>（大家可以把hash值换成地址方便理解），这个父区块hash值呢，也可以说是上一个区块的hash值或者说地址（方便理解）。它的作用主要就是知道了前一个区块地址，从而连接前一个区块，形成一环扣一环的所谓区块链：</p>\\n<p><img src=\\\"https://blockluz-1253389096.cos.ap-beijing.myqcloud.com/blockman/xewx9.jpg\\\"></p>\\n<p>大家看图就会明白，这个一环扣一环既，如果其中一个区块的hash值出现变化，那整个链就断了。而上文提到上一个区块的hash值，那这个hash值是怎么来的呢？其实是对真个区块容器里，装载的所有信息或者说东西做一个运算得来的唯一值（hash运算），也就是说，区块中装载的信息出现改变，hash值一定会改变。从而提高了造假成本。</p>\\n<p><strong>接下来说区块头的的第二个信息merkle树根</strong>，这个词很飘，其实它的用途是做一个标记，刚才跟大家介绍了区块分成两个部分，一个区块头&#x26;一个是交易信息。其中交易信息是比特币的所有的转账记录（比特币的一个区块规定了所能装载的交易记录是1m，也就是大约500笔交易。当装满的时候，就会在区块头加上merkle树根信息，做为标识）</p>\\n<p><strong>而挖矿相关的信息</strong>，主要是用于生成下一个区块，以及发现该区块，这个知识点下文会说。</p>\\n<p>那么之前留下的问题是非可以解答了呢？<strong>即如何没有服务端控制，p2p之间如何协调一致，没有将军，士兵之间如何协调？如何刺激大家做比特币的节点，成为一个p？如何取代央行做货币的发行？</strong></p>\\n<h6>3.共识算法：pow&#x26;运行原理</h6>\\n<p>比特币的解决办法就是pow共识机制，想了解它，我们先来了解一个古老的问题，<strong>即拜占庭军事问题：</strong>\\n讲一个小故事，古时候有一个国家叫拜占庭，他很有钱也很强大，周围有几个小国，他们希望得到拜占庭的财富，但是呢，他们单个国家又无法攻破拜占庭，去攻击拜占庭一定会被消灭，他们之间呢，又各怀鬼胎，企图占领他国。\\n唯一能攻破拜占庭的方案就是他们几个国家一起攻击。这里就涉及到一个问题，就是这个几个互不信任的国家，如何同步的问题。</p>\\n<p>前面提到比特币是区块+链的结构，且区块头中有父区块的hash值，也就知道了父区块的位置，<strong>然后比特币里有个出块的概念，既每隔一段时间产生一个新区块（空的）</strong>中本聪发明了一个游戏，谁先踩中下一个区块的hash值，就全网停止继续运算，全网也去同步他的区块。并准备猜下一个区块的hash值。\\n如何猜中hash值，控制难度呢？由前面提到的区块头的挖矿相关的nonce值，时间戳等控制。</p>\\n<p><img src=\\\"https://blockluz-1253389096.cos.ap-beijing.myqcloud.com/blockman/ez1rn.jpg\\\"></p>\\n<p><strong>那么比特币如何鼓励大家成为它的节点呢？</strong>猜出新区块hash值的矿工，可以获得一个叫coinbase交易的奖励，以及转账的手续费奖励。\\n<strong>这里就要提到区块结构的第二部分：交易信息（merkle树）</strong>\\n首先明确一个概念，比特币是没有账户概念的，所以的额度，都是通过遍历整个的交易信息获取到，并做+-运算的来。\\n所以的比特币客户端出了区块链这个库，还有一个交易池的概念，既你的每次转账都会广播全网的所有节点，并将该转账信息加入到他们各种的交易池中，而非直接放到区块链里。\\n<strong>如何将交易池中保存的交易记录放到区块链中呢？</strong>\\n每次挖出新块后矿工，即将交易数据打包放到到新区块中，其中挖矿获得的奖励和交易手续费也将加入到区块中。直到区块装满（比特币是1m的交易容量），和上文提到的踩中hash后的广播是同一次的。 </p>\\n<p><img src=\\\"media/15219667839362/15221343606583.jpg\\\">                                                                                  </p>\\n<h6>4.<strong>比特币的公钥匙私</strong></h6>\\n<p>比特币生成一个私钥，对私钥做算法运算得到公钥。这个运算是有一个固定算法的，所以可以离线生成比特币的私钥。（硬件钱包，纸钱包原理），且不可逆转。\\n<img src=\\\"https://blockluz-1253389096.cos.ap-beijing.myqcloud.com/blockman/939e3.jpg\\\"></p>\\n<h6><strong>钱包说明</strong></h6>\\n<p>这个私钥是意味着控制权。联想到上面的区块链的交易记录，他会记录转账地址和金额。这个地址就是公钥。所以你可以在任何钱包上使用这个私钥。\\n在交易所中，只提供给你币的地址，没有提供私钥。所以你的转账，其实最终的控制是交易所完成的。而非你自己。但是在钱包里就不一样了。</p>\\n<p>钱包是不是比特币的节点？不一定，有集成节点的钱包，也有调取的比特币网络节点接口的钱包。</p>\\n<h3>附录</h3>\\n<h6>名词解释避坑：</h6>\\n<p><strong>共识：</strong>\\n共识机制的共识是指不同节点直接的数据同步，以及奖励的分配的共识。\\n而在民生，在大众认同等问题上也会提到共识。比如比特币靠什么能赢？很多人说共识，其实这个共识的意思是大众的认同，也就是多少人认可你。在区块链项目里，通常有个社区治理的概念，即有多少人支持一个项目，对这个项目生态又有什么意见。往往涉及到投票等。这里大家可以预先查一下，dac，dao这些概念。了解下社区治理。同时后面解释一个项目：比特股也会在探讨他。</p>\\n<p><strong>节点：</strong>\\n很多资料只会给你解释比特币的区块链里是保存交易记录的。但是没有说明这个交易记录是一种树结构，这种树结构是很多区块链项目都有涉及到的。树就有节点。这里要和区块链网络的节点区分开。</p>\\n<h6><strong>课外常识：</strong></h6>\\n<p><strong>不要怂，就是干，一把梭</strong>\\n对梭的解释：\\n早期出现在股票市场里，主要指不管3721，把前投进去就是了。常常被大家用来自嘲。\\n<strong>会所嫩模</strong>\\n通常是大家对炒币的一种期许，希望币百倍，千倍增长。从而实现财富自由。\\n<strong>韭菜</strong>\\n一般指散户，在区块链项目上的投资通常就是买项目发行的币。门槛很低，基本什么人都能参与。\\n也被用于指不讲技巧的投。比如前面提到的“不要怂，就是干，一把梭”，可用于自嘲，或讽刺他人</p>\\n<h6><strong>问题：</strong></h6>\\n<p>如何定义区块链？只是比特币的区块+链的结构嘛？如果没有对等的节点呢？\\n如果没有p2p分散的节点，或者有人占据了大部分节点，是否能串改数据？区块+链的结构不好改，如果是先搞一个任务池，重构整个区块链呢？也就是一次升级的是吧。</p>\\n<p>区块链还能干做什么？只是做币嘛？没有别的用途嘛？这里先卖个关子。比特币只是一个功能机，后面会讲到一个项目，它把比特币创造的区块链的智能机时代。赋予区块链更多的想象力。</p>\",\"excerpt\":\"…\",\"frontmatter\":{\"path\":\"/blog3\",\"title\":\"比特币的诞生和区块链\"}}},{\"node\":{\"id\":\"/Users/luz/code/js/binstd.github.io/markdown/blog/index.4.md absPath of file >>> MarkdownRemark\",\"html\":\"<h3><strong>一.简单说下货币&#x26;积分</strong></h3>\\n<h6><strong>原始：黄金白银 贝壳</strong></h6>\\n<p>最早时期，交通不发达，内陆地区使用沿海才有的贝壳做为交换媒介，去换取物品，得到贝壳的人又用它去换取其他物品。后来交通发达后，人们可以轻易获得贝壳，于是贝壳不在做为货币（货币的总量是否要优先，是否要防范增发？）\\n为什么不是铜铁，木头？而是黄金，白银，和稀缺是不是有关系。因为稀缺所有值钱，因为之前，所以不需要太多黄金，就可以换取大部分物品。</p>\\n<h6><strong>山西票号</strong></h6>\\n<p>清明晚期，晋商遍布各地做生意，甚至生意做到海外，由于地域广，商人携带大量黄金白银有些不方便和不安全。山西票号适应了这个需求，它在各地建立票号，商户去票号保存银子，会得到一个票据，凭借票据可以异地提取。大大降低了商人出行携带大量银两的安全隐患和运输成本。</p>\\n<h6><strong>传统的数据库下的单节点（中心化）-积分</strong></h6>\\n<p>互联网重构很多行业，大家日常在使用各种app&#x26;网站时都有一个积分，比如早期的qq币，大家想一下这个东西如何实现？\\n<strong>大家大概都能想到一个数据仓库（专业点说叫数据库），记录着：</strong>\\n账号信息（用户名，昵称，秘密），你的qq币额度（还有多少qq币），你的消费记录（记录你的币怎么获得的，怎么消费的，你购买了什么东西）\\n<strong>这是什么呢，这是一个单节点维持的账本，腾讯这家公司控制的账本，这个账本能否做为货币？</strong></p>\\n<h3><strong>二.比特币的诞生</strong></h3>\\n<p>2008经济危机背景下，中本聪发表了比特币-点对点的电子支付系统，次年比特币诞生。2009年比特币正式上线。\\n并且在创世区块中写入了泰晤士报09年1.3号的头版标题，讽刺了一把银行。\\n大家肯定好奇比特币这套系统为什么得到那么多人推崇，为什么可以做到一枚2万美金？</p>\\n<p><strong>比特币是如何实现货币功能的？</strong></p>\\n<h6>1.多节点维持的账本（数据库）</h6>\\n<p>比特币创造了一个没有任何主体控制的系统，上文提到的积分是单个节点说了算，例如q币，就是腾讯说了算的，而比特币有多对等节点。且每个对等节点都有相同的完整的数据库记录或者说账本。\\n<strong>先看一下这个图，理解一下什么叫对等的节点，没有控制者：</strong></p>\\n<p><img src=\\\"https://blockluz-1253389096.cos.ap-beijing.myqcloud.com/blockman/qft6j.jpg\\\"></p>\\n<p><strong>一个经典问题：拜占庭军事问题，怎么解决这个问题？怎么保证数据一致，又怎么保证鼓励大家做比特币的节点（激励层）？这里先卖个关子，先从单个节点的数据结构上说：</strong></p>\\n<h6>2.比特币的单节点的数据结构</h6>\\n<p>区块+链，简单说就是一个个区块一环扣一环，链接而成：</p>\\n<p><img src=\\\"https://blockluz-1253389096.cos.ap-beijing.myqcloud.com/blockman/le9ng.jpg\\\"></p>\\n<p>听到区块这个词不必紧张，你把它当作一个有固定结构和规范的容器就行，就像一个楼层，一个房间。其中区块这个容器构成：包括区块头，交易记录两部分。\\n如图其中区块头中又包含三个部分父区块hash值，merkle树根，挖矿相关的难度值，时间戳等。大家先不用关系他们代表什么，我会在下文一一说明。\\n<strong>1.重点说父区块hash：</strong>（大家可以把hash值换成地址方便理解），这个父区块hash值呢，也可以说是上一个区块的hash值或者说地址（方便理解）。它的作用主要就是知道了前一个区块地址，从而连接前一个区块，形成一环扣一环的所谓区块链：</p>\\n<p><img src=\\\"https://blockluz-1253389096.cos.ap-beijing.myqcloud.com/blockman/xewx9.jpg\\\"></p>\\n<p>大家看图就会明白，这个一环扣一环既，如果其中一个区块的hash值出现变化，那整个链就断了。而上文提到上一个区块的hash值，那这个hash值是怎么来的呢？其实是对真个区块容器里，装载的所有信息或者说东西做一个运算得来的唯一值（hash运算），也就是说，区块中装载的信息出现改变，hash值一定会改变。从而提高了造假成本。</p>\\n<p><strong>接下来说区块头的的第二个信息merkle树根</strong>，这个词很飘，其实它的用途是做一个标记，刚才跟大家介绍了区块分成两个部分，一个区块头&#x26;一个是交易信息。其中交易信息是比特币的所有的转账记录（比特币的一个区块规定了所能装载的交易记录是1m，也就是大约500笔交易。当装满的时候，就会在区块头加上merkle树根信息，做为标识）</p>\\n<p><strong>而挖矿相关的信息</strong>，主要是用于生成下一个区块，以及发现该区块，这个知识点下文会说。</p>\\n<p>那么之前留下的问题是非可以解答了呢？<strong>即如何没有服务端控制，p2p之间如何协调一致，没有将军，士兵之间如何协调？如何刺激大家做比特币的节点，成为一个p？如何取代央行做货币的发行？</strong></p>\\n<h6>3.共识算法：pow&#x26;运行原理</h6>\\n<p>比特币的解决办法就是pow共识机制，想了解它，我们先来了解一个古老的问题，<strong>即拜占庭军事问题：</strong>\\n讲一个小故事，古时候有一个国家叫拜占庭，他很有钱也很强大，周围有几个小国，他们希望得到拜占庭的财富，但是呢，他们单个国家又无法攻破拜占庭，去攻击拜占庭一定会被消灭，他们之间呢，又各怀鬼胎，企图占领他国。\\n唯一能攻破拜占庭的方案就是他们几个国家一起攻击。这里就涉及到一个问题，就是这个几个互不信任的国家，如何同步的问题。</p>\\n<p>前面提到比特币是区块+链的结构，且区块头中有父区块的hash值，也就知道了父区块的位置，<strong>然后比特币里有个出块的概念，既每隔一段时间产生一个新区块（空的）</strong>中本聪发明了一个游戏，谁先踩中下一个区块的hash值，就全网停止继续运算，全网也去同步他的区块。并准备猜下一个区块的hash值。\\n如何猜中hash值，控制难度呢？由前面提到的区块头的挖矿相关的nonce值，时间戳等控制。</p>\\n<p><img src=\\\"https://blockluz-1253389096.cos.ap-beijing.myqcloud.com/blockman/ez1rn.jpg\\\"></p>\\n<p><strong>那么比特币如何鼓励大家成为它的节点呢？</strong>猜出新区块hash值的矿工，可以获得一个叫coinbase交易的奖励，以及转账的手续费奖励。\\n<strong>这里就要提到区块结构的第二部分：交易信息（merkle树）</strong>\\n首先明确一个概念，比特币是没有账户概念的，所以的额度，都是通过遍历整个的交易信息获取到，并做+-运算的来。\\n所以的比特币客户端出了区块链这个库，还有一个交易池的概念，既你的每次转账都会广播全网的所有节点，并将该转账信息加入到他们各种的交易池中，而非直接放到区块链里。\\n<strong>如何将交易池中保存的交易记录放到区块链中呢？</strong>\\n每次挖出新块后矿工，即将交易数据打包放到到新区块中，其中挖矿获得的奖励和交易手续费也将加入到区块中。直到区块装满（比特币是1m的交易容量），和上文提到的踩中hash后的广播是同一次的。 </p>\\n<p><img src=\\\"media/15219667839362/15221343606583.jpg\\\">                                                                                  </p>\\n<h6>4.<strong>比特币的公钥匙私</strong></h6>\\n<p>比特币生成一个私钥，对私钥做算法运算得到公钥。这个运算是有一个固定算法的，所以可以离线生成比特币的私钥。（硬件钱包，纸钱包原理），且不可逆转。\\n<img src=\\\"https://blockluz-1253389096.cos.ap-beijing.myqcloud.com/blockman/939e3.jpg\\\"></p>\\n<h6><strong>钱包说明</strong></h6>\\n<p>这个私钥是意味着控制权。联想到上面的区块链的交易记录，他会记录转账地址和金额。这个地址就是公钥。所以你可以在任何钱包上使用这个私钥。\\n在交易所中，只提供给你币的地址，没有提供私钥。所以你的转账，其实最终的控制是交易所完成的。而非你自己。但是在钱包里就不一样了。</p>\\n<p>钱包是不是比特币的节点？不一定，有集成节点的钱包，也有调取的比特币网络节点接口的钱包。</p>\\n<h3>附录</h3>\\n<h6>名词解释避坑：</h6>\\n<p><strong>共识：</strong>\\n共识机制的共识是指不同节点直接的数据同步，以及奖励的分配的共识。\\n而在民生，在大众认同等问题上也会提到共识。比如比特币靠什么能赢？很多人说共识，其实这个共识的意思是大众的认同，也就是多少人认可你。在区块链项目里，通常有个社区治理的概念，即有多少人支持一个项目，对这个项目生态又有什么意见。往往涉及到投票等。这里大家可以预先查一下，dac，dao这些概念。了解下社区治理。同时后面解释一个项目：比特股也会在探讨他。</p>\\n<p><strong>节点：</strong>\\n很多资料只会给你解释比特币的区块链里是保存交易记录的。但是没有说明这个交易记录是一种树结构，这种树结构是很多区块链项目都有涉及到的。树就有节点。这里要和区块链网络的节点区分开。</p>\\n<h6><strong>课外常识：</strong></h6>\\n<p><strong>不要怂，就是干，一把梭</strong>\\n对梭的解释：\\n早期出现在股票市场里，主要指不管3721，把前投进去就是了。常常被大家用来自嘲。\\n<strong>会所嫩模</strong>\\n通常是大家对炒币的一种期许，希望币百倍，千倍增长。从而实现财富自由。\\n<strong>韭菜</strong>\\n一般指散户，在区块链项目上的投资通常就是买项目发行的币。门槛很低，基本什么人都能参与。\\n也被用于指不讲技巧的投。比如前面提到的“不要怂，就是干，一把梭”，可用于自嘲，或讽刺他人</p>\\n<h6><strong>问题：</strong></h6>\\n<p>如何定义区块链？只是比特币的区块+链的结构嘛？如果没有对等的节点呢？\\n如果没有p2p分散的节点，或者有人占据了大部分节点，是否能串改数据？区块+链的结构不好改，如果是先搞一个任务池，重构整个区块链呢？也就是一次升级的是吧。</p>\\n<p>区块链还能干做什么？只是做币嘛？没有别的用途嘛？这里先卖个关子。比特币只是一个功能机，后面会讲到一个项目，它把比特币创造的区块链的智能机时代。赋予区块链更多的想象力。</p>\",\"excerpt\":\"…\",\"frontmatter\":{\"path\":\"/blog4\",\"title\":\"比特币的诞生和区块链\"}}},{\"node\":{\"id\":\"/Users/luz/code/js/binstd.github.io/markdown/blog/index.md absPath of file >>> MarkdownRemark\",\"html\":\"<h3><strong>一.简单说下货币&#x26;积分</strong></h3>\\n<h6><strong>原始：黄金白银 贝壳</strong></h6>\\n<p>最早时期，交通不发达，内陆地区使用沿海才有的贝壳做为交换媒介，去换取物品，得到贝壳的人又用它去换取其他物品。后来交通发达后，人们可以轻易获得贝壳，于是贝壳不在做为货币（货币的总量是否要优先，是否要防范增发？）\\n为什么不是铜铁，木头？而是黄金，白银，和稀缺是不是有关系。因为稀缺所有值钱，因为之前，所以不需要太多黄金，就可以换取大部分物品。</p>\\n<h6><strong>山西票号</strong></h6>\\n<p>清明晚期，晋商遍布各地做生意，甚至生意做到海外，由于地域广，商人携带大量黄金白银有些不方便和不安全。山西票号适应了这个需求，它在各地建立票号，商户去票号保存银子，会得到一个票据，凭借票据可以异地提取。大大降低了商人出行携带大量银两的安全隐患和运输成本。</p>\\n<h6><strong>传统的数据库下的单节点（中心化）-积分</strong></h6>\\n<p>互联网重构很多行业，大家日常在使用各种app&#x26;网站时都有一个积分，比如早期的qq币，大家想一下这个东西如何实现？\\n<strong>大家大概都能想到一个数据仓库（专业点说叫数据库），记录着：</strong>\\n账号信息（用户名，昵称，秘密），你的qq币额度（还有多少qq币），你的消费记录（记录你的币怎么获得的，怎么消费的，你购买了什么东西）\\n<strong>这是什么呢，这是一个单节点维持的账本，腾讯这家公司控制的账本，这个账本能否做为货币？</strong></p>\\n<h3><strong>二.比特币的诞生</strong></h3>\\n<p>2008经济危机背景下，中本聪发表了比特币-点对点的电子支付系统，次年比特币诞生。2009年比特币正式上线。\\n并且在创世区块中写入了泰晤士报09年1.3号的头版标题，讽刺了一把银行。\\n大家肯定好奇比特币这套系统为什么得到那么多人推崇，为什么可以做到一枚2万美金？</p>\\n<p><strong>比特币是如何实现货币功能的？</strong></p>\\n<h6>1.多节点维持的账本（数据库）</h6>\\n<p>比特币创造了一个没有任何主体控制的系统，上文提到的积分是单个节点说了算，例如q币，就是腾讯说了算的，而比特币有多对等节点。且每个对等节点都有相同的完整的数据库记录或者说账本。\\n<strong>先看一下这个图，理解一下什么叫对等的节点，没有控制者：</strong></p>\\n<p><img src=\\\"https://blockluz-1253389096.cos.ap-beijing.myqcloud.com/blockman/qft6j.jpg\\\"></p>\\n<p><strong>一个经典问题：拜占庭军事问题，怎么解决这个问题？怎么保证数据一致，又怎么保证鼓励大家做比特币的节点（激励层）？这里先卖个关子，先从单个节点的数据结构上说：</strong></p>\\n<h6>2.比特币的单节点的数据结构</h6>\\n<p>区块+链，简单说就是一个个区块一环扣一环，链接而成：</p>\\n<p><img src=\\\"https://blockluz-1253389096.cos.ap-beijing.myqcloud.com/blockman/le9ng.jpg\\\"></p>\\n<p>听到区块这个词不必紧张，你把它当作一个有固定结构和规范的容器就行，就像一个楼层，一个房间。其中区块这个容器构成：包括区块头，交易记录两部分。\\n如图其中区块头中又包含三个部分父区块hash值，merkle树根，挖矿相关的难度值，时间戳等。大家先不用关系他们代表什么，我会在下文一一说明。\\n<strong>1.重点说父区块hash：</strong>（大家可以把hash值换成地址方便理解），这个父区块hash值呢，也可以说是上一个区块的hash值或者说地址（方便理解）。它的作用主要就是知道了前一个区块地址，从而连接前一个区块，形成一环扣一环的所谓区块链：</p>\\n<p><img src=\\\"https://blockluz-1253389096.cos.ap-beijing.myqcloud.com/blockman/xewx9.jpg\\\"></p>\\n<p>大家看图就会明白，这个一环扣一环既，如果其中一个区块的hash值出现变化，那整个链就断了。而上文提到上一个区块的hash值，那这个hash值是怎么来的呢？其实是对真个区块容器里，装载的所有信息或者说东西做一个运算得来的唯一值（hash运算），也就是说，区块中装载的信息出现改变，hash值一定会改变。从而提高了造假成本。</p>\\n<p><strong>接下来说区块头的的第二个信息merkle树根</strong>，这个词很飘，其实它的用途是做一个标记，刚才跟大家介绍了区块分成两个部分，一个区块头&#x26;一个是交易信息。其中交易信息是比特币的所有的转账记录（比特币的一个区块规定了所能装载的交易记录是1m，也就是大约500笔交易。当装满的时候，就会在区块头加上merkle树根信息，做为标识）</p>\\n<p><strong>而挖矿相关的信息</strong>，主要是用于生成下一个区块，以及发现该区块，这个知识点下文会说。</p>\\n<p>那么之前留下的问题是非可以解答了呢？<strong>即如何没有服务端控制，p2p之间如何协调一致，没有将军，士兵之间如何协调？如何刺激大家做比特币的节点，成为一个p？如何取代央行做货币的发行？</strong></p>\\n<h6>3.共识算法：pow&#x26;运行原理</h6>\\n<p>比特币的解决办法就是pow共识机制，想了解它，我们先来了解一个古老的问题，<strong>即拜占庭军事问题：</strong>\\n讲一个小故事，古时候有一个国家叫拜占庭，他很有钱也很强大，周围有几个小国，他们希望得到拜占庭的财富，但是呢，他们单个国家又无法攻破拜占庭，去攻击拜占庭一定会被消灭，他们之间呢，又各怀鬼胎，企图占领他国。\\n唯一能攻破拜占庭的方案就是他们几个国家一起攻击。这里就涉及到一个问题，就是这个几个互不信任的国家，如何同步的问题。</p>\\n<p>前面提到比特币是区块+链的结构，且区块头中有父区块的hash值，也就知道了父区块的位置，<strong>然后比特币里有个出块的概念，既每隔一段时间产生一个新区块（空的）</strong>中本聪发明了一个游戏，谁先踩中下一个区块的hash值，就全网停止继续运算，全网也去同步他的区块。并准备猜下一个区块的hash值。\\n如何猜中hash值，控制难度呢？由前面提到的区块头的挖矿相关的nonce值，时间戳等控制。</p>\\n<p><img src=\\\"https://blockluz-1253389096.cos.ap-beijing.myqcloud.com/blockman/ez1rn.jpg\\\"></p>\\n<p><strong>那么比特币如何鼓励大家成为它的节点呢？</strong>猜出新区块hash值的矿工，可以获得一个叫coinbase交易的奖励，以及转账的手续费奖励。\\n<strong>这里就要提到区块结构的第二部分：交易信息（merkle树）</strong>\\n首先明确一个概念，比特币是没有账户概念的，所以的额度，都是通过遍历整个的交易信息获取到，并做+-运算的来。\\n所以的比特币客户端出了区块链这个库，还有一个交易池的概念，既你的每次转账都会广播全网的所有节点，并将该转账信息加入到他们各种的交易池中，而非直接放到区块链里。\\n<strong>如何将交易池中保存的交易记录放到区块链中呢？</strong>\\n每次挖出新块后矿工，即将交易数据打包放到到新区块中，其中挖矿获得的奖励和交易手续费也将加入到区块中。直到区块装满（比特币是1m的交易容量），和上文提到的踩中hash后的广播是同一次的。 </p>\\n<p><img src=\\\"media/15219667839362/15221343606583.jpg\\\">                                                                                  </p>\\n<h6>4.<strong>比特币的公钥匙私</strong></h6>\\n<p>比特币生成一个私钥，对私钥做算法运算得到公钥。这个运算是有一个固定算法的，所以可以离线生成比特币的私钥。（硬件钱包，纸钱包原理），且不可逆转。\\n<img src=\\\"https://blockluz-1253389096.cos.ap-beijing.myqcloud.com/blockman/939e3.jpg\\\"></p>\\n<h6><strong>钱包说明</strong></h6>\\n<p>这个私钥是意味着控制权。联想到上面的区块链的交易记录，他会记录转账地址和金额。这个地址就是公钥。所以你可以在任何钱包上使用这个私钥。\\n在交易所中，只提供给你币的地址，没有提供私钥。所以你的转账，其实最终的控制是交易所完成的。而非你自己。但是在钱包里就不一样了。</p>\\n<p>钱包是不是比特币的节点？不一定，有集成节点的钱包，也有调取的比特币网络节点接口的钱包。</p>\\n<h3>附录</h3>\\n<h6>名词解释避坑：</h6>\\n<p><strong>共识：</strong>\\n共识机制的共识是指不同节点直接的数据同步，以及奖励的分配的共识。\\n而在民生，在大众认同等问题上也会提到共识。比如比特币靠什么能赢？很多人说共识，其实这个共识的意思是大众的认同，也就是多少人认可你。在区块链项目里，通常有个社区治理的概念，即有多少人支持一个项目，对这个项目生态又有什么意见。往往涉及到投票等。这里大家可以预先查一下，dac，dao这些概念。了解下社区治理。同时后面解释一个项目：比特股也会在探讨他。</p>\\n<p><strong>节点：</strong>\\n很多资料只会给你解释比特币的区块链里是保存交易记录的。但是没有说明这个交易记录是一种树结构，这种树结构是很多区块链项目都有涉及到的。树就有节点。这里要和区块链网络的节点区分开。</p>\\n<h6><strong>课外常识：</strong></h6>\\n<p><strong>不要怂，就是干，一把梭</strong>\\n对梭的解释：\\n早期出现在股票市场里，主要指不管3721，把前投进去就是了。常常被大家用来自嘲。\\n<strong>会所嫩模</strong>\\n通常是大家对炒币的一种期许，希望币百倍，千倍增长。从而实现财富自由。\\n<strong>韭菜</strong>\\n一般指散户，在区块链项目上的投资通常就是买项目发行的币。门槛很低，基本什么人都能参与。\\n也被用于指不讲技巧的投。比如前面提到的“不要怂，就是干，一把梭”，可用于自嘲，或讽刺他人</p>\\n<h6><strong>问题：</strong></h6>\\n<p>如何定义区块链？只是比特币的区块+链的结构嘛？如果没有对等的节点呢？\\n如果没有p2p分散的节点，或者有人占据了大部分节点，是否能串改数据？区块+链的结构不好改，如果是先搞一个任务池，重构整个区块链呢？也就是一次升级的是吧。</p>\\n<p>区块链还能干做什么？只是做币嘛？没有别的用途嘛？这里先卖个关子。比特币只是一个功能机，后面会讲到一个项目，它把比特币创造的区块链的智能机时代。赋予区块链更多的想象力。</p>\",\"excerpt\":\"…\",\"frontmatter\":{\"path\":\"/eth\",\"title\":\"比特币的诞生和区块链\"}}},{\"node\":{\"id\":\"/Users/luz/code/js/binstd.github.io/markdown/docs/en/composite-component.md absPath of file >>> MarkdownRemark\",\"html\":\"<h1>Assemble a composite component</h1>\\n<p>Last chapter we built our first component; this chapter extends what we learned to build TaskList, a list of Tasks. Let’s combine components together and see what happens when more complexity is introduced.</p>\\n<h2>Tasklist</h2>\\n<p>Taskbox emphasizes pinned tasks by positioning them above default tasks. This yields two variations of <code>TaskList</code> you need to create stories for: default items and default and pinned items.</p>\\n<p><img src=\\\"/tasklist-states-1.png\\\" alt=\\\"default and pinned tasks\\\"></p>\\n<p>Since <code>Task</code> data can be sent asynchronously, we <strong>also</strong> need a loading state to render in the absence of a connection. In addition, an empty state is required when there are no tasks.</p>\\n<p><img src=\\\"/tasklist-states-2.png\\\" alt=\\\"empty and loading tasks\\\"></p>\\n<h2>Get setup</h2>\\n<p>A composite component isn’t much different than the basic components it contains. Create a <code>TaskList</code> component and an accompanying story file: <code>src/components/TaskList.js</code> and <code>src/components/TaskList.stories.js</code>.</p>\\n<p>Start with a rough implementation of the <code>TaskList</code>. You’ll need to import the <code>Task</code> component from earlier and pass in the attributes and actions as inputs.</p>\\n<pre><code class=\\\"language-javascript\\\">import React from 'react';\\n\\nimport Task from './Task';\\n\\nfunction TaskList({ loading, tasks, onPinTask, onArchiveTask }) {\\n  const events = {\\n    onPinTask,\\n    onArchiveTask,\\n  };\\n\\n  if (loading) {\\n    return &#x3C;div className=\\\"list-items\\\">loading&#x3C;/div>;\\n  }\\n\\n  if (tasks.length === 0) {\\n    return &#x3C;div className=\\\"list-items\\\">empty&#x3C;/div>;\\n  }\\n\\n  return (\\n    &#x3C;div className=\\\"list-items\\\">\\n      {tasks.map(task => &#x3C;Task key={task.id} task={task} {...events} />)}\\n    &#x3C;/div>\\n  );\\n}\\n\\nexport default TaskList;\\n</code></pre>\\n<p>Next create <code>Tasklist</code>’s test states in the story file.</p>\\n<pre><code class=\\\"language-javascript\\\">import React from 'react';\\nimport { storiesOf } from '@storybook/react';\\n\\nimport TaskList from './TaskList';\\nimport { task, actions } from './Task.stories';\\n\\nexport const defaultTasks = [\\n  { ...task, id: '1', title: 'Task 1' },\\n  { ...task, id: '2', title: 'Task 2' },\\n  { ...task, id: '3', title: 'Task 3' },\\n  { ...task, id: '4', title: 'Task 4' },\\n  { ...task, id: '5', title: 'Task 5' },\\n  { ...task, id: '6', title: 'Task 6' },\\n];\\n\\nexport const withPinnedTasks = [\\n  ...defaultTasks.slice(0, 5),\\n  { id: '6', title: 'Task 6 (pinned)', state: 'TASK_PINNED' },\\n];\\n\\nstoriesOf('TaskList', module)\\n  .addDecorator(story => &#x3C;div style={{ padding: '3rem' }}>{story()}&#x3C;/div>)\\n  .add('default', () => &#x3C;TaskList tasks={defaultTasks} {...actions} />)\\n  .add('withPinnedTasks', () => &#x3C;TaskList tasks={withPinnedTasks} {...actions} />)\\n  .add('loading', () => &#x3C;TaskList loading tasks={[]} {...actions} />)\\n  .add('empty', () => &#x3C;TaskList tasks={[]} {...actions} />);\\n</code></pre>\\n<p><code>addDecorator()</code> allows us to add some “context” to the rendering of each task. In this case we add padding around the list to make it easier to visually verify.</p>\\n<div class=\\\"aside\\\">\\n<a href=\\\"https://storybook.js.org/addons/introduction/#1-decorators\\\"><b>Decorators</b></a> are a way to provide arbitrary wrappers to stories. In this case we’re using a decorator to add styling. They can also be used to wrap stories in “providers” –i.e. library components that set React context.\\n</div>\\n<p><code>task</code> supplies the shape of a <code>Task</code> that we created and exported from the <code>Task.stories.js</code> file. Similarly, <code>actions</code> defines the actions (mocked callbacks) that a <code>Task</code> component expects, which the <code>TaskList</code> also needs.</p>\\n<p>Now check Storybook for the new <code>TaskList</code> stories.</p>\\n<video autoPlay muted playsInline loop>\\n  <source\\n    src=\\\"/inprogress-tasklist-states.mp4\\\"\\n    type=\\\"video/mp4\\\"\\n  />\\n</video>\\n<h2>Build out the states</h2>\\n<p>Our component is still rough but now we have an idea of the stories to work toward. You might be thinking that the <code>.list-items</code> wrapper is overly simplistic. You're right – in most cases we wouldn’t create a new component just to add a wrapper. But the <strong>real complexity</strong> of <code>TaskList</code> component is revealed in the edge cases <code>withPinnedTasks</code>, <code>loading</code>, and <code>empty</code>.</p>\\n<pre><code class=\\\"language-javascript\\\">import React from 'react';\\n\\nimport Task from './Task';\\n\\nfunction TaskList({ loading, tasks, onPinTask, onArchiveTask }) {\\n  const events = {\\n    onPinTask,\\n    onArchiveTask,\\n  };\\n\\n  const LoadingRow = (\\n    &#x3C;div className=\\\"loading-item\\\">\\n      &#x3C;span className=\\\"glow-checkbox\\\" />\\n      &#x3C;span className=\\\"glow-text\\\">\\n        &#x3C;span>Loading&#x3C;/span> &#x3C;span>cool&#x3C;/span> &#x3C;span>state&#x3C;/span>\\n      &#x3C;/span>\\n    &#x3C;/div>\\n  );\\n\\n  if (loading) {\\n    return (\\n      &#x3C;div className=\\\"list-items\\\">\\n        {LoadingRow}\\n        {LoadingRow}\\n        {LoadingRow}\\n        {LoadingRow}\\n        {LoadingRow}\\n        {LoadingRow}\\n      &#x3C;/div>\\n    );\\n  }\\n\\n  if (tasks.length === 0) {\\n    return (\\n      &#x3C;div className=\\\"list-items\\\">\\n        &#x3C;div className=\\\"wrapper-message\\\">\\n          &#x3C;span className=\\\"icon-check\\\" />\\n          &#x3C;div className=\\\"title-message\\\">You have no tasks&#x3C;/div>\\n          &#x3C;div className=\\\"subtitle-message\\\">Sit back and relax&#x3C;/div>\\n        &#x3C;/div>\\n      &#x3C;/div>\\n    );\\n  }\\n\\n  const tasksInOrder = [\\n    ...tasks.filter(t => t.state === 'TASK_PINNED'),\\n    ...tasks.filter(t => t.state !== 'TASK_PINNED'),\\n  ];\\n\\n  return (\\n    &#x3C;div className=\\\"list-items\\\">\\n      {tasksInOrder.map(task => &#x3C;Task key={task.id} task={task} {...events} />)}\\n    &#x3C;/div>\\n  );\\n}\\n\\nexport default TaskList;\\n</code></pre>\\n<p>The added markup results in the following UI:</p>\\n<video autoPlay muted playsInline loop>\\n  <source\\n    src=\\\"/finished-tasklist-states.mp4\\\"\\n    type=\\\"video/mp4\\\"\\n  />\\n</video>\\n<p>Note the position of the pinned item in the list. We want the pinned item to render at the top of the list to make it a priority for our users.</p>\\n<h2>Data requirements and props</h2>\\n<p>As the component grows, so too do input requirements. Define the prop requirements of <code>TaskList</code>. Because <code>Task</code> is a child component, make sure to provide data in the right shape to render it. To save time and headache, reuse the propTypes you defined in <code>Task</code> earlier.</p>\\n<pre><code class=\\\"language-javascript\\\">import React from 'react';\\nimport PropTypes from 'prop-types';\\n\\nfunction TaskList() {\\n  ...\\n}\\n\\n\\nTaskList.propTypes = {\\n  loading: PropTypes.bool,\\n  tasks: PropTypes.arrayOf(Task.propTypes.task).isRequired,\\n  onPinTask: PropTypes.func.isRequired,\\n  onArchiveTask: PropTypes.func.isRequired,\\n};\\n\\nTaskList.defaultProps = {\\n  loading: false,\\n};\\n\\nexport default TaskList;\\n</code></pre>\\n<h2>Automated testing</h2>\\n<p>In the previous chapter we learned how to snapshot test stories using Storyshots. With <code>Task</code> there wasn’t a lot of complexity to test beyond that it renders OK. Since <code>TaskList</code> adds another layer of complexity we want to verify that certain inputs produce certain outputs in a way amenable to automatic testing. To do this we’ll create unit tests using <a href=\\\"https://facebook.github.io/jest/\\\">Jest</a> coupled with a test renderer such as <a href=\\\"http://airbnb.io/enzyme/\\\">Enzyme</a>.</p>\\n<p><img src=\\\"/logo-jest.png\\\" alt=\\\"Jest logo\\\"></p>\\n<h3>Unit tests with Jest</h3>\\n<p>Storybook stories paired with manual visual tests and snapshot tests (see above) go a long way to avoiding UI bugs. If stories cover a wide variety of component use cases, and we use tools that ensure a human checks any change to the story, errors are much less likely.</p>\\n<p>However, sometimes the devil is in the details. A test framework that is explicit about those details is needed. Which brings us to unit tests.</p>\\n<p>In our case, we want our <code>TaskList</code> to render any pinned tasks <strong>before</strong> unpinned tasks that it is passed in the <code>tasks</code> prop. Although we have a story (<code>withPinnedTasks</code>) to test this exact scenario; it can be ambiguous to a human reviewer that if the component <strong>stops</strong> ordering the tasks like this, it is a bug. It certainly won’t scream <strong>“Wrong!”</strong> to the casual eye.</p>\\n<p>So, to avoid this problem, we can use Jest to render the story to the DOM and run some DOM querying code to verify salient features of the output.</p>\\n<p>Create a test file called <code>TaskList.test.js</code>. Here we’ll build out our tests that make assertions about the output.</p>\\n<pre><code class=\\\"language-javascript\\\">import React from 'react';\\nimport ReactDOM from 'react-dom';\\nimport TaskList from './TaskList';\\nimport { withPinnedTasks } from './TaskList.stories';\\n\\nit('renders pinned tasks at the start of the list', () => {\\n  const div = document.createElement('div');\\n  const events = { onPinTask: jest.fn(), onArchiveTask: jest.fn() };\\n  ReactDOM.render(&#x3C;TaskList tasks={withPinnedTasks} {...events} />, div);\\n\\n  // We expect the task titled \\\"Task 6 (pinned)\\\" to be rendered first, not at the end\\n  const lastTaskInput = div.querySelector('.list-item:nth-child(1) input[value=\\\"Task 6 (pinned)\\\"]');\\n  expect(lastTaskInput).not.toBe(null);\\n\\n  ReactDOM.unmountComponentAtNode(div);\\n});\\n</code></pre>\\n<p><img src=\\\"/tasklist-testrunner.png\\\" alt=\\\"TaskList test runner\\\"></p>\\n<p>Note that we’ve been able to reuse the <code>withPinnedTasks</code> list of tasks in both story and unit test; in this way we can continue to leverage an existing resource (the examples that represent interesting configurations of a component) in more and more ways.</p>\\n<p>Notice as well that this test is quite brittle. It's possible that as the project matures, and the exact implementation of the <code>Task</code> changes --perhaps using a different classname or a <code>textarea</code> rather than an <code>input</code>--the test will fail, and need to be updated. This is not necessarily a problem, but rather an indication to be careful liberally using unit tests for UI. They're not easy to maintain. Instead rely on visual, snapshot, and visual regression (see <a href=\\\"/test/\\\">testing chapter</a>) tests where possible.</p>\",\"excerpt\":\"Assemble a composite component Last chapter we built our first component; this chapter extends what we learned to build TaskList, a list of Tasks. Let’s combine components together and see what happens when more complexity is introduced. Tasklist…\",\"frontmatter\":{\"path\":null,\"title\":\"Assemble a composite component\"}}},{\"node\":{\"id\":\"/Users/luz/code/js/binstd.github.io/markdown/docs/en/conclusion.md absPath of file >>> MarkdownRemark\",\"html\":\"<h1>Conclusion</h1>\\n<p>Congratulations! You created your first UI in Storybook. Along the way you learned how to build, compose, test, and deploy UI components. If you’ve been following, your repo and deployed Storybook should look like this:</p>\\n<p><a href=\\\"https://github.com/hichroma/learnstorybook-code\\\">📕 <strong>GitHub repo: hichroma/learnstorybook-code</strong></a>\\n<br/>\\n<a href=\\\"https://clever-banach-415c03.netlify.com/\\\">🌎 <strong>Deployed Storybook</strong></a></p>\\n<p>Storybook is a powerful tool for React, Vue, and Angular. It has a thriving developer community and a wealth of addons. This introduction scratches the surface of what’s possible. We’re confident that once you adopt Storybook, you’ll be impressed by how productive it is to build durable UIs.</p>\\n<h2>Learn more</h2>\\n<p>Want to dive deeper? Here are helpful resources.</p>\\n<ul>\\n<li>\\n<p><a href=\\\"https://storybook.js.org/basics/introduction/\\\"><strong>Official Storybook documentation</strong></a> has API documentation, community links, and the addon gallery.</p>\\n</li>\\n<li>\\n<p><a href=\\\"https://blog.hichroma.com/the-delightful-storybook-workflow-b322b76fd07\\\"><strong>The Delightful Storybook Workflow</strong></a> highlights workflow best practices used by high-velocity teams at Squarespace, Major League Soccer, Discovery Network, and Apollo GraphQL.</p>\\n</li>\\n<li>\\n<p><a href=\\\"https://www.chromaticqa.com/book/visual-testing-handbook\\\"><strong>Visual Testing Handbook</strong></a> dives deep into using Storybook to visual test components. Free 31-page ebook.</p>\\n</li>\\n</ul>\\n<h2>Who made LearnStorybook.com?</h2>\\n<p>The text, code, and production were contributed by <a href=\\\"http://blog.hichroma.com/\\\">Chroma</a>. The tutorial was inspired by Chroma’s popular <a href=\\\"https://blog.hichroma.com/graphql-react-tutorial-part-1-6-d0691af25858\\\">GraphQL + React tutorial series</a>.</p>\\n<p>Want more tutorials and articles like this? Sign up to the Chroma mailing list.</p>\\n<iframe style=\\\"height:400px;width:100%;max-width:800px;margin:30px auto;\\\" src=\\\"https://upscri.be/bface0?as_embed\\\"></iframe>\",\"excerpt\":\"Conclusion Congratulations! You created your first UI in Storybook. Along the way you learned how to build, compose, test, and deploy UI components. If you’ve been following, your repo and deployed Storybook should look like this: 📕  GitHub repo…\",\"frontmatter\":{\"path\":\"/blog\",\"title\":\"Conclusion\"}}},{\"node\":{\"id\":\"/Users/luz/code/js/binstd.github.io/markdown/docs/en/contribute.md absPath of file >>> MarkdownRemark\",\"html\":\"<h1>Contribute</h1>\\n<p>Contributions to Learn Storybook are encouraged! If it’s something small like grammar or punctuation, open up a pull request. If it’s a bigger change, <a href=\\\"https://github.com/hichroma/learnstorybook.com/issues\\\">add an issue</a> for discussion.</p>\\n<h2>Vue and Angular editions</h2>\\n<p>We’re looking for assistance updating our React/Redux example code to Vue and Angular. Comment on the <a href=\\\"https://github.com/hichroma/learnstorybook.com/issues/1\\\">Vue</a> or <a href=\\\"https://github.com/hichroma/learnstorybook.com/issues/2\\\">Angular</a> GitHub issue.</p>\\n<p><img src=\\\"/logos-angular-vue.png\\\" alt=\\\"Vue and Angular contributors wanted\\\"></p>\\n<h2>Translations</h2>\\n<p>Our goal is to make Storybook approachable to all people. Help translate this tutorial into other languages. We’re especially open to Chinese and Spanish translations. Comment on the <a href=\\\"https://github.com/hichroma/learnstorybook.com/issues/3\\\">issue here</a>.</p>\",\"excerpt\":\"Contribute Contributions to Learn Storybook are encouraged! If it’s something small like grammar or punctuation, open up a pull request. If it’s a bigger change,  add an issue  for discussion. Vue and Angular editions We’re looking for assistance…\",\"frontmatter\":{\"path\":\"/eth2\",\"title\":\"Contribute\"}}},{\"node\":{\"id\":\"/Users/luz/code/js/binstd.github.io/markdown/docs/en/data.md absPath of file >>> MarkdownRemark\",\"html\":\"<h1>Wire in data</h1>\\n<p>So far we created isolated stateless components –great for Storybook, but ultimately not useful until we give them some data in our app.</p>\\n<p>This tutorial doesn’t focus on the particulars of building an app so we won’t dig into those details here. But we will take a moment to look at a common pattern for wiring in data with container components.</p>\\n<h2>Container components</h2>\\n<p>Our <code>TaskList</code> component as currently written is “presentational” (see <a href=\\\"https://medium.com/@dan_abramov/smart-and-dumb-components-7ca2f9a7c7d0\\\">this blog post</a>) in that it doesn’t talk to anything external to its own implementation. To get data into it, we need a “container”.</p>\\n<p>This example uses <a href=\\\"https://redux.js.org/\\\">Redux</a>, the most popular React library for storing data, to build a simple data model for our app. However, the pattern used here applies just as well to other data management libraries like <a href=\\\"https://www.apollographql.com/client/\\\">Apollo</a> and <a href=\\\"https://mobx.js.org/\\\">MobX</a>.</p>\\n<p>First we’ll construct a simple Redux store that responds to actions that change the state of tasks, in a file called <code>lib/redux.js</code> in the <code>src</code> folder (intentionally kept simple):</p>\\n<pre><code class=\\\"language-javascript\\\">// A simple redux store/actions/reducer implementation.\\n// A true app would be more complex and separated into different files.\\nimport { createStore } from 'redux';\\n\\n// The actions are the \\\"names\\\" of the changes that can happen to the store\\nexport const actions = {\\n  ARCHIVE_TASK: 'ARCHIVE_TASK',\\n  PIN_TASK: 'PIN_TASK',\\n};\\n\\n// The action creators are how you bundle actions with the data required to execute them\\nexport const archiveTask = id => ({ type: actions.ARCHIVE_TASK, id });\\nexport const pinTask = id => ({ type: actions.PIN_TASK, id });\\n\\n// All our reducers simply change the state of a single task.\\nfunction taskStateReducer(taskState) {\\n  return (state, action) => {\\n    return {\\n      ...state,\\n      tasks: state.tasks.map(\\n        task => (task.id === action.id ? { ...task, state: taskState } : task)\\n      ),\\n    };\\n  };\\n}\\n\\n// The reducer describes how the contents of the store change for each action\\nexport const reducer = (state, action) => {\\n  switch (action.type) {\\n    case actions.ARCHIVE_TASK:\\n      return taskStateReducer('TASK_ARCHIVED')(state, action);\\n    case actions.PIN_TASK:\\n      return taskStateReducer('TASK_PINNED')(state, action);\\n    default:\\n      return state;\\n  }\\n};\\n\\n// The initial state of our store when the app loads.\\n// Usually you would fetch this from a server\\nconst defaultTasks = [\\n  { id: '1', title: 'Something', state: 'TASK_INBOX' },\\n  { id: '2', title: 'Something more', state: 'TASK_INBOX' },\\n  { id: '3', title: 'Something else', state: 'TASK_INBOX' },\\n  { id: '4', title: 'Something again', state: 'TASK_INBOX' },\\n];\\n\\n// We export the constructed redux store\\nexport default createStore(reducer, { tasks: defaultTasks });\\n</code></pre>\\n<p>Then we’ll update the default export from the <code>TaskList</code> component to connect to the Redux store and render the tasks we are interested in:</p>\\n<pre><code class=\\\"language-javascript\\\">import React from 'react';\\nimport PropTypes from 'prop-types';\\n\\nimport Task from './Task';\\nimport { connect } from 'react-redux';\\nimport { archiveTask, pinTask } from '../lib/redux';\\n\\nexport function PureTaskList({ loading, tasks, onPinTask, onArchiveTask }) {\\n  /* previous implementation of TaskList */\\n}\\n\\nPureTaskList.propTypes = {\\n  loading: PropTypes.bool,\\n  tasks: PropTypes.arrayOf(Task.propTypes.task).isRequired,\\n  onPinTask: PropTypes.func.isRequired,\\n  onArchiveTask: PropTypes.func.isRequired,\\n};\\n\\nPureTaskList.defaultProps = {\\n  loading: false,\\n};\\n\\nexport default connect(\\n  ({ tasks }) => ({\\n    tasks: tasks.filter(t => t.state === 'TASK_INBOX' || t.state === 'TASK_PINNED'),\\n  }),\\n  dispatch => ({\\n    onArchiveTask: id => dispatch(archiveTask(id)),\\n    onPinTask: id => dispatch(pinTask(id)),\\n  })\\n)(PureTaskList);\\n</code></pre>\\n<p>At this stage our Storybook tests will have stopped working, as the <code>TaskList</code> is now a container, and no longer expects any props, instead it connects to the store and sets the props on the <code>PureTaskList</code> component it wraps.</p>\\n<p>However, we can easily solve this problem by simply rendering the <code>PureTaskList</code> --the presentational component-- in our Storybook stories:</p>\\n<pre><code class=\\\"language-javascript\\\">import React from 'react';\\nimport { storiesOf } from '@storybook/react';\\n\\nimport { PureTaskList } from './TaskList';\\nimport { task, actions } from './Task.stories';\\n\\nexport const defaultTasks = [\\n  { ...task, id: '1', title: 'Task 1' },\\n  { ...task, id: '2', title: 'Task 2' },\\n  { ...task, id: '3', title: 'Task 3' },\\n  { ...task, id: '4', title: 'Task 4' },\\n  { ...task, id: '5', title: 'Task 5' },\\n  { ...task, id: '6', title: 'Task 6' },\\n];\\n\\nexport const withPinnedTasks = [\\n  ...defaultTasks.slice(0, 5),\\n  { id: '6', title: 'Task 6 (pinned)', state: 'TASK_PINNED' },\\n];\\n\\nstoriesOf('TaskList', module)\\n  .addDecorator(story => &#x3C;div style={{ padding: '3rem' }}>{story()}&#x3C;/div>)\\n  .add('default', () => &#x3C;PureTaskList tasks={defaultTasks} {...actions} />)\\n  .add('withPinnedTasks', () => &#x3C;PureTaskList tasks={withPinnedTasks} {...actions} />)\\n  .add('loading', () => &#x3C;PureTaskList loading tasks={[]} {...actions} />)\\n  .add('empty', () => &#x3C;PureTaskList tasks={[]} {...actions} />);\\n</code></pre>\\n<video autoPlay muted playsInline loop>\\n  <source\\n    src=\\\"/finished-tasklist-states.mp4\\\"\\n    type=\\\"video/mp4\\\"\\n  />\\n</video>\\n<p>Similarly, we need to use <code>PureTaskList</code> in our Jest test:</p>\\n<pre><code class=\\\"language-js\\\">import React from 'react';\\nimport ReactDOM from 'react-dom';\\nimport { PureTaskList } from './TaskList';\\nimport { withPinnedTasks } from './TaskList.stories';\\n\\nit('renders pinned tasks at the start of the list', () => {\\n  const div = document.createElement('div');\\n  const events = { onPinTask: jest.fn(), onArchiveTask: jest.fn() };\\n  ReactDOM.render(&#x3C;PureTaskList tasks={withPinnedTasks} {...events} />, div);\\n\\n  // We expect the task titled \\\"Task 6 (pinned)\\\" to be rendered first, not at the end\\n  const lastTaskInput = div.querySelector('.list-item:nth-child(1) input[value=\\\"Task 6 (pinned)\\\"]');\\n  expect(lastTaskInput).not.toBe(null);\\n\\n  ReactDOM.unmountComponentAtNode(div);\\n});\\n</code></pre>\",\"excerpt\":\"Wire in data So far we created isolated stateless components –great for Storybook, but ultimately not useful until we give them some data in our app. This tutorial doesn’t focus on the particulars of building an app so we won’t dig into those details…\",\"frontmatter\":{\"path\":null,\"title\":\"Wire in data\"}}},{\"node\":{\"id\":\"/Users/luz/code/js/binstd.github.io/markdown/docs/en/deploy.md absPath of file >>> MarkdownRemark\",\"html\":\"<h1>Deploy Storybook</h1>\\n<p>In this tutorial we ran Storybook on our development machine. You may also want to share that Storybook with the team, especially the non-technical members. Thankfully, it’s easy to deploy Storybook online.</p>\\n<div class=\\\"aside\\\">\\n<strong>Did you setup Chromatic testing earlier?</strong>\\n<br/>\\n🎉 Your stories are already deployed! Chromatic securely indexes your stories online and tracks them across branches and commits. Skip this chapter and go to the <a href=\\\"/conclusion\\\">conclusion</a>.\\n</div>\\n<h2>Exporting as a static app</h2>\\n<p>To deploy Storybook we first need to export it as a static web app. This functionality is already built into Storybook, we just need to activate it by adding a script to <code>package.json</code>.</p>\\n<pre><code class=\\\"language-javascript\\\">{\\n  \\\"scripts\\\": {\\n    \\\"build-storybook\\\": \\\"build-storybook -c .storybook -o .storybook-static\\\"\\n  }\\n}\\n</code></pre>\\n<p>Now when you build Storybook via <code>npm run build-storybook</code>, it will output a static Storybook in the <code>storybook-static</code> directory.</p>\\n<h2>Continuous deploy</h2>\\n<p>We want to share the latest version of components whenever we push code. To do this we need to continuous deploy Storybook. We’ll rely on GitHub and Netlify to deploy our static site. We’re using the Netlify free plan.</p>\\n<h3>GitHub</h3>\\n<p>First you want to setup Git for your project in the local directory. If you're following along from the previous testing chapter jump to setting up a repository on GitHub.</p>\\n<pre><code class=\\\"language-bash\\\">$ git init\\n</code></pre>\\n<p>Next add files to the first commit.</p>\\n<pre><code class=\\\"language-bash\\\">$ git add .\\n</code></pre>\\n<p>Now commit the files.</p>\\n<pre><code class=\\\"language-bash\\\">$ git commit -m \\\"taskbox UI\\\"\\n</code></pre>\\n<p>Go to GitHub and setup a repository <a href=\\\"https://github.com/new\\\">here</a>. Name your repo “taskbox”.</p>\\n<p><img src=\\\"/github-create-taskbox.png\\\" alt=\\\"GitHub setup\\\"></p>\\n<p>In the new repo setup copy the origin URL of the repo and add it to your git project with this command:</p>\\n<pre><code class=\\\"language-bash\\\">$ git remote add origin https://github.com/&#x3C;your username>/taskbox.git\\n</code></pre>\\n<p>Finally push the repo to GitHub</p>\\n<pre><code class=\\\"language-bash\\\">$ git push -u origin master\\n</code></pre>\\n<h3>Netlify</h3>\\n<p>Netlify has a continuous deployment service built in which will allow us to deploy Storybook without needing to configure our own CI.</p>\\n<div class=\\\"aside\\\">\\nIf you use CI at your company, add a deploy script to your config that uploads <code>storybook-static</code> to a static hosting service like S3.\\n</div>\\n<p><a href=\\\"https://app.netlify.com/start\\\">Create an account on Netlify</a> and click to “create site”.</p>\\n<p><img src=\\\"/netlify-create-site.png\\\" alt=\\\"Netlify create site\\\"></p>\\n<p>Next click the GitHub button to connect Netlify to GitHub. This allows it to access our remote Taskbox repo.</p>\\n<p>Now select the taskbox GitHub repo from the list of options.</p>\\n<p><img src=\\\"/netlify-account-picker.png\\\" alt=\\\"Netlify connect to repo\\\"></p>\\n<p>Configure Netlify by highlighting which build command to run in its CI and which directory the static site is outputted in. For branch choose <code>master</code>. Directory is <code>storybook-static</code>. Build command use <code>yarn build-storybook</code>.</p>\\n<p><img src=\\\"/netlify-settings.png\\\" alt=\\\"Netlify settings\\\"></p>\\n<p>Submit the form to build and deploy the code on the <code>master</code> branch of taskbox.</p>\\n<p>When that's finished we'll see a confirmation message on Netlify with a link to Taskbox’ Storybook online. If you're following along, your deployed Storybook should be online <a href=\\\"https://clever-banach-415c03.netlify.com/\\\">like so</a>.</p>\\n<p><img src=\\\"/netlify-storybook-deploy.png\\\" alt=\\\"Netlify Storybook deploy\\\"></p>\\n<p>We finished setting up continuous deployment of your Storybook! Now we can share our stories with teammates via a link.</p>\\n<p>This is helpful for visual review as part of the standard app development process or simply to show off work 💅.</p>\",\"excerpt\":\"Deploy Storybook In this tutorial we ran Storybook on our development machine. You may also want to share that Storybook with the team, especially the non-technical members. Thankfully, it’s easy to deploy Storybook online. Exporting as a static app…\",\"frontmatter\":{\"path\":null,\"title\":\"Deploy Storybook\"}}},{\"node\":{\"id\":\"/Users/luz/code/js/binstd.github.io/markdown/docs/en/get-started.md absPath of file >>> MarkdownRemark\",\"html\":\"<h1>Get started</h1>\\n<p>Storybook runs alongside your app in development mode. It helps you build UI components isolated from the business logic and context of your app. This edition of Learn Storybook is for React; other editions for Vue and Angular are coming soon.</p>\\n<p><img src=\\\"/storybook-relationship.jpg\\\" alt=\\\"Storybook and your app\\\"></p>\\n<h2>Setup React Storybook</h2>\\n<p>We’ll need to follow a few steps to get the build process set up in your environment. To start with, we want to use <a href=\\\"https://github.com/facebook/create-react-app\\\">Create React App</a> (CRA) to setup our build system, and enable <a href=\\\"https://storybook.js.org/\\\">Storybook</a> and <a href=\\\"https://facebook.github.io/jest/\\\">Jest</a> testing in our created app. Let’s run the following commands:</p>\\n<pre><code class=\\\"language-bash\\\"># Create our application:\\nnpx create-react-app taskbox\\ncd taskbox\\n\\n# Add Storybook:\\nnpx -p @storybook/cli getstorybook\\n</code></pre>\\n<p>We can quickly check that the various environments of our application are working properly:</p>\\n<pre><code class=\\\"language-bash\\\"># Run the test runner (Jest) in a terminal:\\nyarn test\\n\\n# Start the component explorer on port 9009:\\nyarn run storybook\\n\\n# Run the frontend app proper on port 3000:\\nyarn start\\n</code></pre>\\n<div class=\\\"aside\\\">\\n  NOTE: If <code>yarn test</code> throws an error, you may need to install <code>watchman</code> as advised in <a href=\\\"https://github.com/facebook/create-react-app/issues/871#issuecomment-252297884\\\">this issue</a>.\\n</div>\\n<p>Our three frontend app modalities: automated test (Jest), component development (Storybook), and the app itself.</p>\\n<p><img src=\\\"/app-three-modalities.png\\\" alt=\\\"3 modalities\\\"></p>\\n<p>Depending on what part of the app you’re working on, you may want to run one or more of these simultaneously. Since our current focus is creating a single UI component, we’ll stick with running Storybook.</p>\\n<h2>Reuse CSS</h2>\\n<p>Taskbox reuses design elements from the GraphQL and React Tutorial <a href=\\\"https://blog.hichroma.com/graphql-react-tutorial-part-1-6-d0691af25858\\\">example app</a>, so we won’t need to write CSS in this tutorial. We’ll simply compile the LESS to a single CSS file and include it in our app. Copy and paste <a href=\\\"https://github.com/hichroma/learnstorybook-code/blob/master/src/index.css\\\">this compiled CSS</a> into the src/index.css file per CRA’s convention.</p>\\n<p><img src=\\\"/ss-browserchrome-taskbox-learnstorybook.png\\\" alt=\\\"Taskbox UI\\\"></p>\\n<div class=\\\"aside\\\">\\nIf you want to modify the styling, the source LESS files are provided in the GitHub repo.\\n</div>\\n<h2>Add assets</h2>\\n<p>We also need to add the font and icon <a href=\\\"https://github.com/hichroma/learnstorybook-code/tree/master/public\\\">directories</a> to the <code>public/</code> folder. After adding styling and assets, the app will render a bit strangely. That’s OK. We aren’t working on the app right now. We’re starting off with building our first component!</p>\",\"excerpt\":\"Get started Storybook runs alongside your app in development mode. It helps you build UI components isolated from the business logic and context of your app. This edition of Learn Storybook is for React; other editions for Vue and Angular are coming…\",\"frontmatter\":{\"path\":null,\"title\":\"Get started\"}}},{\"node\":{\"id\":\"/Users/luz/code/js/binstd.github.io/markdown/docs/en/screen.md absPath of file >>> MarkdownRemark\",\"html\":\"<h1>Construct a screen</h1>\\n<p>We've concentrated on building UIs from the bottom up; starting small and adding complexity. Doing so has allowed us to develop each component in isolation, figure out its data needs, and play with it in Storybook. All without needing to stand up a server or build out screens!</p>\\n<p>In this chapter we continue to increase the sophistication by combining components in a screen and developing that screen in Storybook.</p>\\n<h2>Nested container components</h2>\\n<p>As our app is very simple, the screen we’ll build is pretty trivial, simply wrapping the <code>TaskList</code> component (which supplies its own data via Redux) in some layout and pulling a top-level <code>error</code> field out of redux (let's assume we'll set that field if we have some problem connecting to our server). Create <code>InboxScreen.js</code> in your <code>components</code> folder:</p>\\n<pre><code class=\\\"language-javascript\\\">import React from 'react';\\nimport PropTypes from 'prop-types';\\nimport { connect } from 'react-redux';\\n\\nimport TaskList from './TaskList';\\n\\nexport function PureInboxScreen({ error }) {\\n  if (error) {\\n    return (\\n      &#x3C;div className=\\\"page lists-show\\\">\\n        &#x3C;div className=\\\"wrapper-message\\\">\\n          &#x3C;span className=\\\"icon-face-sad\\\" />\\n          &#x3C;div className=\\\"title-message\\\">Oh no!&#x3C;/div>\\n          &#x3C;div className=\\\"subtitle-message\\\">Something went wrong&#x3C;/div>\\n        &#x3C;/div>\\n      &#x3C;/div>\\n    );\\n  }\\n\\n  return (\\n    &#x3C;div className=\\\"page lists-show\\\">\\n      &#x3C;nav>\\n        &#x3C;h1 className=\\\"title-page\\\">\\n          &#x3C;span className=\\\"title-wrapper\\\">Taskbox&#x3C;/span>\\n        &#x3C;/h1>\\n      &#x3C;/nav>\\n      &#x3C;TaskList />\\n    &#x3C;/div>\\n  );\\n}\\n\\nPureInboxScreen.propTypes = {\\n  error: PropTypes.string,\\n};\\n\\nPureInboxScreen.defaultProps = {\\n  error: null,\\n};\\n\\nexport default connect(({ error }) => ({ error }))(PureInboxScreen);\\n</code></pre>\\n<p>We also change the <code>App</code> component to render the <code>InboxScreen</code> (eventually we would use a router to choose the correct screen, but let's not worry about that here):</p>\\n<pre><code class=\\\"language-javascript\\\">import React, { Component } from 'react';\\nimport { Provider } from 'react-redux';\\nimport store from './lib/redux';\\n\\nimport InboxScreen from './components/InboxScreen';\\n\\nclass App extends Component {\\n  render() {\\n    return (\\n      &#x3C;Provider store={store}>\\n        &#x3C;InboxScreen />\\n      &#x3C;/Provider>\\n    );\\n  }\\n}\\n\\nexport default App;\\n</code></pre>\\n<p>However, where things get interesting is in rendering the story in Storybook.</p>\\n<p>As we saw previously, the <code>TaskList</code> component is a <strong>container</strong> that renders the <code>PureTaskList</code> presentational component. By definition container components cannot be simply rendered in isolation; they expect to be passed some context or to connect to a service. What this means is that to render a container in Storybook, we must mock (i.e. provide a pretend version) the context or service it requires.</p>\\n<p>When placing the <code>TaskList</code> into Storybook, we were able to dodge this issue by simply rendering the <code>PureTaskList</code> and avoiding the container. We'll do something similar and render the <code>PureInboxScreen</code> in Storybook also.</p>\\n<p>However, for the <code>PureInboxScreen</code> we have a problem because although the <code>PureInboxScreen</code> itself is presentational, its child, the <code>TaskList</code>, is not. In a sense the <code>PureInboxScreen</code> has been polluted by “container-ness”. So when we setup our stories in <code>InboxScreen.stories.js</code>:</p>\\n<pre><code class=\\\"language-javascript\\\">import React from 'react';\\nimport { storiesOf } from '@storybook/react';\\n\\nimport { PureInboxScreen } from './InboxScreen';\\n\\nstoriesOf('InboxScreen', module)\\n  .add('default', () => &#x3C;PureInboxScreen />)\\n  .add('error', () => &#x3C;PureInboxScreen error=\\\"Something\\\" />);\\n</code></pre>\\n<p>We see that although the <code>error</code> story works just fine, we have an issue in the <code>default</code> story, because the <code>TaskList</code> has no Redux store to connect to. (You also would encounter similar problems when trying to test the <code>PureInboxScreen</code> with a unit test).</p>\\n<p><img src=\\\"/broken-inboxscreen.png\\\" alt=\\\"Broken inbox\\\"></p>\\n<p>One way to sidestep this problem is to never render container components anywhere in your app except at the highest level and instead pass all data-requirements down the component hierarchy.</p>\\n<p>However, developers <strong>will</strong> inevitably need to render containers further down the component hierarchy. If we want to render most or all of the app in Storybook (we do!), we need a solution to this issue.</p>\\n<div class=\\\"aside\\\">\\nAs an aside, passing data down the hierarchy is a legitimate approach, especially when using <a href=\\\"http://graphql.org/\\\">GraphQL</a>. It’s how we have built <a href=\\\"https://chromaticqa.com\\\">Chromatic</a> alongside 670+ stories.\\n</div>\\n<h2>Supplying context with decorators</h2>\\n<p>The good news is that it is easy to supply a Redux store to the <code>InboxScreen</code> in a story! We can just use a mocked version of the Redux store provided in a decorator:</p>\\n<pre><code class=\\\"language-javascript\\\">import React from 'react';\\nimport { storiesOf } from '@storybook/react';\\nimport { action } from '@storybook/addon-actions';\\nimport { Provider } from 'react-redux';\\n\\nimport { PureInboxScreen } from './InboxScreen';\\nimport { defaultTasks } from './TaskList.stories';\\n\\n// A super-simple mock of a redux store\\nconst store = {\\n  getState: () => {\\n    return {\\n      tasks: defaultTasks,\\n    };\\n  },\\n  subscribe: () => 0,\\n  dispatch: action('dispatch'),\\n};\\n\\nstoriesOf('InboxScreen', module)\\n  .addDecorator(story => &#x3C;Provider store={store}>{story()}&#x3C;/Provider>)\\n  .add('default', () => &#x3C;PureInboxScreen />)\\n  .add('error', () => &#x3C;PureInboxScreen error=\\\"Something\\\" />);\\n</code></pre>\\n<p>Similar approaches exist to provide mocked context for other data libraries, such as <a href=\\\"https://www.npmjs.com/package/apollo-storybook-decorator\\\">Apollo</a>, <a href=\\\"https://github.com/orta/react-storybooks-relay-container\\\">Relay</a> and others.</p>\\n<p>Cycling through states in Storybook makes it easy to test we’ve done this correctly:</p>\\n<video autoPlay muted playsInline loop >\\n  <source\\n    src=\\\"/finished-inboxscreen-states.mp4\\\"\\n    type=\\\"video/mp4\\\"\\n  />\\n</video>\\n<h2>Component-Driven Development</h2>\\n<p>We started from the bottom with <code>Task</code>, then progressed to <code>TaskList</code>, now we’re here with a whole screen UI. Our <code>InboxScreen</code> accommodates a nested container component and includes accompanying stories.</p>\\n<video autoPlay muted playsInline loop style=\\\"width:480px; height:auto; margin: 0 auto;\\\">\\n  <source\\n    src=\\\"/component-driven-development-optimized.mp4\\\"\\n    type=\\\"video/mp4\\\"\\n  />\\n</video>\\n<p><a href=\\\"https://blog.hichroma.com/component-driven-development-ce1109d56c8e\\\"><strong>Component-Driven Development</strong></a> allows you to gradually expand complexity as you move up the component hierarchy. Among the benefits are a more focused development process and increased coverage of all possible UI permutations. In short, CDD helps you build higher-quality and more complex user interfaces.</p>\\n<p>We’re not done yet - the job doesn't end when the UI is built. We also need to ensure that it remains durable over time.</p>\",\"excerpt\":\"Construct a screen We've concentrated on building UIs from the bottom up; starting small and adding complexity. Doing so has allowed us to develop each component in isolation, figure out its data needs, and play with it in Storybook. All without…\",\"frontmatter\":{\"path\":null,\"title\":\"Construct a screen\"}}},{\"node\":{\"id\":\"/Users/luz/code/js/binstd.github.io/markdown/docs/en/simple-component.md absPath of file >>> MarkdownRemark\",\"html\":\"<h1>Build a simple component</h1>\\n<p>We’ll build our UI following a <a href=\\\"https://blog.hichroma.com/component-driven-development-ce1109d56c8e\\\">Component-Driven Development</a> (CDD) methodology. It’s a process that builds UIs from the “bottom up” starting with components and ending with screens. CDD helps you scale the amount of complexity you’re faced with as you build out the UI.</p>\\n<h2>Task</h2>\\n<p><img src=\\\"/task-states-learnstorybook.png\\\" alt=\\\"Task component in three states\\\"></p>\\n<p><code>Task</code> is the core component in our app. Each task displays slightly differently depending on exactly what state it’s in. We display a checked (or unchecked) checkbox, some information about the task, and a “pin” button, allowing us to move tasks up and down the list. Putting this together, we’ll need these props:</p>\\n<ul>\\n<li><code>title</code> – a string describing the task</li>\\n<li><code>state</code> - which list is the task currently in and is it checked off?</li>\\n</ul>\\n<p>As we start to build <code>Task</code>, we first write our test states that correspond to the different types of tasks sketch above. Then we use Storybook to build the component in isolation using mocked data. We’ll “visual test” the component’s appearance given each state as we go.</p>\\n<p>This process is similar to <a href=\\\"https://en.wikipedia.org/wiki/Test-driven_development\\\">Test-driven development</a> (TDD) that we can call “<a href=\\\"https://blog.hichroma.com/visual-test-driven-development-aec1c98bed87\\\">Visual TDD</a>”.</p>\\n<h2>Get setup</h2>\\n<p>First, let’s create the task component and its accompanying story file: <code>src/components/Task.js</code> and <code>src/components/Task.stories.js</code>.</p>\\n<p>We’ll begin with a basic implementation of the <code>Task</code>, simply taking in the attributes we know we’ll need and the two actions you can take on a task (to move it between lists):</p>\\n<pre><code class=\\\"language-javascript\\\">import React from 'react';\\n\\nexport default function Task({ task: { id, title, state }, onArchiveTask, onPinTask }) {\\n  return (\\n    &#x3C;div className=\\\"list-item\\\">\\n      &#x3C;input type=\\\"text\\\" value={title} readOnly={true} />\\n    &#x3C;/div>\\n  );\\n}\\n</code></pre>\\n<p>Above, we render straightforward markup for <code>Task</code> based on the existing HTML structure of the Todos app.</p>\\n<p>Below we build out Task’s three test states in the story file:</p>\\n<pre><code class=\\\"language-javascript\\\">import React from 'react';\\nimport { storiesOf } from '@storybook/react';\\nimport { action } from '@storybook/addon-actions';\\n\\nimport Task from './Task';\\n\\nexport const task = {\\n  id: '1',\\n  title: 'Test Task',\\n  state: 'TASK_INBOX',\\n  updatedAt: new Date(2018, 0, 1, 9, 0),\\n};\\n\\nexport const actions = {\\n  onPinTask: action('onPinTask'),\\n  onArchiveTask: action('onArchiveTask'),\\n};\\n\\nstoriesOf('Task', module)\\n  .add('default', () => &#x3C;Task task={task} {...actions} />)\\n  .add('pinned', () => &#x3C;Task task={{ ...task, state: 'TASK_PINNED' }} {...actions} />)\\n  .add('archived', () => &#x3C;Task task={{ ...task, state: 'TASK_ARCHIVED' }} {...actions} />);\\n</code></pre>\\n<p>There are two basic levels of organization in Storybook. The component and its child stories. Think of each story as a permutation of a component. You can have as many stories per component as you need.</p>\\n<ul>\\n<li>\\n<p><strong>Component</strong></p>\\n<ul>\\n<li>Story</li>\\n<li>Story</li>\\n<li>Story</li>\\n</ul>\\n</li>\\n</ul>\\n<p>To initiate Storybook we first call the <code>storiesOf()</code> function to register the component. We add a display name for the component –the name that appears on the sidebar in the Storybook app.</p>\\n<p><code>action()</code> allows us to create a callback that appears in the <strong>actions</strong> panel of the Storybook UI when clicked. So when we build a pin button, we’ll be able to determine in the test UI if a button click is successful.</p>\\n<p>As we need to pass the same set of actions to all permutations of our component, it is convenient to bundle them up into a single <code>actions</code> variable and use React's <code>{...actions}</code> props expansion to pass them all at once. <code>&#x3C;Task {...actions}></code> is equivalent to <code>&#x3C;Task onPinTask={actions.onPinTask} onArchiveTask={actions.onArchiveTask}></code>.</p>\\n<p>Another nice thing about bundling the <code>actions</code> that a component needs is that you can <code>export</code> them and use them in stories for components that reuse this component, as we'll see later.</p>\\n<p>To define our stories, we call <code>add()</code> once for each of our test states to generate a story. The action story is a function that returns a rendered element (i.e. a component class with a set of props) in a given state---exactly like a React <a href=\\\"https://reactjs.org/docs/components-and-props.html\\\">Stateless Functional Component</a>.</p>\\n<p>When creating a story we use a base task (<code>task</code>) to build out the shape of the task the component expects. This is typically modelled from what the true data looks like. Again, <code>export</code>-ing this shape will enable us to reuse it in later stories, as we'll see.</p>\\n<div class=\\\"aside\\\">\\n<a href=\\\"https://storybook.js.org/addons/introduction/#2-native-addons\\\"><b>Actions</b></a> help you verify interactions when building UI components in isolation. Oftentimes you won't have access to the functions and state you have in context of the app. Use <code>action()</code> to stub them in.\\n</div>\\n<h2>Config</h2>\\n<p>We also have to make one small change to the Storybook configuration setup (<code>.storybook/config.js</code>) so it notices our <code>.stories.js</code> files and uses our CSS file. By default Storybook looks for stories in a <code>/stories</code> directory; this tutorial uses a naming scheme that is similar to the <code>.test.js</code> naming scheme favoured by CRA for automated tests.</p>\\n<pre><code class=\\\"language-javascript\\\">import { configure } from '@storybook/react';\\nimport '../src/index.css';\\n\\nconst req = require.context('../src', true, /.stories.js$/);\\n\\nfunction loadStories() {\\n  req.keys().forEach(filename => req(filename));\\n}\\n\\nconfigure(loadStories, module);\\n</code></pre>\\n<p>Once we’ve done this, restarting the Storybook server should yield test cases for the three Task states:</p>\\n<video autoPlay muted playsInline controls >\\n  <source\\n    src=\\\"/inprogress-task-states.mp4\\\"\\n    type=\\\"video/mp4\\\"\\n  />\\n</video>\\n<h2>Build out the states</h2>\\n<p>Now we have Storybook setup, styles imported, and test cases built out, we can quickly start the work of implementing the HTML of the component to match the design.</p>\\n<p>The component is still basic at the moment. First write the code that achieves the design without going into too much detail:</p>\\n<pre><code class=\\\"language-javascript\\\">import React from 'react';\\n\\nexport default function Task({ task: { id, title, state }, onArchiveTask, onPinTask }) {\\n  return (\\n    &#x3C;div className={`list-item ${state}`}>\\n      &#x3C;label className=\\\"checkbox\\\">\\n        &#x3C;input\\n          type=\\\"checkbox\\\"\\n          defaultChecked={state === 'TASK_ARCHIVED'}\\n          disabled={true}\\n          name=\\\"checked\\\"\\n        />\\n        &#x3C;span className=\\\"checkbox-custom\\\" onClick={() => onArchiveTask(id)} />\\n      &#x3C;/label>\\n      &#x3C;div className=\\\"title\\\">\\n        &#x3C;input type=\\\"text\\\" value={title} readOnly={true} placeholder=\\\"Input title\\\" />\\n      &#x3C;/div>\\n\\n      &#x3C;div className=\\\"actions\\\" onClick={event => event.stopPropagation()}>\\n        {state !== 'TASK_ARCHIVED' &#x26;&#x26; (\\n          &#x3C;a onClick={() => onPinTask(id)}>\\n            &#x3C;span className={`icon-star`} />\\n          &#x3C;/a>\\n        )}\\n      &#x3C;/div>\\n    &#x3C;/div>\\n  );\\n}\\n</code></pre>\\n<p>The additional markup from above combined with the CSS we imported earlier yields the following UI:</p>\\n<video autoPlay muted playsInline loop>\\n  <source\\n    src=\\\"/finished-task-states.mp4\\\"\\n    type=\\\"video/mp4\\\"\\n  />\\n</video>\\n<h2>Specify data requirements</h2>\\n<p>It’s best practice to use <code>propTypes</code> in React to specify the shape of data that a component expects. Not only is it self documenting, it also helps catch problems early.</p>\\n<pre><code class=\\\"language-javascript\\\">import React from 'react';\\nimport PropTypes from 'prop-types';\\n\\nfunction Task() {\\n  ...\\n}\\n\\nTask.propTypes = {\\n  task: PropTypes.shape({\\n    id: PropTypes.string.isRequired,\\n    title: PropTypes.string.isRequired,\\n    state: PropTypes.string.isRequired,\\n  }),\\n  onArchiveTask: PropTypes.func,\\n  onPinTask: PropTypes.func,\\n};\\n\\nexport default Task;\\n</code></pre>\\n<p>Now a warning in development will appear if the Task component is misused.</p>\\n<div class=\\\"aside\\\">\\nAn alternative way to achieve the same purpose is to use a JavaScript type system like TypeScript to create a type for the component properties.\\n</div>\\n<h2>Component built!</h2>\\n<p>We’ve now successfully built out a component without needing a server or running the entire frontend application. The next step is to build out the remaining Taskbox components one by one in a similar fashion.</p>\\n<p>As you can see, getting started building components in in isolation is easy and fast. We can expect to produce a higher-quality UI with less bugs and more polish because it’s possible to dig in and test every possible state.</p>\\n<h2>Automated Testing</h2>\\n<p>Storybook gave us a great way to visually test our application during construction. The ‘stories’ will help ensure we don’t break our Task visually as we continue to develop the app. However, it is a completely manual process at this stage, and someone has to go to the effort of clicking through each test state and ensuring it renders well and without errors or warnings. Can’t we do that automatically?</p>\\n<h3>Snapshot testing</h3>\\n<p>Snapshot testing refers to the practice of recording the “known good” output of a component for a given input and then flagging the component whenever the output changes in future. This complements Storybook, because it’s a quick way to view the new version of a component and check out the changes.</p>\\n<div class=\\\"aside\\\">\\nMake sure your components render data that doesn't change, so that your snapshot tests won't fail each time. Watch out for things like dates or randomly generated values.\\n</div>\\n<p>With the <a href=\\\"https://github.com/storybooks/storybook/tree/master/addons/storyshots\\\">Storyshots addon</a> a snapshot test is created for each of the stories. Use it by adding a development dependency on the package:</p>\\n<pre><code class=\\\"language-bash\\\">yarn add --dev @storybook/addon-storyshots react-test-renderer\\n</code></pre>\\n<p>Then create an <code>src/storybook.test.js</code> file with the following in it:</p>\\n<pre><code class=\\\"language-javascript\\\">import initStoryshots from '@storybook/addon-storyshots';\\ninitStoryshots();\\n</code></pre>\\n<p>Once the above is done, we can run <code>yarn test</code> and see the following output:</p>\\n<p><img src=\\\"/task-testrunner.png\\\" alt=\\\"Task test runner\\\"></p>\\n<p>We now have a snapshot test for each of our <code>Task</code> stories. If we change the implementation of <code>Task</code>, we’ll be prompted to verify the changes.</p>\",\"excerpt\":\"Build a simple component We’ll build our UI following a  Component-Driven Development  (CDD) methodology. It’s a process that builds UIs from the “bottom up” starting with components and ending with screens. CDD helps you scale the amount of…\",\"frontmatter\":{\"path\":null,\"title\":\"Build a simple component\"}}},{\"node\":{\"id\":\"/Users/luz/code/js/binstd.github.io/markdown/docs/en/test.md absPath of file >>> MarkdownRemark\",\"html\":\"<h1>Test UI components</h1>\\n<p>No Storybook tutorial would be complete without testing. Testing is essential to creating high quality UIs. In modular systems, miniscule tweaks can result in major regressions. So far we encountered three types of tests:</p>\\n<ul>\\n<li><strong>Visual tests</strong> rely on developers to manually look at a component to verify it for correctness. They help us sanity check a component’s appearance as we build.</li>\\n<li><strong>Snapshot tests</strong> with Storyshots capture a component’s rendered markup. They help us stay abreast of markup changes that cause rendering errors and warnings.</li>\\n<li><strong>Unit tests</strong> with Jest verify that the output of a component remains the same given an fixed input. They’re great for testing the functional qualities of a component.</li>\\n</ul>\\n<h2>“But does it look right?”</h2>\\n<p>Unfortunately, the aforementioned testing methods alone aren’t enough to prevent UI bugs. UIs are tricky to test because design is subjective and nuanced. Visual tests are too manual, snapshot tests trigger too many false positives when used for UI, and pixel-level unit tests are poor value. A complete Storybook testing strategy also includes visual regression tests.</p>\\n<h2>Visual regression testing for Storybook</h2>\\n<p>Visual regression tests are designed to catch changes in appearance. They work by capturing screenshots of every story and comparing them commit-to-commit to surface changes. This is perfect for verifying graphical elements like layout, color, size, and contrast.</p>\\n<video autoPlay muted playsInline loop style=\\\"width:480px; margin: 0 auto;\\\">\\n  <source\\n    src=\\\"/visual-regression-testing.mp4\\\"\\n    type=\\\"video/mp4\\\"\\n  />\\n</video>\\n<p>Storybook is a fantastic tool for visual regression testing because every story is essentially a test specification. Each time we write or update a story we get a spec for free!</p>\\n<p>There are a number of tools for visual regression testing. For professional teams we recommend <a href=\\\"https://www.chromaticqa.com/\\\"><strong>Chromatic</strong></a>, an addon made by Storybook maintainers that runs tests in the cloud.</p>\\n<h2>Setup visual regression testing</h2>\\n<p>Chromatic is a hassle-free Storybook addon for visual regression testing and review in the cloud. Since it’s a paid service (with a free trial), it may not be for everyone. However, Chromatic is an instructive example of a production visual testing workflow that we'll try out for free. Let’s have a look.</p>\\n<h3>Initiate Git</h3>\\n<p>First you want to setup Git for your project in the local directory. Chromatic uses Git history to keep track of your UI components.</p>\\n<pre><code class=\\\"language-bash\\\">$ git init\\n</code></pre>\\n<p>Next add files to the first commit.</p>\\n<pre><code class=\\\"language-bash\\\">$ git add .\\n</code></pre>\\n<p>Now commit the files.</p>\\n<pre><code class=\\\"language-bash\\\">$ git commit -m \\\"taskbox UI\\\"\\n</code></pre>\\n<h3>Get Chromatic</h3>\\n<p>Add the package as a dependency.</p>\\n<pre><code class=\\\"language-bash\\\">yarn add storybook-chromatic\\n</code></pre>\\n<p>Import Chromatic in your <code>.storybook/config.js</code> file.</p>\\n<pre><code class=\\\"language-javascript\\\">import { configure } from '@storybook/react';\\nimport 'storybook-chromatic/storybook-addon';\\n\\nimport '../src/index.css';\\n\\nconst req = require.context('../src/components', true, /\\\\.stories\\\\.js$/);\\n\\nfunction loadStories() {\\n  req.keys().forEach(filename => req(filename));\\n}\\n\\nconfigure(loadStories, module);\\n</code></pre>\\n<p>Then <a href=\\\"https://chromaticqa.com/start\\\">login to Chromatic</a> with your GitHub account (Chromatic only asks for lightweight permissions). Create a project with name \\\"taskbox\\\" and copy your unique <code>app-code</code>.</p>\\n<video autoPlay muted playsInline loop style=\\\"width:520px; margin: 0 auto;\\\">\\n  <source\\n    src=\\\"/chromatic-setup-learnstorybook.mp4\\\"\\n    type=\\\"video/mp4\\\"\\n  />\\n</video>\\n<p>Run the test command in the command line to setup visual regression tests for Storybook. Don't forget to add your unique app code in place of <code>&#x3C;app-code></code>.</p>\\n<pre><code class=\\\"language-bash\\\">./node_modules/.bin/chromatic test --storybook-addon --app-code=&#x3C;app-code> --do-not-start\\n</code></pre>\\n<div class=\\\"aside\\\">\\n<code>--do-not-start</code> is an option that tells Chromatic not to start Storybook. Use this if you already have Storybook running. If not omit <code>--do-not-start</code>.\\n</div>\\n<p>Once the first test is complete, we have test baselines for each story. In other words, screenshots of each story known to be “good”. Future changes to those stories will be compared to the baselines.</p>\\n<p><img src=\\\"/chromatic-baselines.png\\\" alt=\\\"Chromatic baselines\\\"></p>\\n<h2>Catch a UI change</h2>\\n<p>Visual regression testing relies on comparing images of the new rendered UI code to the baseline images. If a UI change is caught you get notified. See how it works by tweaking the background of the <code>Task</code> component:</p>\\n<p><img src=\\\"/chromatic-change-to-task-component.png\\\" alt=\\\"code change\\\"></p>\\n<p>This yields a new background color for the item.</p>\\n<p><img src=\\\"/chromatic-task-change.png\\\" alt=\\\"task background change\\\"></p>\\n<p>Use the test command from earlier to run another Chromatic test.</p>\\n<pre><code class=\\\"language-bash\\\">./node_modules/.bin/chromatic test --storybook-addon --app-code=&#x3C;app-code> --do-not-start\\n</code></pre>\\n<p>Follow the link to the web UI where you’ll see changes.</p>\\n<p><img src=\\\"/chromatic-catch-changes.png\\\" alt=\\\"UI changes in Chromatic\\\"></p>\\n<p>There are a lot of changes! The component hierarchy where <code>Task</code> is a child of <code>TaskList</code> and <code>Inbox</code> means one small tweak snowballs into major regressions. This circumstance is precisely why developers need visual regression testing in addition to other testing methods.</p>\\n<p><img src=\\\"/minor-major-regressions.gif\\\" alt=\\\"UI minor tweaks major regressions\\\"></p>\\n<h2>Review changes</h2>\\n<p>Visual regression testing ensures components dont change by accident. But it’s still up to you to determine whether changes are intentional or not.</p>\\n<p>If a change is intentional you need to update the baseline so that future tests are compared to the latest version of the story. If a change is unintentional it needs to be fixed.</p>\\n<video autoPlay muted playsInline loop style=\\\"width:480px; margin: 0 auto;\\\">\\n  <source\\n    src=\\\"/website-workflow-review-merge-optimized.mp4\\\"\\n    type=\\\"video/mp4\\\"\\n  />\\n</video>\\n<p>Since modern apps are constructed from components, it’s important that we test at the level of component. Doing so helps us pinpoint the root cause of a change, the component, instead of reacting to symptoms of a change, the screens and composite components.</p>\\n<h2>Merge changes</h2>\\n<p>When we’ve finished reviewing we’re ready to merge UI changes with confidence --knowing that updates won’t accidentally introduce bugs. If you like the new <code>papayawhip</code> background then accept the changes, if not revert to the previous state.</p>\\n<p><img src=\\\"/chromatic-review-finished.png\\\" alt=\\\"Changes ready to be merged\\\"></p>\\n<p>Storybook helps you <strong>build</strong> components; testing helps you <strong>maintain</strong> them. The four types of UI testing are covered in this tutorial are visual, snapshot, unit, and visual regression testing. You can automate the last three by adding them to your CI script. This helps you ship components without worrying about stowaway bugs. The whole workflow is illustrated below.</p>\\n<p><img src=\\\"/cdd-review-workflow.png\\\" alt=\\\"Visual regression testing workflow\\\"></p>\",\"excerpt\":\"Test UI components No Storybook tutorial would be complete without testing. Testing is essential to creating high quality UIs. In modular systems, miniscule tweaks can result in major regressions. So far we encountered three types of tests: Visual…\",\"frontmatter\":{\"path\":null,\"title\":\"Testing\"}}},{\"node\":{\"id\":\"/Users/luz/code/js/binstd.github.io/markdown/docs/es/composite-component.md absPath of file >>> MarkdownRemark\",\"html\":\"<h1>Ensamblar un componente compuesto</h1>\\n<p>En el último capítulo construimos nuestro primer componente; este capítulo extiende lo que aprendimos para construir TaskList, una lista de Tareas. Combinemos componentes en conjunto y veamos qué sucede cuando se añade más complejidad.</p>\\n<h2>Lista de Tareas</h2>\\n<p>Taskbox enfatiza las tareas ancladas colocándolas por encima de las tareas predeterminadas. Esto produce dos variaciones de <code>TaskList</code> para las que necesita crear historias: ítems por defecto e ítems por defecto y anclados.</p>\\n<p><img src=\\\"/tasklist-states-1.png\\\" alt=\\\"default and pinned tasks\\\"></p>\\n<p>Dado que los datos de <code>Tareas</code> pueden enviarse asincrónicamente, <strong>también</strong> necesitamos un estado de cargando para renderizar en ausencia de alguna conexión. Además, también se requiere un estado vacío para cuando no hay tareas.</p>\\n<p><img src=\\\"/tasklist-states-2.png\\\" alt=\\\"empty and loading tasks\\\"></p>\\n<h2>Empezar la configuración</h2>\\n<p>Un componente compuesto no es muy diferente de los componentes básicos que contiene. Crea un componente <code>TaskList</code> y un archivo de historia que lo acompañe: <code>src/components/TaskList.js</code> y <code>src/components/TaskList.stories.js</code>.</p>\\n<p>Comienza con una implementación aproximada de la <code>TaskList</code>. Necesitarás importar el componente <code>Tareas</code> del capítulo anterior y pasarle los atributos y acciones como entrada.</p>\\n<pre><code class=\\\"language-javascript\\\">import React from 'react';\\n\\nimport Task from './Task';\\n\\nfunction TaskList({ loading, tasks, onPinTask, onArchiveTask }) {\\n  const events = {\\n    onPinTask,\\n    onArchiveTask,\\n  };\\n\\n  if (loading) {\\n    return &#x3C;div className=\\\"list-items\\\">loading&#x3C;/div>;\\n  }\\n\\n  if (tasks.length === 0) {\\n    return &#x3C;div className=\\\"list-items\\\">empty&#x3C;/div>;\\n  }\\n\\n  return (\\n    &#x3C;div className=\\\"list-items\\\">\\n      {tasks.map(task => &#x3C;Task key={task.id} task={task} {...events} />)}\\n    &#x3C;/div>\\n  );\\n}\\n\\nexport default TaskList;\\n</code></pre>\\n<p>A continuación, crea los estados de prueba de <code>Tasklist</code> en el archivo de historia.</p>\\n<pre><code class=\\\"language-javascript\\\">import React from 'react';\\nimport { storiesOf } from '@storybook/react';\\n\\nimport TaskList from './TaskList';\\nimport { createTask, actions } from './Task.stories';\\n\\nexport const defaultTasks = [\\n  createTask({ state: 'TASK_INBOX' }),\\n  createTask({ state: 'TASK_INBOX' }),\\n  createTask({ state: 'TASK_INBOX' }),\\n  createTask({ state: 'TASK_INBOX' }),\\n  createTask({ state: 'TASK_INBOX' }),\\n  createTask({ state: 'TASK_INBOX' }),\\n];\\n\\nexport const withPinnedTasks = [\\n  createTask({ title: 'Task 1', state: 'TASK_INBOX' }),\\n  createTask({ title: 'Task 2', state: 'TASK_INBOX' }),\\n  createTask({ title: 'Task 3', state: 'TASK_INBOX' }),\\n  createTask({ title: 'Task 4', state: 'TASK_INBOX' }),\\n  createTask({ title: 'Task 5', state: 'TASK_INBOX' }),\\n  createTask({ title: 'Task 6 (pinned)', state: 'TASK_PINNED' }),\\n];\\n\\nstoriesOf('TaskList', module)\\n  .addDecorator(story => &#x3C;div style={{ padding: '3rem' }}>{story()}&#x3C;/div>)\\n  .add('default', () => &#x3C;TaskList tasks={defaultTasks} {...actions} />)\\n  .add('withPinnedTasks', () => &#x3C;TaskList tasks={withPinnedTasks} {...actions} />)\\n  .add('loading', () => &#x3C;TaskList loading tasks={[]} {...actions} />)\\n  .add('empty', () => &#x3C;TaskList tasks={[]} {...actions} />);\\n</code></pre>\\n<p><code>addDecorator()</code> nos permite añadir algún \\\"contexto\\\" al renderizado de cada tarea. En este caso añadimos relleno alrededor de la lista para que sea más fácil de verificar visualmente.</p>\\n<div class=\\\"aside\\\">\\nLos <a href=\\\"https://storybook.js.org/addons/introduction/#1-decorators\\\"><b>Decoradores</b></a> son una forma de proporcionar envoltorios arbitrarios a las historias. En este caso estamos usando un decorador para añadir estilo. También se pueden utilizar para envolver historias en \\\"proveedores\\\", es decir, componentes de la librebría que establecen el contexto de React.\\n</div>\\n<p><code>createTask()</code> es una función de ayuda que genera la forma de una Tarea que creamos y exportamos desde el archivo <code>Task.stories.js</code>. De manera similar, las <code>acciones</code> exportadas de <code>Task.stories.js</code> definieron las acciones (comunmente llamadas mockeadas) que espera un componente <code>Task</code>, el cual también necesita la <code>TaskList</code>.</p>\\n<p>Ahora revise Storybook para ver las nuevas historias de la lista de tareas.</p>\\n<video autoPlay muted playsInline loop>\\n  <source\\n    src=\\\"/inprogress-tasklist-states.mp4\\\"\\n    type=\\\"video/mp4\\\"\\n  />\\n</video>\\n<h2>Construir los estados</h2>\\n<p>Nuestro componente sigue siendo muy rudimentario, pero ahora tenemos una idea de las historias en las que trabajaremos. Podrías estar pensando que el envoltorio de <code>.list-items</code> es demasiado simplista. Tienes razón, en la mayoría de los casos no crearíamos un nuevo componente sólo para añadir un envoltorio. Pero la <strong>complejidad real</strong> del componente <code>TaskList</code> se revela en los casos extremos <code>withPinnedTasks</code>, <code>loading</code>, y <code>empty</code>.</p>\\n<pre><code class=\\\"language-javascript\\\">import React from 'react';\\n\\nimport Task from './Task';\\n\\nfunction TaskList({ loading, tasks, onPinTask, onArchiveTask }) {\\n  const events = {\\n    onPinTask,\\n    onArchiveTask,\\n  };\\n\\n  const LoadingRow = (\\n    &#x3C;div className=\\\"loading-item\\\">\\n      &#x3C;span className=\\\"glow-checkbox\\\" />\\n      &#x3C;span className=\\\"glow-text\\\">\\n        &#x3C;span>Loading&#x3C;/span> &#x3C;span>cool&#x3C;/span> &#x3C;span>state&#x3C;/span>\\n      &#x3C;/span>\\n    &#x3C;/div>\\n  );\\n\\n  if (loading) {\\n    return (\\n      &#x3C;div className=\\\"list-items\\\">\\n        {LoadingRow}\\n        {LoadingRow}\\n        {LoadingRow}\\n        {LoadingRow}\\n        {LoadingRow}\\n        {LoadingRow}\\n      &#x3C;/div>\\n    );\\n  }\\n\\n  if (tasks.length === 0) {\\n    return (\\n      &#x3C;div className=\\\"list-items\\\">\\n        &#x3C;div className=\\\"wrapper-message\\\">\\n          &#x3C;span className=\\\"icon-check\\\" />\\n          &#x3C;div className=\\\"title-message\\\">You have no tasks&#x3C;/div>\\n          &#x3C;div className=\\\"subtitle-message\\\">Sit back and relax&#x3C;/div>\\n        &#x3C;/div>\\n      &#x3C;/div>\\n    );\\n  }\\n\\n  const tasksInOrder = [\\n    ...tasks.filter(t => t.state === 'TASK_PINNED'),\\n    ...tasks.filter(t => t.state !== 'TASK_PINNED'),\\n  ];\\n\\n  return (\\n    &#x3C;div className=\\\"list-items\\\">\\n      {tasksInOrder.map(task => &#x3C;Task key={task.id} task={task} {...events} />)}\\n    &#x3C;/div>\\n  );\\n}\\n\\nexport default TaskList;\\n</code></pre>\\n<p>El etiquetado añadido da como resultado la siguiente interfaz de usuario:</p>\\n<video autoPlay muted playsInline loop>\\n  <source\\n    src=\\\"/finished-tasklist-states.mp4\\\"\\n    type=\\\"video/mp4\\\"\\n  />\\n</video>\\n<p>Observa la posición del elemento anclado en la lista. Queremos que el elemento anclado se muestre en la parte superior de la lista para que sea prioritario para nuestros usuarios.</p>\\n<h2>Requisitos de data y props</h2>\\n<p>A medida que el componente crece, también lo hacen los parámetros de entrada requeridos de <code>TaskList</code>. Define las props requeridas de <code>TaskList</code>. Debido a que <code>Task</code> es un componente hijo, asegúrate de proporcionar los datos en la forma correcta para renderizarlo. Para ahorrar tiempo y dolores de cabeza, reutiliza los propTypes que definiste en <code>Tareas</code> anteriormente.</p>\\n<pre><code class=\\\"language-javascript\\\">import React from 'react';\\nimport PropTypes from 'prop-types';\\n\\nfunction TaskList() {\\n  ...\\n}\\n\\n\\nTaskList.propTypes = {\\n  loading: PropTypes.bool,\\n  tasks: PropTypes.arrayOf(Task.propTypes.task).isRequired,\\n  onPinTask: PropTypes.func.isRequired,\\n  onArchiveTask: PropTypes.func.isRequired,\\n};\\n\\nTaskList.defaultProps = {\\n  loading: false,\\n};\\n\\nexport default TaskList;\\n</code></pre>\\n<h2>Pruebas automatizadas</h2>\\n<p>En el capítulo anterior aprendimos a capturar historias de prueba utilizando Storyshots. Con el componente <code>Task</code> no había mucha complejidad para probar más allá de que se renderice correctamente. Dado que <code>TaskList</code> añade otra capa de complejidad, queremos verificar que ciertas entradas produzcan ciertas salidas de una manera adecuada con pruebas automáticas. Para hacer esto crearemos test unitarios utilizando <a href=\\\"https://facebook.github.io/jest/\\\">Jest</a> junto con un renderizador de prueba como <a href=\\\"http://airbnb.io/enzyme/\\\">Enzyme</a>.</p>\\n<p><img src=\\\"/logo-jest.png\\\" alt=\\\"Jest logo\\\"></p>\\n<h3>Test unitarios con Jest</h3>\\n<p>Las historias de Storybook combinadas con pruebas visuales manuales y pruebas de instantáneas (ver arriba) ayudan mucho a evitar errores de interfaz de usuario. Si las historias cubren una amplia variedad de casos de uso de los componentes, y utilizamos herramientas que aseguran que un humano compruebe cualquier cambio en la historia, los errores son mucho menos probables.</p>\\n<p>Sin embargo, a veces el diablo está en los detalles. Se necesita un framework de pruebas que sea explícito sobre esos detalles. Lo que nos lleva a hacer pruebas unitarias.</p>\\n<p>En nuestro caso, queremos que nuestra <code>TaskList</code> muestre cualquier tarea anclada <strong>antes de</strong> las tareas no ancladas que sean pasadas en la prop <code>tasks</code>. Aunque tenemos una historia (<code>withPinnedTasks</code>) para probar este escenario exacto; puede ser ambiguo para un revisor humano que si el componente <strong>no</strong> ordena las tareas de esta manera, es un error. Ciertamente no gritará <strong>\\\"¡Mal!\\\"</strong> para el ojo casual.</p>\\n<p>Por lo tanto, para evitar este problema, podemos usar Jest para renderizar la historia en el DOM y ejecutar algún código de consulta del DOM para verificar las características salientes del resultado.</p>\\n<p>Crea un archivo de prueba llamado <code>Task.test.js</code>. Aquí vamos a construir nuestras pruebas que hacen afirmaciones acerca del resultado.</p>\\n<pre><code class=\\\"language-javascript\\\">import React from 'react';\\nimport ReactDOM from 'react-dom';\\nimport TaskList from './TaskList';\\nimport { withPinnedTasks } from './TaskList.stories';\\n\\nit('renders pinned tasks at the start of the list', () => {\\n  const div = document.createElement('div');\\n  const events = { onPinTask: jest.fn(), onArchiveTask: jest.fn() };\\n  ReactDOM.render(&#x3C;TaskList tasks={withPinnedTasks} {...events} />, div);\\n\\n  // Esperamos que la tarea titulada \\\"Tarea 6 (anclada)\\\" se ejecute primero, no al final.\\n  const lastTaskInput = div.querySelector('.list-item:nth-child(1) input[value=\\\"Task 6 (pinned)\\\"]');\\n  expect(lastTaskInput).not.toBe(null);\\n\\n  ReactDOM.unmountComponentAtNode(div);\\n});\\n</code></pre>\\n<p><img src=\\\"/tasklist-testrunner.png\\\" alt=\\\"TaskList test runner\\\"></p>\\n<p>Nota que hemos sido capaces de reutilizar la lista de tareas <code>withPinnedTasks</code> tanto en la prueba de la historia como en el test unitario; de esta manera podemos continuar aprovechando un recurso existente (los ejemplos que representan configuraciones interesantes de un componente) de más y más maneras.</p>\\n<p>Note también que esta prueba es bastante frágil. Es posible que a medida que el proyecto madure y que la implementación exacta de la <code>Tarea</code> cambie --quizás usando un nombre de clase diferente o un \\\"área de texto\\\" en lugar de un \\\"input\\\" en el etiquetado-- la prueba falle y necesite ser actualizada. Esto no es necesariamente un problema, sino más bien una indicación de que hay que ser bastante cuidadoso usando pruebas unitarias para la UI. No son fáciles de mantener. En su lugar, confía en las pruebas visuales, de instantáneas y de regresión visual (mira el <a href=\\\"/test/\\\">capitulo sobre las pruebas</a>) siempre que te sea posible.</p>\",\"excerpt\":\"Ensamblar un componente compuesto En el último capítulo construimos nuestro primer componente; este capítulo extiende lo que aprendimos para construir TaskList, una lista de Tareas. Combinemos componentes en conjunto y veamos qué sucede cuando se…\",\"frontmatter\":{\"path\":null,\"title\":\"Ensamblar un componente compuesto\"}}},{\"node\":{\"id\":\"/Users/luz/code/js/binstd.github.io/markdown/docs/es/conclusion.md absPath of file >>> MarkdownRemark\",\"html\":\"<h1>Conclusion</h1>\\n<p>Felicitaciones! Creaste tu primer interfaz de usuario en Storybook. En el camino, aprendiste a construir, componer, probar e implementar componentes de interfaz de usuario. Si lo has estado siguiendo, tu repositorio y Storybook desplegado debería verse así:</p>\\n<p><a href=\\\"https://github.com/hichroma/learnstorybook-code\\\">📕 <strong>Repositorio de GitHub: hichroma/learnstorybook-code</strong></a>\\n<br/>\\n<a href=\\\"https://clever-banach-415c03.netlify.com/\\\">🌎 <strong>Storybook Desplegado</strong></a></p>\\n<p>Storybook es una poderosa herramienta para React, Vue y Angular. Cuenta con una próspera comunidad de desarrolladores y una gran cantidad de complementos. Esta introducción nos lleva superficialmente a lo que es posible. Estamos seguros de que una vez que adoptes Storybook, quedarás impresionado por lo productivo que es crear interfaces de usuario duraderas.</p>\\n<h2>Aprende más</h2>\\n<p>Quieres bucear más profundo? Aquí algunos recursos útiles:</p>\\n<ul>\\n<li>\\n<p><a href=\\\"https://storybook.js.org/basics/introduction/\\\"><strong>Documentación oficial de Storybook</strong></a> tiene la documentación del API, links comunitarios y una galería de complementos.</p>\\n</li>\\n<li>\\n<p><strong>El delicioso flujo de trabajo de Storybook</strong> (Próximamente!) destaca las mejores prácticas del flujo de trabajo utilizado por equipos de alta velocidad en Squarespace, Major League Soccer y Apollo GraphQL.</p>\\n</li>\\n<li>\\n<p><a href=\\\"https://www.chromaticqa.com/book/visual-testing-handbook\\\"><strong>Manual de pruebas visuales</strong></a> se sumerge profundamente en el uso de Storybook para probar componentes visuales. Libro electrónico gratuito de 31 páginas.</p>\\n</li>\\n</ul>\\n<h2>Quién hizo LearnStorybook.com?</h2>\\n<p>El texto, código, y producción fueron contribuidos por <a href=\\\"http://blog.hichroma.com/\\\">Chroma</a>. Los tutoriales fueron inspirados por la popular <a href=\\\"https://blog.hichroma.com/graphql-react-tutorial-part-1-6-d0691af25858\\\">serie de tutoriales GraphQL + React</a> de Chroma.</p>\\n<p>Quieres más tutoriales y artículos como este? Regístratate a la lista de correo de Chroma.</p>\\n<iframe style=\\\"height:400px;width:100%;max-width:800px;margin:30px auto;\\\" src=\\\"https://upscri.be/bface0?as_embed\\\"></iframe>\",\"excerpt\":\"Conclusion Felicitaciones! Creaste tu primer interfaz de usuario en Storybook. En el camino, aprendiste a construir, componer, probar e implementar componentes de interfaz de usuario. Si lo has estado siguiendo, tu repositorio y Storybook desplegado…\",\"frontmatter\":{\"path\":null,\"title\":\"Conclusion\"}}},{\"node\":{\"id\":\"/Users/luz/code/js/binstd.github.io/markdown/docs/es/contribute.md absPath of file >>> MarkdownRemark\",\"html\":\"<h1>Contribuir</h1>\\n<p>Contribuciones para aprender Storybook son bienvenidas! Si se trata de algo pequeño como gramática o puntuación, abre un pull request. Si es un cambio más grande, <a href=\\\"https://github.com/hichroma/learnstorybook.com/issues\\\">agrega un issue</a> para discutirlo.</p>\\n<h2>Ediciones de Vue y Angular</h2>\\n<p>Estamos buscando ayuda para actualizar nuestro código de ejemplo de React/Redux a Vue y Angular. Comenta en el issue sobre <a href=\\\"https://github.com/hichroma/learnstorybook.com/issues/1\\\">Vue</a> o sobre <a href=\\\"https://github.com/hichroma/learnstorybook.com/issues/2\\\">Angular</a>.</p>\\n<p><img src=\\\"/logos-angular-vue.png\\\" alt=\\\"Vue and Angular contributors wanted\\\"></p>\\n<h2>Traducciones</h2>\\n<p>Nuestro objetivo es hacer que Storybook sea accesible a todas las personas. Ayuda a traducir este tutorial a otros idiomas. Estamos especialmente abiertos a traducciones al chino y al japonés. Comenta en <a href=\\\"https://github.com/hichroma/learnstorybook.com/issues/3\\\">este issue</a> si deseas ayudar.</p>\",\"excerpt\":\"Contribuir Contribuciones para aprender Storybook son bienvenidas! Si se trata de algo pequeño como gramática o puntuación, abre un pull request. Si es un cambio más grande,  agrega un issue  para discutirlo. Ediciones de Vue y Angular Estamos…\",\"frontmatter\":{\"path\":null,\"title\":\"Contribuir\"}}},{\"node\":{\"id\":\"/Users/luz/code/js/binstd.github.io/markdown/docs/es/data.md absPath of file >>> MarkdownRemark\",\"html\":\"<h1>Introducir datos</h1>\\n<p>Hasta ahora hemos creado componentes aislados sin estado, muy útiles para Storybook, pero finalmente no son útiles hasta que les proporcionemos algunos datos en nuestra aplicación.</p>\\n<p>Este tutorial no se centra en los detalles de la construcción de una aplicación, por lo que no profundizaremos en esos detalles aquí. Pero, nos tomaremos un momento para observar un patrón común para introducir datos con componentes contenedores.</p>\\n<h2>Componentes contenedores</h2>\\n<p>Nuestro componente <code>TaskList</code> como lo hemos escrito es de “presentación” (ver <a href=\\\"https://medium.com/@dan_abramov/smart-and-dumb-components-7ca2f9a7c7d0\\\">artículo al respecto</a>), en el sentido que no se comunica con nada externo a su implementación. Para poder pasarle datos, necesitaremos un \\\"contenedor\\\".</p>\\n<p>Este ejemplo utiliza <a href=\\\"https://redux.js.org/\\\">Redux</a>, la librería mas popular de React para almacenar datos, que básicamente nos permite crear un modelo simple de datos para la aplicación. De todos modos, el patrón que utilizaremos también se aplica a otras librerías de manejo de datos como <a href=\\\"https://www.apollographql.com/client/\\\">Apollo</a> y <a href=\\\"https://mobx.js.org/\\\">MobX</a>.</p>\\n<p>Primero construiremos un simple store Redux que responde a acciones que cambian el estado de una tarea, en un archivo llamado <code>lib/redux.js</code>, (intencionalmente lo mantendremos simple):</p>\\n<pre><code class=\\\"language-javascript\\\">// Una implementación simple de los store/actions/reducer de Redux.\\n// Una verdadera aplicación sería más compleja y se dividiría en diferentes archivos.\\nimport { createStore } from 'redux';\\n\\n// Las acciones son los \\\"nombres\\\" de los cambios que pueden ocurrir en el store.\\nexport const actions = {\\n  ARCHIVE_TASK: 'ARCHIVE_TASK',\\n  PIN_TASK: 'PIN_TASK',\\n};\\n\\n// Los creadores de acciones son la forma en que se agrupan las acciones con los datos necesarios para ejecutarlas.\\nexport const archiveTask = id => ({ type: actions.ARCHIVE_TASK, id });\\nexport const pinTask = id => ({ type: actions.PIN_TASK, id });\\n\\n// Todos nuestros reducers simplemente cambian el estado de una sola tarea.\\nfunction taskStateReducer(taskState) {\\n  return (state, action) => {\\n    return {\\n      ...state,\\n      tasks: state.tasks.map(\\n        task => (task.id === action.id ? { ...task, state: taskState } : task)\\n      ),\\n    };\\n  };\\n}\\n\\n// El reducer describe como los contenidos del store cambian por cada acción.\\nexport const reducer = (state, action) => {\\n  switch (action.type) {\\n    case actions.ARCHIVE_TASK:\\n      return taskStateReducer('TASK_ARCHIVED')(state, action);\\n    case actions.PIN_TASK:\\n      return taskStateReducer('TASK_PINNED')(state, action);\\n    default:\\n      return state;\\n  }\\n};\\n\\n// El estado inicial de nuestro store cuando la app carga.\\n// Usualmente obtendrías esto de un servidor.\\nconst defaultTasks = [\\n  { id: '1', title: 'Something', state: 'TASK_INBOX' },\\n  { id: '2', title: 'Something more', state: 'TASK_INBOX' },\\n  { id: '3', title: 'Something else', state: 'TASK_INBOX' },\\n  { id: '4', title: 'Something again', state: 'TASK_INBOX' },\\n];\\n\\n// Exportamos el store de redux construido.\\nexport default createStore(reducer, { tasks: defaultTasks });\\n</code></pre>\\n<p>Luego actualizaremos lo exportado por defecto en el componente <code>TaskList</code> para conectarlo al Store de Redux y renderizar las tareas en las que estamos interesados.</p>\\n<pre><code class=\\\"language-javascript\\\">import React from 'react';\\nimport PropTypes from 'prop-types';\\n\\nimport Task from './Task';\\nimport { connect } from 'react-redux';\\nimport { archiveTask, pinTask, snoozeTask } from '../lib/redux';\\n\\nexport function PureTaskList({ tasks, onPinTask, onArchiveTask }) {\\n  /* antigua implementación de TaskList */\\n}\\n\\nPureTaskList.propTypes = {\\n  loading: PropTypes.bool,\\n  tasks: PropTypes.arrayOf(Task.propTypes.task).isRequired,\\n  onPinTask: PropTypes.func.isRequired,\\n  onArchiveTask: PropTypes.func.isRequired,\\n};\\n\\nPureTaskList.defaultProps = {\\n  loading: false,\\n};\\n\\nexport default connect(\\n  ({ tasks }) => ({\\n    tasks: tasks.filter(t => t.state === 'TASK_INBOX' || t.state === 'TASK_PINNED'),\\n  }),\\n  dispatch => ({\\n    onArchiveTask: id => dispatch(archiveTask(id)),\\n    onPinTask: id => dispatch(pinTask(id)),\\n  })\\n)(PureTaskList);\\n</code></pre>\\n<p>En esta etapa, nuestras pruebas de Storybook habrán dejado de funcionar, ya que la <code>TaskList</code> ahora es un contenedor y ya no espera ninguna de las props pasadas como parámetros, sino que se conecta a la store y establece las props en el componente <code>PureTaskList</code> que envuelve.</p>\\n<p>Sin embargo, podemos resolver este problema fácilmente renderizando <code>PureTaskList</code> --el componente de presentación-- en nuestras historias de Storybook:</p>\\n<pre><code class=\\\"language-javascript\\\">import React from 'react';\\nimport { storiesOf } from '@storybook/react';\\n\\nimport { PureTaskList } from './TaskList';\\nimport { createTask, actions } from './Task.stories';\\n\\nexport const defaultTasks = [\\n  createTask({ state: 'TASK_INBOX' }),\\n  createTask({ state: 'TASK_INBOX' }),\\n  createTask({ state: 'TASK_INBOX' }),\\n  createTask({ state: 'TASK_INBOX' }),\\n  createTask({ state: 'TASK_INBOX' }),\\n  createTask({ state: 'TASK_INBOX' }),\\n];\\n\\nexport const withPinnedTasks = [\\n  createTask({ title: 'Task 1', state: 'TASK_INBOX' }),\\n  createTask({ title: 'Task 2', state: 'TASK_INBOX' }),\\n  createTask({ title: 'Task 3', state: 'TASK_INBOX' }),\\n  createTask({ title: 'Task 4', state: 'TASK_INBOX' }),\\n  createTask({ title: 'Task 5', state: 'TASK_INBOX' }),\\n  createTask({ title: 'Task 6 (pinned)', state: 'TASK_PINNED' }),\\n];\\n\\nstoriesOf('TaskList', module)\\n  .addDecorator(story => &#x3C;div style={{ padding: '3rem' }}>{story()}&#x3C;/div>)\\n  .add('default', () => &#x3C;PureTaskList tasks={defaultTasks} {...actions} />)\\n  .add('withPinnedTasks', () => &#x3C;PureTaskList tasks={withPinnedTasks} {...actions} />)\\n  .add('loading', () => &#x3C;PureTaskList loading tasks={[]} {...actions} />)\\n  .add('empty', () => &#x3C;PureTaskList tasks={[]} {...actions} />);\\n</code></pre>\\n<video autoPlay muted playsInline loop>\\n  <source\\n    src=\\\"/finished-tasklist-states.mp4\\\"\\n    type=\\\"video/mp4\\\"\\n  />\\n</video>\",\"excerpt\":\"Introducir datos Hasta ahora hemos creado componentes aislados sin estado, muy útiles para Storybook, pero finalmente no son útiles hasta que les proporcionemos algunos datos en nuestra aplicación. Este tutorial no se centra en los detalles de la…\",\"frontmatter\":{\"path\":null,\"title\":\"Introducir datos\"}}},{\"node\":{\"id\":\"/Users/luz/code/js/binstd.github.io/markdown/docs/es/deploy.md absPath of file >>> MarkdownRemark\",\"html\":\"<h1>Desplegar Storybook</h1>\\n<p>En este tutorial hemos ejecutado Storybook en nuestra máquina de desarrollo. También se puede compartir ese Storybook con el equipo, especialmente con los miembros no técnicos. Afortunadamente, es fácil implementar Storybook en línea.</p>\\n<div class=\\\"aside\\\">\\n<strong>¿Hiciste los test con Chromatic antes?</strong>\\n<br/>\\n🎉 Sus historias ya están desplegadas! Chromatic indexa de forma segura sus historias en línea y las rastrea a través de ramas y commits. Salta este capítulo y ve a la <a href=\\\"/conclusion\\\">conclusión</a>.\\n</div>\\n<h2>Exportando como una app estática</h2>\\n<p>Para desplegar Storybook primero necesitamos exportarlo como una aplicación web estática. Esta funcionalidad ya está incorporada en Storybook, sólo necesitamos activarla añadiendo un script al <code>package.json</code>.</p>\\n<pre><code class=\\\"language-javascript\\\">{\\n  \\\"scripts\\\": {\\n    \\\"storybook\\\": \\\"build-storybook -c .storybook -o .storybook-static\\\"\\n  }\\n}\\n</code></pre>\\n<p>Ahora, cuando ejecutes Storybook a través de <code>npm run storybook</code>, obtendrás un Storybook estático en el directorio <code>storybook-static</code>.</p>\\n<h2>Despliegue continuo</h2>\\n<p>Queremos compartir la última versión de los componentes cada vez que hagamos push del código. Para ello necesitamos desplegar de forma continua Storybook. Confiaremos en GitHub y Netlify para desplegar nuestro sitio estático. Estaremos usando el plan gratuito de Netlify.</p>\\n<h3>GitHub</h3>\\n<p>Primero debes configurar Git para tu proyecto en el directorio local. Si estás siguiendo el capítulo anterior sobre testing, salta a la creación de un repositorio en GitHub.</p>\\n<pre><code class=\\\"language-bash\\\">$ git init\\n</code></pre>\\n<p>Agrega archivos al primer commit. </p>\\n<pre><code class=\\\"language-bash\\\">$ git add .\\n</code></pre>\\n<p>Ahora haz commit de los archivos.</p>\\n<pre><code class=\\\"language-bash\\\">$ git commit -m \\\"taskbox UI\\\"\\n</code></pre>\\n<p>Ve a Github y configura un repositorio <a href=\\\"https://github.com/new\\\">aquí</a>. Nombra tu repo “taskbox”.</p>\\n<p><img src=\\\"/github-create-taskbox.png\\\" alt=\\\"GitHub setup\\\"></p>\\n<p>En la nueva configuración del repositorio copia la URL de origen del repositorio y añádelo a tu proyecto git con este comando:</p>\\n<pre><code class=\\\"language-bash\\\">$ git remote add origin https://github.com/&#x3C;your username>/taskbox.git\\n</code></pre>\\n<p>Finalmente haz push al repo en GitHub.</p>\\n<pre><code class=\\\"language-bash\\\">$ git push -u origin master\\n</code></pre>\\n<h3>Netlify</h3>\\n<p>Netlify tiene incorporado un servicio de despliegue continuo que nos permitirá desplegar Storybook sin necesidad de configurar nuestro propio CI.</p>\\n<div class=\\\"aside\\\">\\nSi usas CI en tu empresa, añade un script de implementación a tu configuración que suba <code>storybook-static</code> a un servicio de alojamiento de estáticos como S3.\\n</div>\\n<p><a href=\\\"https://app.netlify.com/start\\\">Crea una cuenta en Netlify</a> y da click en “crear sitio”.</p>\\n<p><img src=\\\"/netlify-create-site.png\\\" alt=\\\"Crear sitio en Netlify\\\"></p>\\n<p>A continuación, haz clic en el botón de GitHub para conectar Netlify a GitHub. Esto le permite acceder a nuestro repositorio remoto Taskbox.</p>\\n<p>Ahora selecciona el repo de taskbox de GitHub de la lista de opciones.</p>\\n<p><img src=\\\"/netlify-account-picker.png\\\" alt=\\\"Conectar un repositorio en Netlify\\\"></p>\\n<p>Configura Netlify resaltando el comando build que se ejecutará en tu CI y el directorio en el que se enviará el sitio estático. Para la rama elegir <code>master</code>. El directorio es <code>storybook-static</code>. Ejecuta el comando <code>yarn build-storybook</code>.</p>\\n<p><img src=\\\"/netlify-settings.png\\\" alt=\\\"Ajustes Netlify\\\"></p>\\n<p>Ahora envía el formulario para construir e implementar el código en la rama <code>master</code> del taskbox.</p>\\n<p>Cuando esto termine veremos un mensaje de confirmación en Netlify con un enlace al Storybook de Taskbox online. Si lo estás siguiendo, tu Storybook desplegado debería estar en línea <a href=\\\"https://clever-banach-415c03.netlify.com/\\\">como este</a>.</p>\\n<p><img src=\\\"/netlify-storybook-deploy.png\\\" alt=\\\"Despliegue de Netlify Storybook\\\"></p>\\n<p>Terminamos de configurar el despliegue continuo de tu Storybook! Ahora podemos compartir nuestras historias con nuestros compañeros de equipo a través de un enlace.</p>\\n<p>Esto es útil para la revisión visual como parte del proceso de desarrollo de aplicaciones estándar o simplemente para mostrar nuestro trabajo💅.</p>\",\"excerpt\":\"Desplegar Storybook En este tutorial hemos ejecutado Storybook en nuestra máquina de desarrollo. También se puede compartir ese Storybook con el equipo, especialmente con los miembros no técnicos. Afortunadamente, es fácil implementar Storybook en…\",\"frontmatter\":{\"path\":null,\"title\":\"Desplegar Storybook\"}}},{\"node\":{\"id\":\"/Users/luz/code/js/binstd.github.io/markdown/docs/es/get-started.md absPath of file >>> MarkdownRemark\",\"html\":\"<h1>Empezando</h1>\\n<p>Storybook se ejecuta junto con tu aplicación en modo desarrollo. Te ayuda a crear componentes de UI aislados de la lógica y el contexto de tu aplicación. Esta edición de Aprende Storybook es para React; otras ediciones para Vue y Angular vendrán pronto.</p>\\n<p><img src=\\\"/storybook-relationship.jpg\\\" alt=\\\"Storybook and your app\\\"></p>\\n<h2>Configurando React Storybook</h2>\\n<p>Necesitaremos seguir algunos pasos para configurar el proceso de build de nuestro entorno. Para iniciar, vamos a usar <a href=\\\"https://github.com/facebook/create-react-app\\\">Create React App</a> (CRA) para configurar nuestro sistema de build, y añadiremos <a href=\\\"https://storybook.js.org/\\\">Storybook</a> y <a href=\\\"https://facebook.github.io/jest/\\\">Jest</a> para testear nuestra aplicación creada. Vamos a ejecutar los siguientes comandos:</p>\\n<pre><code class=\\\"language-bash\\\"># Crea nuestra aplicación:\\nnpx create-react-app taskbox\\ncd taskbox\\n\\n# Añade Storybook:\\nnpx -p @storybook/cli getstorybook\\n</code></pre>\\n<p>Podemos comprobar rápidamente que los distintos entornos de nuestra aplicación funcionan correctamente:</p>\\n<pre><code class=\\\"language-bash\\\"># Corre el test de prueba (Jest) en una terminal:\\nyarn test\\n\\n# Inicia el explorador de componentes en el puerto 9009:\\nyarn run storybook\\n\\n# Ejecuta el frontend de la aplicación en el puerto 3000:\\nyarn start\\n</code></pre>\\n<p>Nuestras tres modalidades del frontend de la aplicación: test automatizado (Jest), desarrollo de componentes (Storybook) y la propia aplicación.</p>\\n<p><img src=\\\"/app-three-modalities.png\\\" alt=\\\"3 modalidades\\\"></p>\\n<p>Dependiendo de en qué parte de la aplicación estés trabajando, es posible que quieras ejecutar uno o más de estos simultáneamente. Dado que nuestro objetivo actual es crear un único componente de UI, seguiremos ejecutando Storybook.</p>\\n<h2>Reusa CSS</h2>\\n<p>Taskbox reutiliza elementos de diseño de la aplicación de ejemplo de este <a href=\\\"https://blog.hichroma.com/graphql-react-tutorial-part-1-6-d0691af25858\\\">Tutorial de GraphQL y React</a>, por lo que no necesitaremos escribir CSS en este tutorial. Simplemente compilaremos nuestros archivos LESS en un único archivo CSS y lo incluiremos en nuestra aplicación. Copia y pega <a href=\\\"https://github.com/hichroma/learnstorybook-code/blob/master/src/index.css\\\">este CSS compilado</a> dentro del archivo src/index.css según la convención de CRA.</p>\\n<p><img src=\\\"/ss-browserchrome-taskbox-learnstorybook.png\\\" alt=\\\"Buzón de tareas UI\\\"></p>\\n<div class=\\\"aside\\\">\\nSi deseas modificar los estilos, los archivos fuente de CSS en formato LESS son proporcionados en el mismo repositorio de GitHub.</div>\\n<h2>Añade recursos</h2>\\n<p>También necesitamos añadir la fuente y el icono de este <a href=\\\"https://github.com/hichroma/learnstorybook-code/tree/master/public\\\">directorio</a> a la carpeta <code>public/</code>.\\nDespués de añadir los estilos y recursos, nuestra aplicación se renderizará de forma un poco extraña. Está bien. No estamos trabajando en la aplicación ahora mismo. Comenzamos con la construcción de nuestro primer componente!</p>\",\"excerpt\":\"Empezando Storybook se ejecuta junto con tu aplicación en modo desarrollo. Te ayuda a crear componentes de UI aislados de la lógica y el contexto de tu aplicación. Esta edición de Aprende Storybook es para React; otras ediciones para Vue y Angular…\",\"frontmatter\":{\"path\":null,\"title\":\"Empezando\"}}},{\"node\":{\"id\":\"/Users/luz/code/js/binstd.github.io/markdown/docs/es/screen.md absPath of file >>> MarkdownRemark\",\"html\":\"<h1>Construir una pantalla</h1>\\n<p>Nos hemos concentrado en crear interfaces de usuario de abajo hacia arriba; comenzando por lo pequeño y añadiendo complejidad. Esto nos ha permitido desarrollar cada componente de forma aislada, determinar los datos que necesita y jugar con ellos en Storybook. Todo sin necesidad de levantar un servidor o construir pantallas!</p>\\n<p>En este capítulo continuaremos aumentando la sofisticación combinando componentes en una pantalla y desarrollando esa pantalla en Storybook.</p>\\n<h2>Componentes de contenedor anidados</h2>\\n<p>Como nuestra aplicación es muy simple, la pantalla que construiremos es bastante trivial, simplemente envolviendo el componente <code>TaskList</code> (que proporciona sus propios datos a través de Redux) en alguna maqueta y sacando un campo <code>error</code> de primer nivel de redux (asumamos que pondremos ese campo si tenemos algún problema para conectarnos a nuestro servidor):</p>\\n<pre><code class=\\\"language-javascript\\\">import React from 'react';\\nimport PropTypes from 'prop-types';\\nimport { connect } from 'react-redux';\\n\\nimport TaskList from './TaskList';\\n\\nexport function PureInboxScreen({ error }) {\\n  if (error) {\\n    return (\\n      &#x3C;div className=\\\"page lists-show\\\">\\n        &#x3C;div className=\\\"wrapper-message\\\">\\n          &#x3C;span className=\\\"icon-face-sad\\\" />\\n          &#x3C;div className=\\\"title-message\\\">Oh no!&#x3C;/div>\\n          &#x3C;div className=\\\"subtitle-message\\\">Algo va mal&#x3C;/div>\\n        &#x3C;/div>\\n      &#x3C;/div>\\n    );\\n  }\\n\\n  return (\\n    &#x3C;div className=\\\"page lists-show\\\">\\n      &#x3C;nav>\\n        &#x3C;h1 className=\\\"title-page\\\">\\n          &#x3C;span className=\\\"title-wrapper\\\">Taskbox&#x3C;/span>\\n        &#x3C;/h1>\\n      &#x3C;/nav>\\n      &#x3C;TaskList />\\n    &#x3C;/div>\\n  );\\n}\\n\\nPureInboxScreen.propTypes = {\\n  error: PropTypes.string,\\n};\\n\\nPureInboxScreen.defaultProps = {\\n  error: null,\\n};\\n\\nexport default connect(({ error }) => ({ error }))(PureInboxScreen);\\n</code></pre>\\n<p>También cambiamos el componente <code>App</code> para renderizar la pantalla de la bandeja de entrada <code>InboxScreen</code> (normalmente usaríamos un router para elegir la pantalla correcta, pero no nos preocupemos por ello aquí):</p>\\n<pre><code class=\\\"language-javascript\\\">import React, { Component } from 'react';\\nimport { Provider } from 'react-redux';\\nimport store from './lib/redux';\\n\\nimport InboxScreen from './components/InboxScreen';\\n\\nclass App extends Component {\\n  render() {\\n    return (\\n      &#x3C;Provider store={store}>\\n        &#x3C;InboxScreen />\\n      &#x3C;/Provider>\\n    );\\n  }\\n}\\n\\nexport default App;\\n</code></pre>\\n<p>Sin embargo, donde las cosas se ponen interesantes es en la representación de la historia en Storybook.</p>\\n<p>Como vimos anteriormente, el componente <code>TaskList</code> es un <strong>contenedor</strong> que renderiza el componente de presentación <code>PureTaskList</code>. Por definición, los componentes de un contenedor no pueden simplemente hacer render de forma aislada; esperan que se les pase algún contexto o que se conecten a un servicio. Lo que esto significa es que para hacer render de un contenedor en Storybook, debemos mockearlo (es decir, proporcionar una versión ficticia) del contexto o servicio que requiere.</p>\\n<p>Al colocar la \\\"Lista de tareas\\\" <code>TaskList</code> en Storybook, pudimos esquivar este problema simplemente renderizando la <code>PureTaskList</code> y evadiendo el contenedor. Haremos algo similar y renderizaremos la <code>PureInboxScreen</code> en Storybook también.</p>\\n<p>Sin embargo, para la <code>PureInboxScreen</code> tenemos un problema porque aunque la <code>PureInboxScreen</code> en si misma es presentacional, su hijo, la <code>TaskList</code>, no lo es. En cierto sentido la <code>PureInboxScreen</code> ha sido contaminada por la \\\"contenedorización\\\". Así que cuando preparamos nuestras historias:</p>\\n<pre><code class=\\\"language-javascript\\\">import React from 'react';\\nimport { storiesOf } from '@storybook/react';\\n\\nimport { PureInboxScreen } from './InboxScreen';\\n\\nstoriesOf('InboxScreen', module)\\n  .add('default', () => &#x3C;PureInboxScreen />)\\n  .add('error', () => &#x3C;PureInboxScreen error=\\\"Something\\\" />);\\n</code></pre>\\n<p>Vemos que aunque la historia de <code>error</code> funciona bien, tenemos un problema en la historia <code>default</code>, porque la <code>TaskList</code> no tiene una store de Redux a la que conectarse. (También encontrarás problemas similares cuando intentes probar la <code>PureInboxScreen</code> con un test unitario).</p>\\n<p><img src=\\\"/broken-inboxscreen.png\\\" alt=\\\"Broken inbox\\\"></p>\\n<p>Una forma de evitar este problema es nunca renderizar componentes contenedores en ninguna parte de tu aplicación excepto en el nivel más alto y en su lugar pasar todos los datos requeridos bajo la jerarquía de componentes.</p>\\n<p>Sin embargo, los desarrolladores <strong>necesitarán</strong> inevitablemente renderizar los contenedores más abajo en la jerarquía de componentes. Si queremos renderizar la mayor parte o la totalidad de la aplicación en Storybook (¡lo hacemos!), necesitamos una solución a este problema.</p>\\n<div class=\\\"aside\\\">\\nPor otro lado, la transmisión de datos a nivel jerárquico es un enfoque legítimo, especialmente cuando utilizas <a href=\\\"http://graphql.org/\\\">GraphQL</a>. Así es como hemos construido <a href=\\\"https://chromaticqa.com\\\">Chromatic</a> junto a más de 670+ historias.\\n</div>\\n<h2>Suministrando contexto con decoradores</h2>\\n<p>La buena noticia es que es fácil suministrar una store de Redux a la <code>InboxScreen</code> en una historia! Podemos usar una versión mockeada de la store de Redux provista en un decorador:</p>\\n<pre><code class=\\\"language-javascript\\\">import React from 'react';\\nimport { storiesOf } from '@storybook/react';\\nimport { action } from '@storybook/addon-actions';\\nimport { Provider } from 'react-redux';\\n\\nimport { PureInboxScreen } from './InboxScreen';\\nimport { defaultTasks } from './TaskList.stories';\\n\\n// Un mock super simple de un store de redux\\nconst store = {\\n  getState: () => {\\n    return {\\n      tasks: defaultTasks,\\n    };\\n  },\\n  subscribe: () => 0,\\n  dispatch: action('dispatch'),\\n};\\n\\nstoriesOf('InboxScreen', module)\\n  .addDecorator(story => &#x3C;Provider store={store}>{story()}&#x3C;/Provider>)\\n  .add('default', () => &#x3C;PureInboxScreen />)\\n  .add('error', () => &#x3C;PureInboxScreen error=\\\"Something\\\" />);\\n</code></pre>\\n<p>Existen enfoques similares para proporcionar un contexto simulado para otras bibliotecas de datos, tales como <a href=\\\"https://www.npmjs.com/package/apollo-storybook-decorator\\\">Apollo</a>, <a href=\\\"https://github.com/orta/react-storybooks-relay-container\\\">Relay</a> y algunas otras.</p>\\n<p>Recorrer los estados en Storybook hace que sea fácil comprobar que lo hemos hecho correctamente:</p>\\n<video autoPlay muted playsInline loop >\\n  <source\\n    src=\\\"/finished-inboxscreen-states.mp4\\\"\\n    type=\\\"video/mp4\\\"\\n  />\\n</video>\\n<h2>Desarrollo basado en componentes</h2>\\n<p>Empezamos desde abajo con <code>Task</code>, luego progresamos a <code>TaskList</code>, ahora estamos aquí con una interfaz de usuario de pantalla completa. Nuestra <code>InboxScreen</code> contiene un componente de contenedor anidado e incluye historias de acompañamiento.</p>\\n<video autoPlay muted playsInline loop style=\\\"width:480px; height:auto; margin: 0 auto;\\\">\\n  <source\\n    src=\\\"/component-driven-development-optimized.mp4\\\"\\n    type=\\\"video/mp4\\\"\\n  />\\n</video>\\n<p><a href=\\\"https://blog.hichroma.com/component-driven-development-ce1109d56c8e\\\"><strong>El desarrollo basado en componentes</strong></a> te permite expandir gradualmente la complejidad a medida que asciendes en la jerarquía de componentes. Entre los beneficios están un proceso de desarrollo más enfocado y una mayor cobertura de todas las posibles mutaciones de la interfaz de usuario. En resumen, la CDD te ayuda a construir interfaces de usuario de mayor calidad y complejidad.</p>\\n<p>Aún no hemos terminado, el trabajo no termina cuando se construye la interfaz de usuario. También tenemos que asegurarnos de que siga siendo duradero a lo largo del tiempo.</p>\",\"excerpt\":\"Construir una pantalla Nos hemos concentrado en crear interfaces de usuario de abajo hacia arriba; comenzando por lo pequeño y añadiendo complejidad. Esto nos ha permitido desarrollar cada componente de forma aislada, determinar los datos que…\",\"frontmatter\":{\"path\":null,\"title\":\"Construir una pantalla\"}}},{\"node\":{\"id\":\"/Users/luz/code/js/binstd.github.io/markdown/docs/es/simple-component.md absPath of file >>> MarkdownRemark\",\"html\":\"<h1>Construye un componente simple</h1>\\n<p>Construiremos nuestra UI siguiendo la metodología (CDD) <a href=\\\"https://blog.hichroma.com/component-driven-development-ce1109d56c8e\\\">Component-Driven Development</a>. Es un proceso que construye UIs de “abajo hacia arriba”, empezando con los componentes y terminando con las vistas. CDD te ayudará a escalar la cantidad de complejidad con la que te enfrentas a medida que construyes la UI.</p>\\n<h2>Task - Tarea</h2>\\n<p><img src=\\\"/task-states-learnstorybook.png\\\" alt=\\\"Task component in three states\\\"></p>\\n<p><code>Task</code> (o Tarea) es el componente principal en nuestra app. Cada tarea se muestra de forma ligeramente diferente según el estado en el que se encuentre. Mostramos un checkbox marcado (o no marcado), información sobre la tarea y un botón “pin” que nos permite mover la tarea hacia arriba o abajo en la lista de tareas. Poniendo esto en conjunto, necesitaremos estas propiedades -props- :</p>\\n<ul>\\n<li><code>title</code> – un string que describe la tarea</li>\\n<li><code>state</code> - en que lista se encuentra la tarea actualmente? y, está marcado el checkbox?</li>\\n</ul>\\n<p>A medida que comencemos a construir <code>Task</code>, primero escribiremos nuestros tests para los estados que corresponden a los distintos tipos de tareas descritas anteriormente. Luego, utilizamos Storybook para construir el componente de forma aislada usando datos de prueba. Vamos a “testear visualmente” la apariencia del componente a medida que cambiemos cada estado.</p>\\n<p>Este proceso es similar a <a href=\\\"https://en.wikipedia.org/wiki/Test-driven_development\\\">Test-driven development</a> (TDD) al que podemos llamar “<a href=\\\"https://blog.hichroma.com/visual-test-driven-development-aec1c98bed87\\\">Visual TDD</a>”.</p>\\n<h2>Ajustes iniciales</h2>\\n<p>Primero, vamos a crear el componente Task y el archivo de historias de storybook que lo acompaña: <code>src/components/Task.js</code> y <code>src/components/Task.stories.js</code>.</p>\\n<p>Comenzaremos con una implementación básica de <code>Task</code>, simplemente teniendo en cuenta los atributos que sabemos que necesitaremos y las dos acciones que puedes realizar con una tarea (para moverla entre las listas):</p>\\n<pre><code class=\\\"language-javascript\\\">import React from 'react';\\n\\nexport default function Task({ task: { id, title, state }, onArchiveTask, onPinTask }) {\\n  return (\\n    &#x3C;div className=\\\"list-item\\\">\\n      &#x3C;input type=\\\"text\\\" value={title} readOnly={true} />\\n    &#x3C;/div>\\n  );\\n}\\n</code></pre>\\n<p>Arriba, renderizamos directamente <code>Task</code> basándonos en la estructura HTML existente de la app Todos.</p>\\n<p>A continuación creamos los tres estados de prueba de Task dentro del archivo de historia:</p>\\n<pre><code class=\\\"language-javascript\\\">import React from 'react';\\nimport { storiesOf } from '@storybook/react';\\nimport { action } from '@storybook/addon-actions';\\n\\nimport Task from './Task';\\n\\nexport function createTask(attrs) {\\n  return {\\n    id: Math.round(Math.random() * 1000000).toString(),\\n    title: 'Test Task',\\n    state: 'TASK_INBOX',\\n    updatedAt: Date.now(),\\n    ...attrs,\\n  };\\n}\\n\\nexport const actions = {\\n  onPinTask: action('onPinTask'),\\n  onArchiveTask: action('onArchiveTask'),\\n};\\n\\nstoriesOf('Task', module)\\n  .add('default', () => &#x3C;Task task={createTask({ state: 'TASK_INBOX' })} {...actions} />)\\n  .add('pinned', () => &#x3C;Task task={createTask({ state: 'TASK_PINNED' })} {...actions} />)\\n  .add('archived', () => &#x3C;Task task={createTask({ state: 'TASK_ARCHIVED' })} {...actions} />);\\n</code></pre>\\n<p>Existen dos niveles básicos de organización en Storybook. El componente y sus historias hijas. Piensa en cada historia como una permutación posible del componente. Puedes tener tantas historias por componente como se necesite.</p>\\n<ul>\\n<li>\\n<p><strong>Component</strong></p>\\n<ul>\\n<li>Story</li>\\n<li>Story</li>\\n<li>Story</li>\\n</ul>\\n</li>\\n</ul>\\n<p>Para iniciar Storybook, primero invocamos a la función <code>storiesOf()</code> para registrar el componente. Agregamos un nombre para mostrar el componente, que se muestra en la barra lateral de la aplicación Storybook.</p>\\n<p><code>action()</code> nos permite crear un callback que aparecerá en el panel <strong>actions</strong> de la UI de Storybook cuando es cliqueado. Entonces, cuando construyamos un botón pin, podremos determinar en la UI de prueba si un click en el botón es exitoso o no.</p>\\n<p>Como necesitamos pasarle el mismo conjunto de acciones a todas las permutaciones de nuestro componente, es conveniente agruparlas en una sola variable <code>actions</code> y utilizar <code>{...actions}</code>, la expansión de propiedades de React, para pasarlas todas a la vez. <code>&#x3C;Task {...actions}></code> es equivalente a <code>&#x3C;Task onPinTask={actions.onPinTask} onArchiveTask={actions.onArchiveTask}></code>.</p>\\n<p>Otra cosa positiva acerca de agrupar las <code>actions</code> que un componente necesita, es que puedes usar <code>export</code> y utilizarlas en historias para otros componentes que reutilicen este componente, como veremos luego.</p>\\n<p>Para definir nuestras historias, llamamos a <code>add()</code> una vez para cada uno de nuestros estados del test para generar una historia. La historia de acción - action story - es una función que retorna un elemento renderizado (es decir, una clase componente con un conjunto de props) en un estado dado---exactamente como en React <a href=\\\"https://reactjs.org/docs/components-and-props.html\\\">Stateless Functional Component</a>.</p>\\n<p>Al crear una historia utilizamos una función auxiliar (<code>createTask()</code>) para construir la forma de la task que el componente espera. Esto generalmente se modela a partir del aspecto de los datos verdaderos. Nuevamente, <code>export</code>-ando esta función nos permitirá reutilizarla en historias posteriores, como veremos.</p>\\n<div class=\\\"aside\\\">\\nLas <a href=\\\"https://storybook.js.org/addons/introduction/#2-native-addons\\\"><b>Acciones</b></a> ayudan a verificar las interacciones cuando creamos componentes UI en aislamiento. A menudo no tendrás acceso a las funciones y el estado que tienes en el contexto de la aplicación. Utiliza <code>action()</code> para agregarlas.\\n</div>\\n<h2>Configuración</h2>\\n<p>También necesitamos hacer un pequeño cambio en la configuración de Storybook (<code>.storybook/config.js</code>) para que tenga en cuenta nuestros archivos <code>.stories.js</code> y use nuestro archivo CSS. Por defecto, Storybook busca historias en el directorio <code>/stories</code>; este tutorial usa un esquema de nombres que es similar al esquema de nombres <code>.test.js</code> preferido por CRA para pruebas -tests- automatizadas.</p>\\n<pre><code class=\\\"language-javascript\\\">import { configure } from '@storybook/react';\\nimport '../src/index.css';\\n\\nconst req = require.context('../src', true, /.stories.js$/);\\n\\nfunction loadStories() {\\n  req.keys().forEach(filename => req(filename));\\n}\\n\\nconfigure(loadStories, module);\\n</code></pre>\\n<p>Una vez que hayamos hecho esto, reiniciando el servidor de Storybook debería producir casos de prueba para los tres estados de Task:</p>\\n<video autoPlay muted playsInline controls >\\n  <source\\n    src=\\\"/inprogress-task-states.mp4\\\"\\n    type=\\\"video/mp4\\\"\\n  />\\n</video>\\n<h2>Construyendo los estados</h2>\\n<p>Ahora tenemos configurado Storybook, los estilos importados y los casos de prueba construidos; podemos comenzar rápidamente el trabajo de implementar el HTML del componente para que coincida con el diseño.</p>\\n<p>El componente todavía es básico. Primero escribiremos el código que se aproxima al diseño sin entrar en demasiados detalles:</p>\\n<pre><code class=\\\"language-javascript\\\">import React from 'react';\\n\\nexport default function Task({ task: { id, title, state }, onArchiveTask, onPinTask }) {\\n  return (\\n    &#x3C;div className={`list-item ${state}`}>\\n      &#x3C;label className=\\\"checkbox\\\">\\n        &#x3C;input\\n          type=\\\"checkbox\\\"\\n          defaultChecked={state === 'TASK_ARCHIVED'}\\n          disabled={true}\\n          name=\\\"checked\\\"\\n        />\\n        &#x3C;span className=\\\"checkbox-custom\\\" onClick={() => onArchiveTask(id)} />\\n      &#x3C;/label>\\n      &#x3C;div className=\\\"title\\\">\\n        &#x3C;input type=\\\"text\\\" value={title} readOnly={true} placeholder=\\\"Input title\\\" />\\n      &#x3C;/div>\\n\\n      &#x3C;div className=\\\"actions\\\" onClick={event => event.stopPropagation()}>\\n        {state !== 'TASK_ARCHIVED' &#x26;&#x26; (\\n          &#x3C;a onClick={() => onPinTask(id)}>\\n            &#x3C;span className={`icon-star`} />\\n          &#x3C;/a>\\n        )}\\n      &#x3C;/div>\\n    &#x3C;/div>\\n  );\\n}\\n</code></pre>\\n<p>El maquetado adicional de arriba, combinado con el CSS que hemos importado antes, produce la siguiente UI:</p>\\n<video autoPlay muted playsInline loop>\\n  <source\\n    src=\\\"/finished-task-states.mp4\\\"\\n    type=\\\"video/mp4\\\"\\n  />\\n</video>\\n<h2>Especificar los requerimientos de datos</h2>\\n<p>Es una buena práctica en React utilizar <code>propTypes</code> para especificar la forma de los datos que espera recibir un componente. No sólo se auto documenta, sino que también ayuda a detectar problemas rápidamente.</p>\\n<pre><code class=\\\"language-javascript\\\">import React from 'react';\\nimport PropTypes from 'prop-types';\\n\\nfunction Task() {\\n  ...\\n}\\n\\nTask.propTypes = {\\n  task: PropTypes.shape({\\n    id: PropTypes.string.isRequired,\\n    title: PropTypes.string.isRequired,\\n    state: PropTypes.string.isRequired,\\n  }),\\n  onArchiveTask: PropTypes.func,\\n  onPinTask: PropTypes.func,\\n};\\n\\nexport default Task;\\n</code></pre>\\n<p>Ahora aparecerá una advertencia en modo desarrollo si el componente Task  se utiliza incorrectamente.</p>\\n<div class=\\\"aside\\\">\\nUna forma alternativa de lograr el mismo propósito es utilizando un sistema de tipos de JavaScript como TypeScript, para crear un tipo para las propiedades del componente.\\n</div>\\n<h2>Componente construido!</h2>\\n<p>Ahora hemos construido con éxito un componente sin necesidad de un servidor o sin ejecutar toda la aplicación frontend. El siguiente paso es construir los componentes restantes de la Taskbox, uno por uno de manera similar.</p>\\n<p>Como puedes ver, comenzar a construir componentes de forma aislada es fácil y rápido. Podemos esperar producir una UI de mayor calidad con menos errores y más pulida porque es posible profundizar y probar todos los estados posibles.</p>\\n<h2>Pruebas automatizadas</h2>\\n<p>Storybook nos dio una excelente manera de probar visualmente nuestra aplicación durante su construcción. Las 'historias' ayudarán a asegurar que no rompamos nuestra Task visualmente, a medida que continuamos desarrollando la aplicación. Sin embargo, en esta etapa, es un proceso completamente manual y alguien tiene que hacer el esfuerzo de hacer clic en cada estado de prueba y asegurarse de que se visualice bien y sin errores ni advertencias. ¿No podemos hacer eso automáticamente?</p>\\n<h3>Pruebas de instantáneas</h3>\\n<p>La prueba de instantáneas se refiere a la práctica de registrar la salida \\\"correcta\\\" de un componente para una entrada dada y luego en el futuro marcar el componente siempre que la salida cambie. Esto complementa a Storybook, porque es una manera rápida de ver la nueva versión de un componente y verificar los cambios.</p>\\n<p>Con <a href=\\\"https://github.com/storybooks/storybook/tree/master/addons/storyshots\\\">Storyshots addon</a> se crea una prueba de instantánea para cada una de las historias. Usalo agregando una dependencia en modo desarrollo en el paquete:</p>\\n<pre><code class=\\\"language-bash\\\">yarn add --dev @storybook/addon-storyshots react-test-renderer\\n</code></pre>\\n<p>Luego crea un archivo <code>src/storybook.test.js</code> con el siguiente contenido:</p>\\n<pre><code class=\\\"language-javascript\\\">import initStoryshots from '@storybook/addon-storyshots';\\ninitStoryshots();\\n</code></pre>\\n<p>Una vez hecho lo anterior, podemos ejecutar <code>yarn test</code> y veremos el siguiente resultado:</p>\\n<p><img src=\\\"/task-testrunner.png\\\" alt=\\\"Task test runner\\\"></p>\\n<p>Ahora tenemos una prueba de instantánea para cada una de las historias de <code>Task</code>. Si cambiamos la implementación de <code>Task</code>, se nos pedirá que verifiquemos los cambios.</p>\",\"excerpt\":\"Construye un componente simple Construiremos nuestra UI siguiendo la metodología (CDD)  Component-Driven Development . Es un proceso que construye UIs de “abajo hacia arriba”, empezando con los componentes y terminando con las vistas. CDD te ayudará…\",\"frontmatter\":{\"path\":null,\"title\":\"Construye un componente simple\"}}},{\"node\":{\"id\":\"/Users/luz/code/js/binstd.github.io/markdown/docs/es/test.md absPath of file >>> MarkdownRemark\",\"html\":\"<h1>Testear Componentes UI</h1>\\n<p>Ningún tutorial de Storybook estaría completo sin hacer test. Las pruebas son esenciales para crear interfaces de usuario de alta calidad. En los sistemas modulares, los ajustes minúsculos pueden dar lugar a regresiones importantes. Hasta ahora hemos encontrado tres tipos de pruebas:</p>\\n<ul>\\n<li><strong>Pruebas visuales</strong> confían en que los desarrolladores examinen manualmente un componente para verificar que esté correcto. Nos ayudan a comprobar la aparencia de un componente a medida que lo construimos.</li>\\n<li><strong>Pruebas instantáneas</strong> con Storyshots captura el marcado del renderizado de un componente. Nos ayudan a mantenernos al tanto de los cambios de marcado que causan errores de renderizado y advertencias en los componentes.</li>\\n<li><strong>Pruebas unitarias</strong> con Jest verifica que la salida de un componente permanezca igual a una entrada fija dada. Son ideales para probar las cualidades funcionales de un componente.</li>\\n</ul>\\n<h2>\\\"¿Pero se ve bien?\\\"</h2>\\n<p>Desafortunadamente, los métodos de testing mencionados no son suficientes para prevenir errores de interfaz. Las interfaces de usuario son difíciles de probar porque el diseño es subjetivo y matizado. Las pruebas visuales son demasiado manuales, las pruebas instantáneas desencadenan demasiados falsos positivos cuando se utilizan para la interfaz de usuario, y las pruebas unitarias a nivel de píxel son de poco valor. Una estrategia completa de pruebas de Storybook también incluye pruebas de regresión visual.</p>\\n<h2>Pruebas de regresión visual para Storybook</h2>\\n<p>Las pruebas de regresión visual están diseñadas para detectar cambios en la apariencia. Funcionan haciendo capturas de pantalla de todas las historias y comparando con los cambios superficiales. Esto es perfecto para verificar elementos gráficos como diseño, color, tamaño y contraste.</p>\\n<video autoPlay muted playsInline loop style=\\\"width:480px; margin: 0 auto;\\\">\\n  <source\\n    src=\\\"/visual-regression-testing.mp4\\\"\\n    type=\\\"video/mp4\\\"\\n  />\\n</video>\\n<p>Storybook es una herramienta fantástica para las pruebas de regresión visual porque cada historia es esencialmente una especificación del test. Cada vez que escribimos o actualizamos una historia recibimos una especificación gratis!</p>\\n<p>Existen varias herramientas para la prueba de regresión visual. Para equipos profesionales recomendamos <a href=\\\"https://www.chromaticqa.com/\\\"><strong>Chromatic</strong></a>, un complemento hecho por las personas de Storybook que ejecuta pruebas en la nube.</p>\\n<h2>Configurar pruebas de regresión visual</h2>\\n<p>Chromatic es un complemento de Storybook para pruebas de regresión visual y revisión en la nube. Dado que es un servicio de pago (con una prueba gratuita), puede que no sea para todos. Sin embargo, Chromatic es un ejemplo instructivo de un flujo de trabajo de pruebas visuales de producción que probaremos gratuitamente. Echemos un vistazo.</p>\\n<h3>Iniciando Git</h3>\\n<p>Primero tienes que configurar Git para tu proyecto en el directorio local. Chromatic usa el historial de Git para hacer un seguimiento de los componentes de tu interfaz de usuario.</p>\\n<pre><code class=\\\"language-bash\\\">$ git init\\n</code></pre>\\n<p>Luego agrega archivos al primer commit.</p>\\n<pre><code class=\\\"language-bash\\\">$ git add .\\n</code></pre>\\n<p>Ahora haz commit de los archivos.</p>\\n<pre><code class=\\\"language-bash\\\">$ git commit -m \\\"taskbox UI\\\"\\n</code></pre>\\n<h3>Añadiendo Chromatic</h3>\\n<p>Agregando el paquete como una dependencia.</p>\\n<pre><code class=\\\"language-bash\\\">yarn add storybook-chromatic\\n</code></pre>\\n<p>Importa Chromatic en tu archivo <code>.storybook/config.js</code>.</p>\\n<pre><code class=\\\"language-javascript\\\">import { configure } from '@storybook/react';\\nimport 'storybook-chromatic/storybook-addon';\\n\\nimport '../src/index.css';\\n\\nconst req = require.context('../src/components', true, /\\\\.stories\\\\.js$/);\\n\\nfunction loadStories() {\\n  req.keys().forEach(filename => req(filename));\\n}\\n\\nconfigure(loadStories, module);\\n</code></pre>\\n<p>Ahora <a href=\\\"https://chromaticqa.com/start\\\">logueate en Chromatic</a> con tú cuenta de GitHub (Chromatic solo te pedirá algunos permisos simples). Crea un proyecto con nombre \\\"taskbox\\\" y copia tu <code>app-code</code> único.</p>\\n<video autoPlay muted playsInline loop style=\\\"width:520px; margin: 0 auto;\\\">\\n  <source\\n    src=\\\"/chromatic-setup-learnstorybook.mp4\\\"\\n    type=\\\"video/mp4\\\"\\n  />\\n</video>\\n<p>Ejecuta el comando de prueba en la línea de comandos para configurar las pruebas de regresión visual para Storybook. No olvides añadir tu código de aplicación único en el <code>&#x3C;app-code></code>.</p>\\n<pre><code class=\\\"language-bash\\\">./node_modules/.bin/chromatic test --storybook-addon --app-code=&#x3C;app-code> --do-not-start\\n</code></pre>\\n<div class=\\\"aside\\\">\\n<code>--do-not-start</code> es una opción que le dice a Chromatic que no inicie Storybook. Usa esto si ya tienes a Storybook corriendo. Si no, omite el <code>--do-not-start</code>.\\n</div>\\n<p>Una vez el primer test esté completo, tenemos líneas base de prueba para cada historia. En otras palabras, capturas de cada historia que ya se conocen como \\\"buenas\\\". Los futuros cambios a estas historias serán comparados con estás lineas base.</p>\\n<p><img src=\\\"/chromatic-baselines.png\\\" alt=\\\"Chromatic baselines\\\"></p>\\n<h2>Capturando un cambio en la interfaz de usuario</h2>\\n<p>La prueba de regresión visual se basa en la comparación de imágenes del nuevo código de la interfaz de usuario renderizado con las imágenes de la línea base. Si se detecta un cambio en la interfaz de usuario, se notificará. Vea cómo funciona ajustando el fondo del componente <code>Tareas</code>:</p>\\n<p><img src=\\\"/chromatic-change-to-task-component.png\\\" alt=\\\"code change\\\"></p>\\n<p>Esto produce un nuevo color de fondo para el artículo.</p>\\n<p><img src=\\\"/chromatic-task-change.png\\\" alt=\\\"task background change\\\"></p>\\n<p>Usa el comando de prueba anterior para ejecutar otra prueba cromática.</p>\\n<pre><code class=\\\"language-bash\\\">./node_modules/.bin/chromatic test --storybook-addon --app-code=&#x3C;app-code> --do-not-start\\n</code></pre>\\n<p>Sigue el enlace a la interfaz de usuario web donde verá los cambios.</p>\\n<p><img src=\\\"/chromatic-catch-changes.png\\\" alt=\\\"UI changes in Chromatic\\\"></p>\\n<p>Hay muchos cambios! La jerarquía de componentes donde <code>Task</code> es hijo de <code>TaskList</code> y <code>Inbox</code> significa un pequeño giro de bolas de nieve en regresiones mayores. Esta circunstancia es precisamente la razón por la que los desarrolladores necesitan pruebas de regresión visual además de otros métodos de pruebas.</p>\\n<p><img src=\\\"/minor-major-regressions.gif\\\" alt=\\\"UI minor tweaks major regressions\\\"></p>\\n<h2>Revisando cambios</h2>\\n<p>Las pruebas de regresión visual aseguran que los componentes no cambien por accidente. Pero todavía depende de ti determinar si los cambios son intencionales o no.</p>\\n<p>Si un cambio es intencional, es necesario actualizar la línea base para que las pruebas futuras se comparen con la última versión de la historia. Si un cambio no es intencional, debe ser corregido.</p>\\n<video autoPlay muted playsInline loop style=\\\"width:480px; margin: 0 auto;\\\">\\n  <source\\n    src=\\\"/website-workflow-review-merge-optimized.mp4\\\"\\n    type=\\\"video/mp4\\\"\\n  />\\n</video>\\n<p>Dado que las aplicaciones modernas se construyen a partir de componentes, es importante que probemos a nivel de componentes. Hacerlo nos ayuda a identificar la causa raíz de un cambio, el componente, en lugar de reaccionar a los síntomas de un cambio, las pantallas y los componentes compuestos.</p>\\n<h2>Fusionando cambios</h2>\\n<p>Cuando hayamos terminado de revisar, estaremos listos para fusionar o hacer \\\"merge\\\" de los cambios en la interfaz de usuario con confianza, sabiendo que las actualizaciones no introducirán errores accidentalmente. Si te gusta el nuevo fondo <code>papayawhip</code> entonces acepta los cambios, si no, vuelve al estado anterior.</p>\\n<p><img src=\\\"/chromatic-review-finished.png\\\" alt=\\\"Changes ready to be merged\\\"></p>\\n<p>Storybook te ayuda a <strong>construir</strong> componentes; las pruebas te ayudan a <strong>mantenerlos</strong>. Los cuatro tipos de pruebas de interfaz de usuario que se tratan en este tutorial son las pruebas visuales, de instantánea, unitarios y de regresión visual. Puede automatizar los tres últimos añadiéndolos a su script CI. Esto le ayuda a enviar componentes sin tener que preocuparse por los bugs polizones. A continuación se ilustra todo el flujo de trabajo.</p>\\n<p><img src=\\\"/cdd-review-workflow.png\\\" alt=\\\"Visual regression testing workflow\\\"></p>\",\"excerpt\":\"Testear Componentes UI Ningún tutorial de Storybook estaría completo sin hacer test. Las pruebas son esenciales para crear interfaces de usuario de alta calidad. En los sistemas modulares, los ajustes minúsculos pueden dar lugar a regresiones…\",\"frontmatter\":{\"path\":null,\"title\":\"Testing\"}}},{\"node\":{\"id\":\"/Users/luz/code/js/binstd.github.io/markdown/docs/zh/composite-component.md absPath of file >>> MarkdownRemark\",\"html\":\"<h1>组装复合组件</h1>\\n<p>上一章我们构建了第一个组件; 本章 我们学习 扩展构建TaskList的任务列表. 让我们将 组件组合 在一起,看看在引入更多复杂性时会发生什么. </p>\\n<h2>任务列表</h2>\\n<p>Taskbox 通过将 固定任务 置于默认任务之上 来强调 固定任务. 这产生了两种变体<code>TaskList</code>您需要为以下内容创建故事: 默认项目 以及 默认和 固定项目. </p>\\n<p><img src=\\\"/tasklist-states-1.png\\\" alt=\\\"default and pinned tasks\\\"></p>\\n<p><code>Task</code>可以异步发送数据,我们 <strong>也</strong>需要在没有连接的情况下 loading 渲染 <em>右图</em>. 此外,当没有任务时,需要 空状态 <em>左图</em>. </p>\\n<p><img src=\\\"/tasklist-states-2.png\\\" alt=\\\"empty and loading tasks\\\"></p>\\n<h2>获取设置</h2>\\n<p>复合组件与 其包含的基本组件没有太大区别. 创建一个<code>TaskList</code>组件和 对应的故事文件: <code>src/components/TaskList.js</code>和<code>src/components/TaskList.stories.js</code>. </p>\\n<p>从粗略的实现开始<code>TaskList</code>. 你需要导入早期的<code>Task</code>组件,并将 属性和操作 作为输入传递. </p>\\n<pre><code class=\\\"language-javascript\\\">import React from 'react';\\n\\nimport Task from './Task';\\n\\nfunction TaskList({ loading, tasks, onPinTask, onArchiveTask }) {\\n  const events = {\\n    onPinTask,\\n    onArchiveTask,\\n  };\\n\\n  if (loading) {\\n    return &#x3C;div className=\\\"list-items\\\">loading&#x3C;/div>;\\n  }\\n\\n  if (tasks.length === 0) {\\n    return &#x3C;div className=\\\"list-items\\\">empty&#x3C;/div>;\\n  }\\n\\n  return (\\n    &#x3C;div className=\\\"list-items\\\">\\n      {tasks.map(task => &#x3C;Task key={task.id} task={task} {...events} />)}\\n    &#x3C;/div>\\n  );\\n}\\n\\nexport default TaskList;\\n</code></pre>\\n<p>接下来创建<code>Tasklist</code>故事文件中的测试状态. </p>\\n<pre><code class=\\\"language-javascript\\\">import React from 'react';\\nimport { storiesOf } from '@storybook/react';\\n\\nimport TaskList from './TaskList';\\nimport { task, actions } from './Task.stories';\\n\\nexport const defaultTasks = [\\n  { ...task, id: '1', title: 'Task 1' },\\n  { ...task, id: '2', title: 'Task 2' },\\n  { ...task, id: '3', title: 'Task 3' },\\n  { ...task, id: '4', title: 'Task 4' },\\n  { ...task, id: '5', title: 'Task 5' },\\n  { ...task, id: '6', title: 'Task 6' },\\n];\\n\\nexport const withPinnedTasks = [\\n  ...defaultTasks.slice(0, 5),\\n  { id: '6', title: 'Task 6 (pinned)', state: 'TASK_PINNED' },\\n];\\n\\nstoriesOf('TaskList', module)\\n  .addDecorator(story => &#x3C;div style={{ padding: '3rem' }}>{story()}&#x3C;/div>)\\n  .add('default', () => &#x3C;TaskList tasks={defaultTasks} {...actions} />)\\n  .add('withPinnedTasks', () => &#x3C;TaskList tasks={withPinnedTasks} {...actions} />)\\n  .add('loading', () => &#x3C;TaskList loading tasks={[]} {...actions} />)\\n  .add('empty', () => &#x3C;TaskList tasks={[]} {...actions} />);\\n</code></pre>\\n<p><code>addDecorator()</code>允许我们为每个任务的渲染添加一些\\\"上下文\\\". 在这种情况下,我们在列表周围添加 <em>填充-padding</em>,以便更容易进行 可视化验证. </p>\\n<div class=\\\"aside\\\">\\n<a href=\\\"https://storybook.js.org/addons/introduction/#1-decorators\\\"><b>Decorators-装饰器</b></a> 是一种为 故事 提供任意包装的方法。 在这种情况下，我们使用装饰器来添加样式。 它们还可以用于包装故事在 <b>\\\"providers\\\" - 设置 React上下文 的库组件</b>.\\n</div>\\n<p><code>task</code>提供一个<code>Task</code>的形状,这是通过我们创建和导出的<code>Task.stories.js</code>文件. 同样的,<code>actions</code>定义<code>Task</code>组件期望的操作 (模拟回调) ,其中<code>TaskList</code>也需要. </p>\\n<p>现在查看 Storybook的新内容<code>TaskList</code>故事. </p>\\n<video autoPlay muted playsInline loop>\\n  <source\\n    src=\\\"/inprogress-tasklist-states.mp4\\\"\\n    type=\\\"video/mp4\\\"\\n  />\\n</video>\\n<h2>建立状态</h2>\\n<p>我们的组件仍然很粗糙,但现在我们已经了解了 要努力的故事. 你可能会想到<code>.list-items</code>包装过于简单化. 你是对的 - 在大多数情况下,我们不会只是添加一个包装器来创建一个新的组件. 但是 <strong>真正的复杂性</strong> 的<code>TaskList</code>组件在边缘情况下会显示<code>withPinnedTasks</code>,<code>loading</code>,和<code>empty</code>. </p>\\n<pre><code class=\\\"language-javascript\\\">import React from 'react';\\n\\nimport Task from './Task';\\n\\nfunction TaskList({ loading, tasks, onPinTask, onArchiveTask }) {\\n  const events = {\\n    onPinTask,\\n    onArchiveTask,\\n  };\\n\\n  const LoadingRow = (\\n    &#x3C;div className=\\\"loading-item\\\">\\n      &#x3C;span className=\\\"glow-checkbox\\\" />\\n      &#x3C;span className=\\\"glow-text\\\">\\n        &#x3C;span>Loading&#x3C;/span> &#x3C;span>cool&#x3C;/span> &#x3C;span>state&#x3C;/span>\\n      &#x3C;/span>\\n    &#x3C;/div>\\n  );\\n\\n  if (loading) {\\n    return (\\n      &#x3C;div className=\\\"list-items\\\">\\n        {LoadingRow}\\n        {LoadingRow}\\n        {LoadingRow}\\n        {LoadingRow}\\n        {LoadingRow}\\n        {LoadingRow}\\n      &#x3C;/div>\\n    );\\n  }\\n\\n  if (tasks.length === 0) {\\n    return (\\n      &#x3C;div className=\\\"list-items\\\">\\n        &#x3C;div className=\\\"wrapper-message\\\">\\n          &#x3C;span className=\\\"icon-check\\\" />\\n          &#x3C;div className=\\\"title-message\\\">You have no tasks&#x3C;/div>\\n          &#x3C;div className=\\\"subtitle-message\\\">Sit back and relax&#x3C;/div>\\n        &#x3C;/div>\\n      &#x3C;/div>\\n    );\\n  }\\n\\n  const tasksInOrder = [\\n    ...tasks.filter(t => t.state === 'TASK_PINNED'), //&#x3C; ==== 固定顶部\\n    ...tasks.filter(t => t.state !== 'TASK_PINNED'),\\n  ];\\n\\n  return (\\n    &#x3C;div className=\\\"list-items\\\">\\n      {tasksInOrder.map(task => &#x3C;Task key={task.id} task={task} {...events} />)}\\n    &#x3C;/div>\\n  );\\n}\\n\\nexport default TaskList;\\n</code></pre>\\n<p>添加的标记会产生以下UI: </p>\\n<video autoPlay muted playsInline loop>\\n  <source\\n    src=\\\"/finished-tasklist-states.mp4\\\"\\n    type=\\\"video/mp4\\\"\\n  />\\n</video>\\n<p>请注意列表中 固定项 的位置. 我们希望固定项目在 列表顶部 呈现,以使其成为我们用户的优先事项. </p>\\n<h2>数据要求和props</h2>\\n<p>随着组件的增长,输入要求也在增长. 要求定义<code>TaskList</code>的<em>props</em>. 因为<code>Task</code>是一个子组件,请确保提供 正确形状的数据 来呈现它. 为了节省时间和头痛,请重用您定义的早期<code>Task</code>的propTypes. </p>\\n<pre><code class=\\\"language-javascript\\\">import React from 'react';\\nimport PropTypes from 'prop-types';\\n\\nfunction TaskList() {\\n  ...\\n}\\n\\n\\nTaskList.propTypes = {\\n  loading: PropTypes.bool,\\n  tasks: PropTypes.arrayOf(Task.propTypes.task).isRequired,\\n  onPinTask: PropTypes.func.isRequired,\\n  onArchiveTask: PropTypes.func.isRequired,\\n};\\n\\nTaskList.defaultProps = {\\n  loading: false,\\n};\\n\\nexport default TaskList;\\n</code></pre>\\n<h2>自动化测试</h2>\\n<p>在上一章中,我们学习了如何使用 Storyshots快照测试 故事. <code>Task</code>测试没有太多的复杂性,已然够用了. 而<code>TaskList</code>增加了另一层复杂性,我们希望 以 自动测试 的方式验证 某些输入产生某些输出. 为此,我们将使用创建单 元测试<a href=\\\"https://facebook.github.io/jest/\\\">jest-笑话</a>再加上测试渲染器等<a href=\\\"http://airbnb.io/enzyme/\\\">Enzyme</a>. </p>\\n<p><img src=\\\"/logo-jest.png\\\" alt=\\\"Jest logo\\\"></p>\\n<h3>用Jest进行单元测试</h3>\\n<p> Storybook故事 与 手动可视化测试 和 快照测试 (见上文) 相结合,可以避免 UI错误. 如果故事 涵盖了 各种各样的组件用例,并且我们使用的工具可以确保 人员检查故事的任何变化,那么错误的可能性就大大降低. </p>\\n<p>然而,有时候魔鬼是在细节中. 需要一个明确有关这些细节的测试框架. 这让我们进行了单元测试. </p>\\n<p>在我们的例子中,我们希望我们的<code>TaskList</code>,在传递 不固定tasks 之前,呈现所有固定tasks. 虽然我们有一个故事 (<code>withPinnedTasks</code>) 测试这个确切的场景; 但是如果组件停止对 这样的任务 进行排序，那么就人类看着来说，这可能是不明确的,<em>因为只看到表面与操作</em>, 这是一个bug. 它肯定不会尖叫 <strong>\\\"错误!\\\"</strong> 直怼眼睛. </p>\\n<p>因此,为了避免这个问题,我们可以使用Jest 将故事呈现给<code>DOM</code>,并运行一些<code>DOM</code>查询代码,来验证输出的显着特征. </p>\\n<p>创建一个名为的测试文件<code>TaskList.test.js</code>. 在这里,我们将构建我们的测试,对输出进行断言. </p>\\n<pre><code class=\\\"language-javascript\\\">import React from 'react';\\nimport ReactDOM from 'react-dom';\\nimport TaskList from './TaskList';\\nimport { withPinnedTasks } from './TaskList.stories';\\n\\nit('renders pinned tasks at the start of the list', () => {\\n  const div = document.createElement('div');\\n  const events = { onPinTask: jest.fn(), onArchiveTask: jest.fn() };\\n  ReactDOM.render(&#x3C;TaskList tasks={withPinnedTasks} {...events} />, div);\\n\\n  // 我们期望首先渲染标题为“任务6（固定）”的任务，而不是最后\\n  const lastTaskInput = div.querySelector('.list-item:nth-child(1) input[value=\\\"Task 6 (pinned)\\\"]');\\n  expect(lastTaskInput).not.toBe(null);\\n\\n  ReactDOM.unmountComponentAtNode(div);\\n});\\n</code></pre>\\n<p><img src=\\\"/tasklist-testrunner.png\\\" alt=\\\"TaskList test runner\\\"></p>\\n<p>请注意,我们已经能够重用<code>withPinnedTasks</code>故事 和单元测试中的任务列表;通过这种方式,我们可以继续以越来越多的方式利用现有资源(代表组件的有趣配置的示例) . </p>\\n<p>另请注意,此测试非常脆弱. 随着项目的成熟,以及项目的确切实现,这都可能是<code>Task</code>的更改 - 可能使用 不同的类名或<code>textarea</code>而不是一个<code>input</code>- 测试将失败,需要更新. 这不一定是一个问题,但使用UI的 单元测试 要小心的指示. 它们不容易维护. 替代的是依靠视觉,快照和视觉回归 (参见<a href=\\\"/test/\\\">测试章节</a>) 的 Stortbook测试. </p>\",\"excerpt\":\"组装复合组件 上一章我们构建了第一个组件; 本章 我们学习 扩展构建TaskList的任务列表. 让我们将 组件组合 在一起,看看在引入更多复杂性时会发生什么.  任务列表 Taskbox 通过将 固定任务 置于默认任务之上 来强调 固定任务. 这产生了两种变体 TaskList 您需要为以下内容创建故事: 默认项目 以及 默认和 固定项目.  Task 可以异步发送数据,我们  也 需要在没有连接的情况下 loading…\",\"frontmatter\":{\"path\":null,\"title\":\"组装复合组件\"}}},{\"node\":{\"id\":\"/Users/luz/code/js/binstd.github.io/markdown/docs/zh/conclusion.md absPath of file >>> MarkdownRemark\",\"html\":\"<h1>结论</h1>\\n<p>恭喜! 您在Storybook中创建了第一个UI. 在此过程中,您学习了如何构建,组合,测试和部署UI组件. 如果您一直关注,您的 repo和部署的Storybook 应如下所示: </p>\\n<p><a href=\\\"https://github.com/hichroma/learnstorybook-code\\\">📕<strong>GitHub回购: hichroma / learnstorybook-code</strong></a>\\n<br/>\\n<a href=\\\"https://clever-banach-415c03.netlify.com/\\\">🌎<strong>部署 Storybook</strong></a></p>\\n<p>Storybook是 React,Vue和Angular 的强大工具. 它拥有蓬勃发展的开发者社区和丰富的插件. 这篇介绍揭示了可能的表面. 我们相信,一旦您采用了Storybook,您将会对构建持久UI的效率印象深刻. </p>\\n<h2>学到更多</h2>\\n<p>想深入了解? 这是有用的资源. </p>\\n<ul>\\n<li>\\n<p><a href=\\\"https://storybook.js.org/basics/introduction/\\\"><strong>官方 Storybook文档</strong></a>有API文档,社区链接和插件库. </p>\\n</li>\\n<li>\\n<p><a href=\\\"https://blog.hichroma.com/the-delightful-storybook-workflow-b322b76fd07\\\"><strong>令人愉快的 Storybook工作流程</strong></a> 重点介绍Squarespace,Major League Soccer,Discovery Network和 Apollo GraphQL 的高速团队使用的工作流程最佳实践. </p>\\n</li>\\n<li>\\n<p><a href=\\\"https://www.chromaticqa.com/book/visual-testing-handbook\\\"><strong>视觉测试手册</strong></a>深入探讨将 Storybook 用于可视化测试组件. 免费的31页电子书. </p>\\n</li>\\n</ul>\\n<h2>谁制作了 LearnStorybook.com?</h2>\\n<p>文本,代码和制作都是由<a href=\\\"http://blog.hichroma.com/\\\">Chroma</a>. 该教程的灵感来自 Chroma的流行<a href=\\\"https://blog.hichroma.com/graphql-react-tutorial-part-1-6-d0691af25858\\\">GraphQL + React教程系列</a>. </p>\\n<p>想要更多这样的教程和文章吗? 注册 Chroma 邮件列表. </p>\\n<iframe style=\\\"height:400px;width:100%;max-width:800px;margin:30px auto;\\\" src=\\\"https://upscri.be/bface0?as_embed\\\"></iframe>\",\"excerpt\":\"结论 恭喜! 您在Storybook中创建了第一个UI. 在此过程中,您学习了如何构建,组合,测试和部署UI组件. 如果您一直关注,您的 repo和部署的Storybook 应如下所示:  📕 GitHub回购: hichroma / learnstorybook-code \\n \\n 🌎 部署 Storybook Storybook是 React,Vue和Angular 的强大工具. 它拥有蓬勃发展的开发者社区和丰富的插件. 这篇介绍揭示了可能的表面. 我们相信,一旦您采用了Storybook…\",\"frontmatter\":{\"path\":null,\"title\":\"总结\"}}},{\"node\":{\"id\":\"/Users/luz/code/js/binstd.github.io/markdown/docs/zh/contribute.md absPath of file >>> MarkdownRemark\",\"html\":\"<h1>帮忙帮忙</h1>\\n<p>鼓励学习 Storybook的贡献! 如果它像 语法或标点符号 那样小,请打开拉取请求. 如果这是一个更大的变化,<a href=\\\"https://github.com/hichroma/learnstorybook.com/issues\\\">添加一个问题</a>讨论. </p>\\n<h2>Vue和Angular版本</h2>\\n<p>我们正在寻找帮助将 React/Redux示例代码 更新为 Vue和Angular 的帮助. 评论<a href=\\\"https://github.com/hichroma/learnstorybook.com/issues/1\\\">Vue</a>要么<a href=\\\"https://github.com/hichroma/learnstorybook.com/issues/2\\\">Angular</a> GitHub问题. </p>\\n<p><img src=\\\"/logos-angular-vue.png\\\" alt=\\\"Vue and Angular contributors wanted\\\"></p>\\n<h2>翻译</h2>\\n<p>我们的目标是让所有人都能接触 Storybook. 帮助将本教程翻译成其他语言. 我们对 中文和西班牙文翻译 特别开放. 评论<a href=\\\"https://github.com/hichroma/learnstorybook.com/issues/3\\\">问题在这里</a>. </p>\",\"excerpt\":\"帮忙帮忙 鼓励学习 Storybook的贡献! 如果它像 语法或标点符号 那样小,请打开拉取请求. 如果这是一个更大的变化, 添加一个问题 讨论.  Vue和Angular版本 我们正在寻找帮助将 React/Redux示例代码 更新为 Vue和Angular 的帮助. 评论 Vue 要么 Angular  GitHub问题.  翻译 我们的目标是让所有人都能接触 Storybook. 帮助将本教程翻译成其他语言. 我们对 中文和西班牙文翻译 特别开放. 评论 问题在这里 . \",\"frontmatter\":{\"path\":null,\"title\":\"帮助我们\"}}},{\"node\":{\"id\":\"/Users/luz/code/js/binstd.github.io/markdown/docs/zh/data.md absPath of file >>> MarkdownRemark\",\"html\":\"<h1>连线数据</h1>\\n<p>到目前为止,我们创建了孤立的无状态组件 - Storybook很棒,但作用不大,除非我们在应用程序中为他们提供一些数据. </p>\\n<p>本教程不关注构建应用程序的细节,因此我们不会在此处深入研究这些细节. 但我们将花点时间研究一下 与容器组件 连接数据 的常见模式. </p>\\n<h2>容器组件</h2>\\n<p>我们的<code>TaskList</code>目前编写的组件是\\\"表现性的\\\" (见<a href=\\\"https://medium.com/@dan_abramov/smart-and-dumb-components-7ca2f9a7c7d0\\\">这篇博文</a>) 因为它不会与 其自身实现之外 的任何内容交谈. 为了获取数据,我们需要一个\\\"容器\\\". </p>\\n<p>这个例子使用<a href=\\\"https://redux.js.org/\\\">Redux</a>,最流行的React库,用于存储数据,为我们的应用程序构建一个简单的数据模型. 但是,此处使用的模式同样适用于其他数据管理库<a href=\\\"https://www.apollographql.com/client/\\\">阿波罗</a>和<a href=\\\"https://mobx.js.org/\\\">MobX</a>. </p>\\n<p>首先,我们将构建一个简单的Redux存储,它在一个<code>src/lib/redux.js</code>中定义改变任务状态的操作 (故意保持简单) : </p>\\n<pre><code class=\\\"language-javascript\\\">// 一个简单的 redux store/actions/reducer 实现。\\n// 一个真正的应用程序将更复杂，并分为不同的文件.\\nimport { createStore } from 'redux';\\n\\n// 这些行为是可能发生的store变化的“名称”\\nexport const actions = {\\n  ARCHIVE_TASK: 'ARCHIVE_TASK',\\n  PIN_TASK: 'PIN_TASK',\\n};\\n\\n// 动作创建者是将动作与 要求的数据捆绑在一起的方式\\nexport const archiveTask = id => ({ type: actions.ARCHIVE_TASK, id });\\nexport const pinTask = id => ({ type: actions.PIN_TASK, id });\\n\\n// 我们所有的Reducer都只是改变了一个任务的状态。\\nfunction taskStateReducer(taskState) {\\n  return (state, action) => {\\n    return {\\n      ...state,\\n      tasks: state.tasks.map(\\n        task => (task.id === action.id ? { ...task, state: taskState } : task)\\n      ),\\n    };\\n  };\\n}\\n\\n// reducer描述了 Store 中每个 action 如何改变内容\\n\\nexport const reducer = (state, action) => {\\n  switch (action.type) {\\n    case actions.ARCHIVE_TASK:\\n      return taskStateReducer('TASK_ARCHIVED')(state, action);\\n    case actions.PIN_TASK:\\n      return taskStateReducer('TASK_PINNED')(state, action);\\n    default:\\n      return state;\\n  }\\n};\\n\\n// 应用加载时我们Store 的初始状态。\\n\\n// 通常你会从服务器上获取它\\nconst defaultTasks = [\\n  { id: '1', title: 'Something', state: 'TASK_INBOX' },\\n  { id: '2', title: 'Something more', state: 'TASK_INBOX' },\\n  { id: '3', title: 'Something else', state: 'TASK_INBOX' },\\n  { id: '4', title: 'Something again', state: 'TASK_INBOX' },\\n];\\n\\n// 我们导出构造的 redux store\\nexport default createStore(reducer, { tasks: defaultTasks });\\n</code></pre>\\n<p>然后我们将更新默认导出<code>TaskList</code>组件连接到Redux存储,并呈现我们感兴趣的任务: </p>\\n<pre><code class=\\\"language-javascript\\\">import React from 'react';\\nimport PropTypes from 'prop-types';\\n\\nimport Task from './Task';\\nimport { connect } from 'react-redux';\\nimport { archiveTask, pinTask } from '../lib/redux';\\n\\nexport function PureTaskList({ loading, tasks, onPinTask, onArchiveTask }) {\\n  /* 以前的 TaskList 实现 */\\n}\\n\\nPureTaskList.propTypes = {\\n  loading: PropTypes.bool,\\n  tasks: PropTypes.arrayOf(Task.propTypes.task).isRequired,\\n  onPinTask: PropTypes.func.isRequired,\\n  onArchiveTask: PropTypes.func.isRequired,\\n};\\n\\nPureTaskList.defaultProps = {\\n  loading: false,\\n};\\n\\nexport default connect(\\n  ({ tasks }) => ({\\n    tasks: tasks.filter(t => t.state === 'TASK_INBOX' || t.state === 'TASK_PINNED'),\\n  }),\\n  dispatch => ({\\n    onArchiveTask: id => dispatch(archiveTask(id)),\\n    onPinTask: id => dispatch(pinTask(id)),\\n  })\\n)(PureTaskList);\\n</code></pre>\\n<p>在这个阶段,我们的 Storybook测试将停止工作,因为<code>TaskList</code>现在是一个容器,不再需要任何 props,而是连接到 Store 并设置<code>PureTaskList</code>包裹组件的props. </p>\\n<p>但是,我们可以通过简单地渲染<code>PureTaskList</code>来轻松解决这个问题 - 我们的 Storybook故事中的表现部分: </p>\\n<pre><code class=\\\"language-javascript\\\">import React from 'react';\\nimport { storiesOf } from '@storybook/react';\\n\\nimport { PureTaskList } from './TaskList';\\nimport { task, actions } from './Task.stories';\\n\\nexport const defaultTasks = [\\n  { ...task, id: '1', title: 'Task 1' },\\n  { ...task, id: '2', title: 'Task 2' },\\n  { ...task, id: '3', title: 'Task 3' },\\n  { ...task, id: '4', title: 'Task 4' },\\n  { ...task, id: '5', title: 'Task 5' },\\n  { ...task, id: '6', title: 'Task 6' },\\n];\\n\\nexport const withPinnedTasks = [\\n  ...defaultTasks.slice(0, 5),\\n  { id: '6', title: 'Task 6 (pinned)', state: 'TASK_PINNED' },\\n];\\n\\nstoriesOf('TaskList', module)\\n  .addDecorator(story => &#x3C;div style={{ padding: '3rem' }}>{story()}&#x3C;/div>)\\n  .add('default', () => &#x3C;PureTaskList tasks={defaultTasks} {...actions} />)\\n  .add('withPinnedTasks', () => &#x3C;PureTaskList tasks={withPinnedTasks} {...actions} />)\\n  .add('loading', () => &#x3C;PureTaskList loading tasks={[]} {...actions} />)\\n  .add('empty', () => &#x3C;PureTaskList tasks={[]} {...actions} />);\\n</code></pre>\\n<video autoPlay muted playsInline loop>\\n  <source\\n    src=\\\"/finished-tasklist-states.mp4\\\"\\n    type=\\\"video/mp4\\\"\\n  />\\n</video>\\n<p>同样,我们需要使用<code>PureTaskList</code>在我们的Jest测试中: </p>\\n<pre><code class=\\\"language-js\\\">import React from 'react';\\nimport ReactDOM from 'react-dom';\\nimport { PureTaskList } from './TaskList';\\nimport { withPinnedTasks } from './TaskList.stories';\\n\\nit('renders pinned tasks at the start of the list', () => {\\n  const div = document.createElement('div');\\n  const events = { onPinTask: jest.fn(), onArchiveTask: jest.fn() };\\n  ReactDOM.render(&#x3C;PureTaskList tasks={withPinnedTasks} {...events} />, div);\\n\\n  // 我们期望首先渲染标题为“任务6（固定）”的任务，而不是最后\\n  const lastTaskInput = div.querySelector('.list-item:nth-child(1) input[value=\\\"Task 6 (pinned)\\\"]');\\n  expect(lastTaskInput).not.toBe(null);\\n\\n  ReactDOM.unmountComponentAtNode(div);\\n});\\n</code></pre>\",\"excerpt\":\"连线数据 到目前为止,我们创建了孤立的无状态组件 - Storybook很棒,但作用不大,除非我们在应用程序中为他们提供一些数据.  本教程不关注构建应用程序的细节,因此我们不会在此处深入研究这些细节. 但我们将花点时间研究一下 与容器组件 连接数据 的常见模式.  容器组件 我们的 TaskList 目前编写的组件是\\\"表现性的\\\" (见 这篇博文 ) 因为它不会与 其自身实现之外 的任何内容交谈. 为了获取数据,我们需要一个\\\"容器\\\".  这个例子使用 Redux ,最流行的React…\",\"frontmatter\":{\"path\":null,\"title\":\"接连data\"}}},{\"node\":{\"id\":\"/Users/luz/code/js/binstd.github.io/markdown/docs/zh/deploy.md absPath of file >>> MarkdownRemark\",\"html\":\"<h1>部署 Storybook</h1>\\n<p>在本教程中,我们在开发机器上运行了Storybook. 您可能还想与团队分享该 Storybook,尤其是非技术成员. 值得庆幸的是,在线部署 Storybook 很容易. </p>\\n<div class=\\\"aside\\\">\\n<strong>您之前是否安装过Chromatic 测试？?</strong>\\n<br/>\\n🎉 你的故事已经部署好了！ Chromatic 在线安全地为您的故事编制索引，并在分支和提交中跟踪它们。 跳过这一章，然后转到 <a href=\\\"/conclusion\\\">总结</a>.\\n</div>\\n<h2>导出为静态应用程序</h2>\\n<p>要部署Storybook,我们首先需要将其导出为 静态Web应用程序. 这个功能已经内置到 Storybook中,我们只需要通过添加脚本来激活它<code>package.json</code>. </p>\\n<pre><code class=\\\"language-javascript\\\">{\\n  \\\"scripts\\\": {\\n    \\\"build-storybook\\\": \\\"build-storybook -c .storybook -o .storybook-static\\\"\\n  }\\n}\\n</code></pre>\\n<p>现在当你运行<code>npm run build-storybook</code>,它会输出一个 静态的<code>storybook-static</code>目录. </p>\\n<h2>持续部署</h2>\\n<p>我们希望在推送代码时共享最新版本的组件. 为此,我们需要不断部署Storybook. 我们将依靠 GitHub和Netlify 来部署我们的静态站点. 我们正在使用 Netlify免费计划. </p>\\n<h3>GitHub上</h3>\\n<p>首先,您要在本地目录中为项目设置Git. 如果您从上一个测试章节开始,请跳转到在 GitHub上 设置存储库. </p>\\n<pre><code class=\\\"language-bash\\\">$ git init\\n</code></pre>\\n<p>接下来将文件添加到第一次提交. </p>\\n<pre><code class=\\\"language-bash\\\">$ git add .\\n</code></pre>\\n<p>现在提交文件. </p>\\n<pre><code class=\\\"language-bash\\\">$ git commit -m \\\"taskbox UI\\\"\\n</code></pre>\\n<p>转到GitHub并设置存储库<a href=\\\"https://github.com/new\\\">这里</a>. 将您的仓库命名为\\\"taskbox\\\". </p>\\n<p><img src=\\\"/github-create-taskbox.png\\\" alt=\\\"GitHub setup\\\"></p>\\n<p>在新的repo设置中,复制repo的原始URL,并使用以下命令将其添加到git项目中: </p>\\n<pre><code class=\\\"language-bash\\\">$ git remote add origin https://github.com/&#x3C;your username>/taskbox.git\\n</code></pre>\\n<p>最后将回购推送到GitHub</p>\\n<pre><code class=\\\"language-bash\\\">$ git push -u origin master\\n</code></pre>\\n<h3>Netlify</h3>\\n<p>Netlify内置了持续部署服务,使我们无需配置自己的CI,即可部署Storybook. </p>\\n<div class=\\\"aside\\\">\\n如果您在公司使用CI，请在您上传的配置中添加部署脚本 <code>storybook-static</code> 到像S3这样的静态托管服务.\\n</div>\\n<p><a href=\\\"https://app.netlify.com/start\\\">在Netlify上创建一个帐户</a>然后单击\\\"创建站点\\\". </p>\\n<p><img src=\\\"/netlify-create-site.png\\\" alt=\\\"Netlify create site\\\"></p>\\n<p>然后单击GitHub按钮将,Netlify连接到GitHub. 这允许它访问我们的远程 Taskbox 仓库. </p>\\n<p>现在从选项列表中选择任务框GitHub repo. </p>\\n<p><img src=\\\"/netlify-account-picker.png\\\" alt=\\\"Netlify connect to repo\\\"></p>\\n<p>通过突出显示在其CI中运行的构建命令,以及输出静态站点的目录 来配置 Netlify. 对于分支选择 <code>master</code>. 目录是<code>storybook-static</code>. <code>yarn build-storybook</code>构建.</p>\\n<p><img src=\\\"/netlify-settings.png\\\" alt=\\\"Netlify settings\\\"></p>\\n<p>提交表单以 构建和部署代码任务箱的<code>master</code>分支. 完成后,我们将在 Netlify上 看到一条确认消息,其中包含指向 Taskbox在线 Storybook 的链接. </p>\\n<p>如果您正在跟进,您部署的 Storybook应该在线<a href=\\\"https://clever-banach-415c03.netlify.com/\\\">像这样</a>.</p>\\n<p><img src=\\\"/netlify-storybook-deploy.png\\\" alt=\\\"Netlify Storybook deploy\\\"></p>\\n<p>我们完成了 Storybook的持续部署! 现在我们可以通过链接与队友分享我们的故事. </p>\\n<p>这有助于视觉 作为 标准应用程序开发过程的 一部分审查 或 仅仅是为了展示工作💅. </p>\",\"excerpt\":\"部署 Storybook 在本教程中,我们在开发机器上运行了Storybook. 您可能还想与团队分享该 Storybook,尤其是非技术成员. 值得庆幸的是,在线部署 Storybook 很容易.  导出为静态应用程序 要部署Storybook,我们首先需要将其导出为 静态Web应用程序. 这个功能已经内置到 Storybook中,我们只需要通过添加脚本来激活它 package.json .  现在当你运行 npm run build-storybook…\",\"frontmatter\":{\"path\":null,\"title\":\"发布 Storybook\"}}},{\"node\":{\"id\":\"/Users/luz/code/js/binstd.github.io/markdown/docs/zh/get-started.md absPath of file >>> MarkdownRemark\",\"html\":\"<h1>开始吧</h1>\\n<p> Storybook 是在开发模式下 与 您的应用程序一起运行的. 它可以帮助您构建UI组件,并与 应用程序的 业务逻辑和上下文 隔离开来. 本期\\\"学习 Storybook\\\"适用于 <strong>React</strong>; <code>Vue和Angular</code>版本即将推出. </p>\\n<p><img src=\\\"/storybook-relationship.jpg\\\" alt=\\\"Storybook and your app\\\"></p>\\n<blockquote>\\n<p>整个页面 -> 拿出各种组件 -> 分隔出 <strong>每个组件</strong> /<code>组件组合</code>用来测试与文档说明</p>\\n</blockquote>\\n<h2>设置React Storybook</h2>\\n<p>我们需要按照几个步骤设置 Storybook 环境. 首先,我们想要使用<a href=\\\"https://github.com/facebook/create-react-app\\\">Create React App</a> (<strong>CRA</strong>) 快速设置我们的环境,并启用<a href=\\\"https://storybook.js.org/\\\">Storybook</a>和<a href=\\\"https://facebook.github.io/jest/\\\"> jest-笑话 </a>测试我们创建的应用. 让我们运行以下命令: </p>\\n<pre><code class=\\\"language-bash\\\"># 创建应用:\\nnpx create-react-app taskbox\\ncd taskbox\\n\\n# 加入 Storybook:\\nnpx -p @storybook/cli getstorybook\\n</code></pre>\\n<p>我们可以快速检查,我们的应用程序的各种命令是否正常工作: </p>\\n<pre><code class=\\\"language-bash\\\"># 运行 测试引擎(Jest):\\nyarn test\\n\\n# 启动 storybook 在端口:9009 :\\nyarn run storybook\\n\\n# 启动 前端 页面 在端口:3000:\\nyarn start\\n</code></pre>\\n<div class=\\\"aside\\\">\\n  注意: 如果 <code>yarn test</code> 运行错误, 你可能需要安装 <code>watchman</code> 具体问题来自 <a href=\\\"https://github.com/facebook/create-react-app/issues/871#issuecomment-252297884\\\">这个Issue</a>.\\n</div>\\n<p>我们的三个前端应用程序模式: 自动化测试 (Jest) ,组件开发 (Storybook) 和 应用程序本身. </p>\\n<p><img src=\\\"/app-three-modalities.png\\\" alt=\\\"3 modalities\\\"></p>\\n<p>根据您正在处理的应用程序的哪个部分,您可能希望同时运行其中一个或多个. 由于我们目前的重点是创建单个UI组件,因此我们将坚持运行 Storybook. </p>\\n<h2>重用CSS</h2>\\n<p>本例子<code>Taskbox</code> 重用了 <a href=\\\"https://blog.hichroma.com/graphql-react-tutorial-part-1-6-d0691af25858\\\">GraphQL 和 React Tutorial示例应用</a>中的设计元素,所以我们不需要在本教程中编写CSS. 我们只需将 LESS编译为单个CSS文件, 并将其包含在我们的应用程序中. 复制和粘贴<a href=\\\"https://github.com/hichroma/learnstorybook-code/blob/master/src/index.css\\\">这个编译的CSS</a>根据 <strong>CRA</strong>的规则 进入 <strong>src/index.css</strong> 文件. </p>\\n<p><img src=\\\"/ss-browserchrome-taskbox-learnstorybook.png\\\" alt=\\\"Taskbox UI\\\"></p>\\n<div class=\\\"aside\\\">\\n如果要修改样式，在GitHub存储库中有提供 源LESS文件。\\n</div>\\n<h2>添加资源</h2>\\n<p>我们还需要添加 字体和图标<a href=\\\"https://github.com/hichroma/learnstorybook-code/tree/master/public\\\">文件夹</a>到了<code>public/</code>文件夹. 添加 样式和静态资源 后,应用程序会奇奇怪怪的. 没关系. 因为我们还没有开发应用程序. 现在我们开始构建我们的第一个组件!</p>\",\"excerpt\":\"开始吧  Storybook 是在开发模式下 与 您的应用程序一起运行的. 它可以帮助您构建UI组件,并与 应用程序的 业务逻辑和上下文 隔离开来. 本期\\\"学习 Storybook\\\"适用于  React ;  Vue和Angular 版本即将推出.  整个页面 -> 拿出各种组件 -> 分隔出  每个组件  / 组件组合 用来测试与文档说明 设置React Storybook 我们需要按照几个步骤设置 Storybook 环境. 首先,我们想要使用 Create React App  ( CRA…\",\"frontmatter\":{\"path\":null,\"title\":\"开始吧\"}}},{\"node\":{\"id\":\"/Users/luz/code/js/binstd.github.io/markdown/docs/zh/screen.md absPath of file >>> MarkdownRemark\",\"html\":\"<h1>构建一个页面</h1>\\n<p>我们专注于从下到上构建UI; 从小做起并增加复杂性. 这样做使我们能够独立开发每个组件,找出其数据需求,并在 Storybook 中使用它. 所有这些都无需 启动服务器或构建出页面!</p>\\n<p>在本章中,我们通过组合页面中的组件,并在 Storybook中开发该页面 来继续提高复杂性. </p>\\n<h2>嵌套的容器组件</h2>\\n<p>由于我们的应用程序非常简单,我们将构建的页面非常简单,只需简单地包装<code>TaskList</code>组件 (通过Redux提供自己的数据) 在某些布局中并拉出redux中顶层<code>error</code>的字段 (假设我们在连接到 服务器时遇到问题,我们将设置该字段) . 创建<code>InboxScreen.js</code>在你的<code>components</code>夹: </p>\\n<pre><code class=\\\"language-javascript\\\">import React from 'react';\\nimport PropTypes from 'prop-types';\\nimport { connect } from 'react-redux';\\n\\nimport TaskList from './TaskList';\\n\\nexport function PureInboxScreen({ error }) {\\n  if (error) {\\n    return (\\n      &#x3C;div className=\\\"page lists-show\\\">\\n        &#x3C;div className=\\\"wrapper-message\\\">\\n          &#x3C;span className=\\\"icon-face-sad\\\" />\\n          &#x3C;div className=\\\"title-message\\\">Oh no!&#x3C;/div>\\n          &#x3C;div className=\\\"subtitle-message\\\">Something went wrong&#x3C;/div>\\n        &#x3C;/div>\\n      &#x3C;/div>\\n    );\\n  }\\n\\n  return (\\n    &#x3C;div className=\\\"page lists-show\\\">\\n      &#x3C;nav>\\n        &#x3C;h1 className=\\\"title-page\\\">\\n          &#x3C;span className=\\\"title-wrapper\\\">Taskbox&#x3C;/span>\\n        &#x3C;/h1>\\n      &#x3C;/nav>\\n      &#x3C;TaskList />\\n    &#x3C;/div>\\n  );\\n}\\n\\nPureInboxScreen.propTypes = {\\n  error: PropTypes.string,\\n};\\n\\nPureInboxScreen.defaultProps = {\\n  error: null,\\n};\\n\\nexport default connect(({ error }) => ({ error }))(PureInboxScreen);\\n</code></pre>\\n<p>我们也改变了<code>App</code>,用于渲染的组件<code>InboxScreen</code> (最终我们会使用路由器来选择正确的页面,但不要在此担心) : </p>\\n<pre><code class=\\\"language-javascript\\\">import React, { Component } from 'react';\\nimport { Provider } from 'react-redux';\\nimport store from './lib/redux';\\n\\nimport InboxScreen from './components/InboxScreen';\\n\\nclass App extends Component {\\n  render() {\\n    return (\\n      &#x3C;Provider store={store}>\\n        &#x3C;InboxScreen />\\n      &#x3C;/Provider>\\n    );\\n  }\\n}\\n\\nexport default App;\\n</code></pre>\\n<p>然而,事情变得有趣的是在 Storybook中渲染故事. </p>\\n<p>正如我们之前看到的那样<code>TaskList</code>组件是一个 <strong>容器</strong>, 这使得<code>PureTaskList</code>表示组件. 根据定义,容器组件不能简单地单独呈现; 他们希望通过一些上下文或连接到服务. 这意味着要在Storybook中呈现容器,我们必须模拟 (即提供假装版本) 它所需的上下文或服务. </p>\\n<p>放置<code>TaskList</code>进入 Storybook,我们能够通过简单地渲染<code>PureTaskList</code>,并避开容器来避开这个问题. 我们会渲染<code>PureInboxScreen</code>并在 Storybook中做类似的事情. </p>\\n<p>但是,对于<code>PureInboxScreen</code>我们有一个问题,因为虽然<code>PureInboxScreen</code>本身是表现性的,它的孩子,<code>TaskList</code>, 不是. 从某种意义上说<code>PureInboxScreen</code>被\\\"容器\\\"污染了. 所以,当我们设置我们的故事<code>InboxScreen.stories.js</code>: </p>\\n<pre><code class=\\\"language-javascript\\\">import React from 'react';\\nimport { storiesOf } from '@storybook/react';\\n\\nimport { PureInboxScreen } from './InboxScreen';\\n\\nstoriesOf('InboxScreen', module)\\n  .add('default', () => &#x3C;PureInboxScreen />)\\n  .add('error', () => &#x3C;PureInboxScreen error=\\\"Something\\\" />);\\n</code></pre>\\n<p>我们看到了虽然如此<code>error</code>故事工作得很好,我们<code>default</code>故事有一个问题,因为<code>TaskList</code>没有要连接的Redux Store . (在尝试测试时,您也会遇到类似的问题<code>PureInboxScreen</code>用单元测试) . </p>\\n<p><img src=\\\"/broken-inboxscreen.png\\\" alt=\\\"Broken inbox\\\"></p>\\n<p>避免此问题的一种方法是,永远不要在应用程序中的任何位置呈现容器组件,除非在最高级别,而是将所有要求的数据 传递到 组件层次结构中. </p>\\n<p>但是,开发人员 <strong>将</strong> 不可避免地需要在组件层次结构中,进一步渲染容器. 如果我们想要在 Storybook中渲染大部分或全部应用程序 (我们这样做!) ,我们需要一个解决此问题的方法. </p>\\n<div class=\\\"aside\\\">\\n另外，在层次结构中 传递数据 是合法的方法，尤其是在使用 <a href=\\\"http://graphql.org/\\\">GraphQL</a>. 这就是我们的建设 <a href=\\\"https://chromaticqa.com\\\">Chromatic</a> 伴随着670多个故事.\\n</div>\\n<h2>用装饰器提供上下文</h2>\\n<p>好消息是 Redux Store  很容易提供给 一个<code>InboxScreen</code>故事! 我们可以使用 Redux Store 的模拟版本 提供给到装饰器中: </p>\\n<pre><code class=\\\"language-javascript\\\">import React from 'react';\\nimport { storiesOf } from '@storybook/react';\\nimport { action } from '@storybook/addon-actions';\\nimport { Provider } from 'react-redux';\\n\\nimport { PureInboxScreen } from './InboxScreen';\\nimport { defaultTasks } from './TaskList.stories';\\n\\n// A super-simple mock of a redux store\\nconst store = {\\n  getState: () => {\\n    return {\\n      tasks: defaultTasks,\\n    };\\n  },\\n  subscribe: () => 0,\\n  dispatch: action('dispatch'),\\n};\\n\\nstoriesOf('InboxScreen', module)\\n  .addDecorator(story => &#x3C;Provider store={store}>{story()}&#x3C;/Provider>)\\n  .add('default', () => &#x3C;PureInboxScreen />)\\n  .add('error', () => &#x3C;PureInboxScreen error=\\\"Something\\\" />);\\n</code></pre>\\n<p>存在类似的方法来为其他数据库提供模拟的上下文,例如<a href=\\\"https://www.npmjs.com/package/apollo-storybook-decorator\\\">阿波罗</a>,<a href=\\\"https://github.com/orta/react-storybooks-relay-container\\\">Relay</a>和别的. </p>\\n<p>在Storybook中 循环浏览状态 可以轻松测试我们是否已正确完成此操作: </p>\\n<video autoPlay muted playsInline loop >\\n  <source\\n    src=\\\"/finished-inboxscreen-states.mp4\\\"\\n    type=\\\"video/mp4\\\"\\n  />\\n</video>\\n<h2>组件驱动开发</h2>\\n<p>我们从底部开始<code>Task</code>,然后进展到<code>TaskList</code>,现在我们在这里使用全屏UI. 我们的<code>InboxScreen</code>容纳嵌套的容器组件,并包括随附的故事. </p>\\n<video autoPlay muted playsInline loop style=\\\"width:480px; height:auto; margin: 0 auto;\\\">\\n  <source\\n    src=\\\"/component-driven-development-optimized.mp4\\\"\\n    type=\\\"video/mp4\\\"\\n  />\\n</video>\\n<p><a href=\\\"https://blog.hichroma.com/component-driven-development-ce1109d56c8e\\\"><strong>组件驱动开发</strong></a>允许您在向上移动组件层次结构时,逐渐扩展复杂性. 其中的好处包括 更集中的开发过程 以及 所有可能的UI排列 的覆盖范围. 简而言之,CDD 可帮助您构建 更高质量和更复杂 的用户界面. </p>\\n<p>我们还没有完成 - 在构建UI时,工作不会结束. 我们还需要确保它随着时间的推移保持持久. </p>\",\"excerpt\":\"构建一个页面 我们专注于从下到上构建UI; 从小做起并增加复杂性. 这样做使我们能够独立开发每个组件,找出其数据需求,并在 Storybook 中使用它. 所有这些都无需 启动服务器或构建出页面! 在本章中,我们通过组合页面中的组件,并在 Storybook中开发该页面 来继续提高复杂性.  嵌套的容器组件 由于我们的应用程序非常简单,我们将构建的页面非常简单,只需简单地包装 TaskList 组件 (通过Redux提供自己的数据) 在某些布局中并拉出redux中顶层 error…\",\"frontmatter\":{\"path\":null,\"title\":\"构建一个页面\"}}},{\"node\":{\"id\":\"/Users/luz/code/js/binstd.github.io/markdown/docs/zh/simple-component.md absPath of file >>> MarkdownRemark\",\"html\":\"<h1>构建一个简单的组件</h1>\\n<p>我们将按照<a href=\\\"https://blog.hichroma.com/component-driven-development-ce1109d56c8e\\\">组件驱动开发</a> (CDD) 方法论来 构建我们的UI. 这是一个从\\\"自下而上\\\"开始构建UI的过程,从组件开始到整个页面结束. CDD 可帮助您在构建UI时,摆列您所面临的复杂程度. </p>\\n<h2>任务-Task</h2>\\n<p><img src=\\\"/task-states-learnstorybook.png\\\" alt=\\\"Task component in three states\\\"></p>\\n<p><code>Task</code>是我们的应用程序的核心组件. 每个任务的显示略有不同,具体取决于它所处的<code>状态-state</code>. 我们显示一个选中 (或未选中) 复选框,一些有关任务的信息,以及一个\\\"pin\\\"按钮,允许我们在列表中上下移动任务. 为了把各个它们摆在一起,我们需要下面的 <strong>props</strong>: </p>\\n<ul>\\n<li>\\n<p><code>title</code> - 描述任务的字符串</p>\\n</li>\\n<li>\\n<p><code>state</code> - 哪个列表是当前的任务,是否已检查?</p>\\n</li>\\n</ul>\\n<p>在我们开始构建<code>Task</code>时,我们首先编写 与 上面草图中不同类型的任务 相对应的测试状态. 然后我们使用 Storybook 模拟数据 隔离对应状态组件. 我们将\\\"视觉测试\\\"组件在每个状态下的外观. </p>\\n<p>这个过程类似于<a href=\\\"https://en.wikipedia.org/wiki/Test-driven_development\\\">测试驱动的开发(TDD)</a>,我们可以称之为<a href=\\\"https://blog.hichroma.com/visual-test-driven-development-aec1c98bed87\\\">\\\"Visual-虚拟 TDD\\\"</a></p>\\n<h2>获取设置</h2>\\n<p>首先,让我们创建任务组件 及 其附带的 <em>storybook-故事</em> 文件: </p>\\n<p><code>src/components/Task.js</code>和<code>src/components/Task.stories.js</code></p>\\n<p>我们将从基本实现开始,简单传入我们需要的<code>属性-props</code> 以及 您可以对任务执行的两个<code>on</code>操作 (在列表之间移动它) : </p>\\n<pre><code class=\\\"language-javascript\\\">import React from 'react';\\n\\nexport default function Task({ task: { id, title, state }, onArchiveTask, onPinTask }) {\\n  return (\\n    &#x3C;div className=\\\"list-item\\\">\\n      &#x3C;input type=\\\"text\\\" value={title} readOnly={true} />\\n    &#x3C;/div>\\n  );\\n}\\n</code></pre>\\n<p>上面,我们基于 Todos应用程序现有HTML结构 为 <code>Task</code>提供简单的 markup . </p>\\n<p>下面, 我们在 故事文件中 构建 Task的 三个测试状态: </p>\\n<pre><code class=\\\"language-javascript\\\">import React from 'react';\\nimport { storiesOf } from '@storybook/react';\\nimport { action } from '@storybook/addon-actions';\\n\\nimport Task from './Task';\\n\\nexport const task = {\\n  id: '1',\\n  title: 'Test Task',\\n  state: 'TASK_INBOX',\\n  updatedAt: new Date(2018, 0, 1, 9, 0),\\n};\\n\\nexport const actions = {\\n  onPinTask: action('onPinTask'),\\n  onArchiveTask: action('onArchiveTask'),\\n};\\n\\nstoriesOf('Task', module)\\n  .add('default', () => &#x3C;Task task={task} {...actions} />)\\n  .add('pinned', () => &#x3C;Task task={{ ...task, state: 'TASK_PINNED' }} {...actions} />)\\n  .add('archived', () => &#x3C;Task task={{ ...task, state: 'TASK_ARCHIVED' }} {...actions} />);\\n</code></pre>\\n<p>Storybook中有两个基本的组织级别. </p>\\n<p>该组件 及 其 child 故事. </p>\\n<p>将每个故事 视为组件的排列. 您可以根据需要为每个组件 创建 尽可能多的故事. </p>\\n<ul>\\n<li>\\n<p><strong>组件</strong></p>\\n<ul>\\n<li>故事</li>\\n<li>故事</li>\\n<li>故事</li>\\n</ul>\\n</li>\\n</ul>\\n<p>要开始 Storybook,我们先运<code>行 注册组件的</code>storiesOf()`函数. 我们为组件添加 <em>显示名称 -  Storybook应用程序侧栏上显示的名称</em>. </p>\\n<p><code>action()</code>允许我们创建一个回调, 当在Storybook UI的面板中 单击这个 <strong>action</strong> 时 回调触发. 因此,当我们构建一个pin按钮 时,我们将能够在 测试UI中 确定按钮单击 是否成功. </p>\\n<p>由于我们需要将 相同的一组操作 传递给 组件的所有排列,因此将它们捆绑到<code>actions</code>变量 并 使用React<code>{...actions}</code>的<code>porps</code>扩展以立即传递它们. <code>&#x3C;Task {...actions}></code>相当于<code>&#x3C;Task onPinTask={actions.onPinTask} onArchiveTask={actions.onArchiveTask}></code>. </p>\\n<p>关于捆绑<code>actions</code>的另一个好处就是,你可以<code>export-暴露</code>它们,用于重用该组件的组件,我们稍后会看到. </p>\\n<p>为了定义我们的故事,我们用<code>add()</code>,一次一个为我们的每个测试状态生成一个故事. <code>add</code>第二个参数是一个函数,它返回一个给定状态的渲染元素 (即带有一组<code>props</code>的组件类)  - 就像一个React<a href=\\\"https://reactjs.org/docs/components-and-props.html\\\">无状态功能组件</a>. </p>\\n<p>在创建故事时,我们使用基本任务 (<code>task</code>) 构建组件期望的 任务的形状. 这通常是 根据真实数据的模型建模的. 再次,正如我们所看到的,<code>export</code>这种形状将使我们能够在以后的故事中重复使用它. </p>\\n<div class=\\\"aside\\\">\\n<a href=\\\"https://storybook.js.org/addons/introduction/#2-native-addons\\\"><b>Actions</b></a> 帮助您在隔离构建UI组件时 验证交互. 通常，您无法访问应用程序上下文中的函数和状态。 使用 <code>action()</code> 将它们存入.\\n</div>\\n<h2>配置</h2>\\n<p>我们还必须对 Storybook的配置设置 (<code>.storybook/config.js</code>) 做一个小改动,让它注意到我们的<code>.stories.js</code>文件并使用我们的CSS文件. 默认情况下, Storybook 会查找故事<code>/stories</code>目录; 本教程使用类似于<code>.test.js</code>的命名方案, 这个命令是 <strong>CRA</strong> 赞成的用于自动化测试的方案. </p>\\n<pre><code class=\\\"language-javascript\\\">import { configure } from '@storybook/react';\\nimport '../src/index.css';\\n\\nconst req = require.context('../src', true, /.stories.js$/);\\n\\nfunction loadStories() {\\n  req.keys().forEach(filename => req(filename));\\n}\\n\\nconfigure(loadStories, module);\\n</code></pre>\\n<p>完成此操作后,重新启动 Storybook服务器 应该会产生 三个任务状态的测试用例: </p>\\n<video autoPlay muted playsInline controls >\\n  <source\\n    src=\\\"/inprogress-task-states.mp4\\\"\\n    type=\\\"video/mp4\\\"\\n  />\\n</video>\\n<h2>建立状态</h2>\\n<p>现在我们有 Storybook设置,导入的样式和构建的测试用例,我们可以快速开始实现组件的HTML,以匹配设计. </p>\\n<p>该组件目前仍然是基本的. 首先编写实现设计的代码,不用过多细节: </p>\\n<pre><code class=\\\"language-javascript\\\">import React from 'react';\\n\\nexport default function Task({ task: { id, title, state }, onArchiveTask, onPinTask }) {\\n  return (\\n    &#x3C;div className={`list-item ${state}`}>\\n      &#x3C;label className=\\\"checkbox\\\">\\n        &#x3C;input\\n          type=\\\"checkbox\\\"\\n          defaultChecked={state === 'TASK_ARCHIVED'}\\n          disabled={true}\\n          name=\\\"checked\\\"\\n        />\\n        &#x3C;span className=\\\"checkbox-custom\\\" onClick={() => onArchiveTask(id)} />\\n      &#x3C;/label>\\n      &#x3C;div className=\\\"title\\\">\\n        &#x3C;input type=\\\"text\\\" value={title} readOnly={true} placeholder=\\\"Input title\\\" />\\n      &#x3C;/div>\\n\\n      &#x3C;div className=\\\"actions\\\" onClick={event => event.stopPropagation()}>\\n        {state !== 'TASK_ARCHIVED' &#x26;&#x26; (\\n          &#x3C;a onClick={() => onPinTask(id)}>\\n            &#x3C;span className={`icon-star`} />\\n          &#x3C;/a>\\n        )}\\n      &#x3C;/div>\\n    &#x3C;/div>\\n  );\\n}\\n</code></pre>\\n<p>上面的附加 markup 与我们之前导入的CSS相结合,产生以下UI: </p>\\n<video autoPlay muted playsInline loop>\\n  <source\\n    src=\\\"/finished-task-states.mp4\\\"\\n    type=\\\"video/mp4\\\"\\n  />\\n</video>\\n<h2>特别数据要求</h2>\\n<p>最好的做法是<code>propTypes</code>在React中 指定组件所需的 数据形状. 它不仅可以自我记录,还有助于及早发现问题. </p>\\n<pre><code class=\\\"language-javascript\\\">import React from 'react';\\nimport PropTypes from 'prop-types';\\n\\nfunction Task() {\\n  ...\\n}\\n\\nTask.propTypes = {\\n  task: PropTypes.shape({\\n    id: PropTypes.string.isRequired,\\n    title: PropTypes.string.isRequired,\\n    state: PropTypes.string.isRequired,\\n  }),\\n  onArchiveTask: PropTypes.func,\\n  onPinTask: PropTypes.func,\\n};\\n\\nexport default Task;\\n</code></pre>\\n<p>现在,如果任务组件被滥用,则会出现开发警告. </p>\\n<div class=\\\"aside\\\">\\n另一种实现方法是使用 类似TypeScript的JavaScript类型系统 来为组件属性 创建类型。\\n</div>\\n<h2>组件构建!</h2>\\n<p>我们现在已成功构建了一个组件,没用到服务器或运行整个前端应用程序. 下一步是以类似的方式逐个构建剩余的 Taskbox组件. </p>\\n<p>如您所见,开始单独构建组件非常简单快捷. 我们可以期望生成更高质量的UI,减少错误和更多打磨,因为它可以挖掘并测试每个可能的状态. </p>\\n<h2>自动化测试</h2>\\n<p> Storybook 为我们提供了一种在施工期间,<code>可视化</code>测试我们的应用程序.在我们继续开发应用程序时,\\\"故事\\\"将有助于确保我们不会在视觉上打破我们的任务.\\n但是,在这个阶段,这是一个完全手动的过程,有人必须努力点击每个测试状态,并确保它呈现良好且没有错误或警告.\\n我们不能自动这样做吗?</p>\\n<h3>快照测试</h3>\\n<p>快照测试是指,记录 带一定输入的组件的\\\"已知良好\\\"输出,然后,将来 输出发生变化时标记组件 的做法.\\n这补充了 Storybook,因为快照 是查看 组件新版本 并 检查更改的快速方法. </p>\\n<div class=\\\"aside\\\">\\n确保您的组件呈现 <b>不变</b> 的数据，以便每次快照测试都不会失败。 注意日期或随机生成的值等内容。\\n</div>\\n<p>需要<a href=\\\"https://github.com/storybooks/storybook/tree/master/addons/storyshots\\\">Storyshots 插件</a>为每个故事创建 快照测试.\\n通过添加开发依赖项来使用它: </p>\\n<pre><code class=\\\"language-bash\\\">yarn add --dev @storybook/addon-storyshots react-test-renderer\\n</code></pre>\\n<p>然后创建一个<code>src/storybook.test.js</code>文件中包含以下内容: </p>\\n<pre><code class=\\\"language-javascript\\\">import initStoryshots from '@storybook/addon-storyshots';\\ninitStoryshots();\\n</code></pre>\\n<p>完成上述操作后,我们就可以运行了<code>yarn test</code>并看到以下输出: </p>\\n<p><img src=\\\"/task-testrunner.png\\\" alt=\\\"Task test runner\\\"></p>\\n<p>我们现在为每个<code>Task</code>故事进行快照测试. 如果我们改变了<code>Task</code>的实现,我们会提示您验证更改. </p>\",\"excerpt\":\"构建一个简单的组件 我们将按照 组件驱动开发  (CDD) 方法论来 构建我们的UI. 这是一个从\\\"自下而上\\\"开始构建UI的过程,从组件开始到整个页面结束. CDD 可帮助您在构建UI时,摆列您所面临的复杂程度.  任务-Task Task 是我们的应用程序的核心组件. 每个任务的显示略有不同,具体取决于它所处的 状态-state . 我们显示一个选中 (或未选中) 复选框,一些有关任务的信息,以及一个\\\"pin…\",\"frontmatter\":{\"path\":null,\"title\":\"构建一个简单的组件\"}}},{\"node\":{\"id\":\"/Users/luz/code/js/binstd.github.io/markdown/docs/zh/test.md absPath of file >>> MarkdownRemark\",\"html\":\"<h1>测试UI组件</h1>\\n<p>Storybook教程没有测试是不完整的. 测试对于创建高质量的UI至关重要. 在模块化系统中,微小的调整可能导致重大的回溯. 到目前为止,我们遇到了三种类型的测试</p>\\n<ul>\\n<li><strong>视觉测试</strong> 依赖开发人员手动查看组件以验证其正确性. 它们帮助我们在构建时检查组件的外观. </li>\\n<li><strong>快照测试</strong> 使用Storyshots捕获组件的渲染标记. 它们可以帮助我们及时了解导致 渲染错误和警告的标记更改. </li>\\n<li><strong>单元测试</strong> 使用Jest验证 在给定固定输入的情况下 组件的输出保持不变. 它们非常适合测试组件的功能质量. </li>\\n</ul>\\n<h2>\\\"但看起来不错吗?\\\"</h2>\\n<p>不幸的是,单独的上述测试方法不足以防止UI错误. 用户界面很难测试,因为设计是主观的,细致入微的. 可视化测试 过于手动,快照测试在用于UI时 会触发太多误报,而 像素级单元测试的价值很低. 完整的 Storybook测试策略 还包括视觉回溯测试. </p>\\n<h2>Storybook的视觉回溯测试</h2>\\n<p>视觉回溯测试旨在捕捉外观的变化. 他们通过捕获每个故事的屏幕截图,并将它们提交到 表面更改 进行比较工作. 这非常适合验证布局,颜色,大小和对比度等图形元素. </p>\\n<video autoPlay muted playsInline loop style=\\\"width:480px; margin: 0 auto;\\\">\\n  <source\\n    src=\\\"/visual-regression-testing.mp4\\\"\\n    type=\\\"video/mp4\\\"\\n  />\\n</video>\\n<p> Storybook 是视觉回溯测试的绝佳工具,因为每个故事本质上都是一个测试规范. 每次我们编写或更新故事时,我们都会免费获得规格!</p>\\n<p>有许多用于视觉回溯测试的工具. 对于专业团队,我们建议<a href=\\\"https://www.chromaticqa.com/\\\"><strong>Chromatic</strong></a>,由 Storybook维护者制作的插件,在云中运行测试. </p>\\n<h2>设置视觉回溯测试</h2>\\n<p>Chromatic 是一个无障碍的 Storybook插件,用于在云中进行视觉回溯测试和审查. 由于它是付费服务 (免费试用) ,因此可能并非适合所有人. 但是,Chromatic 是生产视觉测试工作流程的一个有益的例子,我们将免费试用. 我们来看一下. </p>\\n<h3>初始化Git</h3>\\n<p>首先,您要在本地目录中为项目设置Git. Chromatic 使用 Git历史记录 来跟踪您的UI组件. </p>\\n<pre><code class=\\\"language-bash\\\">$ git init\\n</code></pre>\\n<p>接下来将文件添加到第一次提交. </p>\\n<pre><code class=\\\"language-bash\\\">$ git add .\\n</code></pre>\\n<p>现在提交文件. </p>\\n<pre><code class=\\\"language-bash\\\">$ git commit -m \\\"taskbox UI\\\"\\n</code></pre>\\n<h3>获得 Chromatic</h3>\\n<p>将包添加为依赖项. </p>\\n<pre><code class=\\\"language-bash\\\">yarn add storybook-chromatic\\n</code></pre>\\n<p>导入Chromatic 到你的<code>.storybook/config.js</code>文件. </p>\\n<pre><code class=\\\"language-javascript\\\">import { configure } from '@storybook/react';\\nimport 'storybook-chromatic/storybook-addon';\\n\\nimport '../src/index.css';\\n\\nconst req = require.context('../src/components', true, /\\\\.stories\\\\.js$/);\\n\\nfunction loadStories() {\\n  req.keys().forEach(filename => req(filename));\\n}\\n\\nconfigure(loadStories, module);\\n</code></pre>\\n<p>然后<a href=\\\"https://chromaticqa.com/start\\\">登录Chromatic</a>使用您的GitHub帐户 (Chromatic仅要求轻量级权限) . 创建名为\\\"taskbox\\\"的项目并复制您的唯一项目<code>app-code</code>. </p>\\n<video autoPlay muted playsInline loop style=\\\"width:520px; margin: 0 auto;\\\">\\n  <source\\n    src=\\\"/chromatic-setup-learnstorybook.mp4\\\"\\n    type=\\\"video/mp4\\\"\\n  />\\n</video>\\n<p>在命令行中运行 test命令 以设置Storybook的可视化回溯测试. 不要忘记添加您的 唯一应用代码 来代替<code>&#x3C;app-code></code>. </p>\\n<pre><code class=\\\"language-bash\\\">./node_modules/.bin/chromatic test --storybook-addon --app-code=&#x3C;app-code> --do-not-start\\n</code></pre>\\n<div class=\\\"aside\\\">\\n<code>--do-not-start</code> 是一个选项，告诉 Chromatic 不要启动故事书。 如果您已经运行了故事书，请使用此选项。 如果没有会省略 <code>--do-not-start</code>.\\n</div>\\n<p>第一次测试完成后, 我们会为每个故事提供测试基准. 换句话说,每个故事的屏幕截图都被称为\\\"good\\\". 这些故事的未来变化 将与 基线进行比较. </p>\\n<p><img src=\\\"/chromatic-baselines.png\\\" alt=\\\"Chromatic baselines\\\"></p>\\n<h2>捕获UI更改</h2>\\n<p>视觉回溯测试 依赖于将 新呈现的UI代码的图像 与 基线图像 进行比较. 如果捕获到UI更改,则会收到通知. 通过调整背景 来了解它是如何工作的<code>Task</code>组件: </p>\\n<p><img src=\\\"/chromatic-change-to-task-component.png\\\" alt=\\\"code change\\\"></p>\\n<p>这会为项目生成新的背景颜色. </p>\\n<p><img src=\\\"/chromatic-task-change.png\\\" alt=\\\"task background change\\\"></p>\\n<p>使用之前的test命令运行另一个Chromatic测试. </p>\\n<pre><code class=\\\"language-bash\\\">./node_modules/.bin/chromatic test --storybook-addon --app-code=&#x3C;app-code> --do-not-start\\n</code></pre>\\n<p>点击您将看到 更改的网络用户界面 链接. </p>\\n<p><img src=\\\"/chromatic-catch-changes.png\\\" alt=\\\"UI changes in Chromatic\\\"></p>\\n<p>有很多变化! 组件层次结构表明 <code>Task</code>是<code>TaskList</code>的孩子和<code>Inbox</code>意味着一个小小的调整滚雪球成为主要的回溯. 这种情况正是开发人员除了其他测试方法之外,还需要视觉回溯测试的原因. </p>\\n<p><img src=\\\"/minor-major-regressions.gif\\\" alt=\\\"UI minor tweaks major regressions\\\"></p>\\n<h2>查看更改</h2>\\n<p>视觉回溯测试确保组件不会意外更改. 但是,您仍然需要确定更改是否是有意的. </p>\\n<p>如果有意更改,则需要更新基线,以便将来的测试与故事的最新版本进行比较. 如果改变是无意的,则需要修复. </p>\\n<video autoPlay muted playsInline loop style=\\\"width:480px; margin: 0 auto;\\\">\\n  <source\\n    src=\\\"/website-workflow-review-merge-optimized.mp4\\\"\\n    type=\\\"video/mp4\\\"\\n  />\\n</video>\\n<p>由于现代应用程序是 由组件构建的,因此我们在组件级别 进行测试非常重要. 这样做有助于我们找出变化的根本原因,即组件,而不是对 变化的症状,页面 和 复合组件 做出反应. </p>\\n<h2>合并更改</h2>\\n<p>当我们完成审核后,我们已准备好自信地合并 UI更改 - 知道更新不会意外地引入错误. 如果你喜欢新的<code>papayawhip</code>背景色,然后接受更改,如果不需要恢复到以前的状态. </p>\\n<p><img src=\\\"/chromatic-review-finished.png\\\" alt=\\\"Changes ready to be merged\\\"></p>\\n<p> Storybook可以帮助你 <strong>建立</strong> 组件;测试可以帮助你 <strong>保持</strong> 他们. 本教程介绍了四种类型的UI测试,包括 可视化,快照,单元和可视化回溯测试. 您可以通过将它们添加到 CI脚本 来自动执行最后三个. 这有助于您运输组件 而不必担心 偷渡漏洞. 整个工作流程如下所示. </p>\\n<p><img src=\\\"/cdd-review-workflow.png\\\" alt=\\\"Visual regression testing workflow\\\"></p>\",\"excerpt\":\"测试UI组件 Storybook教程没有测试是不完整的. 测试对于创建高质量的UI至关重要. 在模块化系统中,微小的调整可能导致重大的回溯. 到目前为止,我们遇到了三种类型的测试 视觉测试  依赖开发人员手动查看组件以验证其正确性. 它们帮助我们在构建时检查组件的外观.  快照测试  使用Storyshots捕获组件的渲染标记. 它们可以帮助我们及时了解导致 渲染错误和警告的标记更改.  单元测试  使用Jest…\",\"frontmatter\":{\"path\":null,\"title\":\"测试\"}}}]}},\"pathContext\":{}}\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/json-loader!./.cache/json/index.json\n// module id = 886\n// module chunks = 142629428675168"],"sourceRoot":""}